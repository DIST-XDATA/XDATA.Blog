{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/material/source/css/disqus-proxy.css","path":"css/disqus-proxy.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/duoshuo.min.css","path":"css/duoshuo.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/disqus-proxy.min.css","path":"css/disqus-proxy.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/duoshuo.css","path":"css/duoshuo.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/gallery.min.css","path":"css/gallery.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/fontawesome.min.css","path":"css/fontawesome.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/ie-blocker.css","path":"css/ie-blocker.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/material-icons.css","path":"css/material-icons.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify.css","path":"css/prettify.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify.min.css","path":"css/prettify.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/uc.css","path":"css/uc.css","modified":1,"renderable":1},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.woff","path":"fonts/MaterialIcons-Regular.woff","modified":1,"renderable":1},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.woff2","path":"fonts/MaterialIcons-Regular.woff2","modified":1,"renderable":1},{"_id":"themes/material/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/browserstack_logo.png","path":"img/browserstack_logo.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/bg.png","path":"img/bg.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/logo.png","path":"img/logo.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/sidebar_header.png","path":"img/sidebar_header.png","modified":1,"renderable":1},{"_id":"themes/material/source/js/MathJax.js","path":"js/MathJax.js","modified":1,"renderable":1},{"_id":"themes/material/source/js/ie-blocker.zhCN.js","path":"js/ie-blocker.zhCN.js","modified":1,"renderable":1},{"_id":"themes/material/source/js/Valine.min.js","path":"js/Valine.min.js","modified":1,"renderable":1},{"_id":"themes/material/source/js/lazyload.min.js","path":"js/lazyload.min.js","modified":1,"renderable":1},{"_id":"themes/material/source/js/ie-blocker.en.js","path":"js/ie-blocker.en.js","modified":1,"renderable":1},{"_id":"themes/material/source/js/hanabi-browser-bundle.js","path":"js/hanabi-browser-bundle.js","modified":1,"renderable":1},{"_id":"themes/material/source/js/prettify.min.js","path":"js/prettify.min.js","modified":1,"renderable":1},{"_id":"themes/material/source/js/lsloader.js","path":"js/lsloader.js","modified":1,"renderable":1},{"_id":"themes/material/source/js/queue.min.js","path":"js/queue.min.js","modified":1,"renderable":1},{"_id":"themes/material/source/js/nprogress.js","path":"js/nprogress.js","modified":1,"renderable":1},{"_id":"themes/material/source/js/lsloader.min.js","path":"js/lsloader.min.js","modified":1,"renderable":1},{"_id":"themes/material/source/img/upyun_logo.svg","path":"img/upyun_logo.svg","modified":1,"renderable":1},{"_id":"themes/material/source/js/queue.js","path":"js/queue.js","modified":1,"renderable":1},{"_id":"themes/material/source/js/smoothscroll.js","path":"js/smoothscroll.js","modified":1,"renderable":1},{"_id":"themes/material/source/css/material.css","path":"css/material.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/material.min.css","path":"css/material.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/style.min.css","path":"css/style.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/style.css","path":"css/style.css","modified":1,"renderable":1},{"_id":"themes/material/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/material/source/img/daily_pic.png","path":"img/daily_pic.png","modified":1,"renderable":1},{"_id":"themes/material/source/fonts/fontawesome-webfont.woff2","path":"fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/material/source/js/jquery.min.js","path":"js/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/material/source/js/js.min.js","path":"js/js.min.js","modified":1,"renderable":1},{"_id":"themes/material/source/js/js.js","path":"js/js.js","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-cave-dark.min.css","path":"css/prettify/atelier-cave-dark.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-cave-light.min.css","path":"css/prettify/atelier-cave-light.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-dune-light.min.css","path":"css/prettify/atelier-dune-light.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-dune-dark.min.css","path":"css/prettify/atelier-dune-dark.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-estuary-dark.min.css","path":"css/prettify/atelier-estuary-dark.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-estuary-light.min.css","path":"css/prettify/atelier-estuary-light.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-forest-light.min.css","path":"css/prettify/atelier-forest-light.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-heath-dark.min.css","path":"css/prettify/atelier-heath-dark.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-lakeside-dark.min.css","path":"css/prettify/atelier-lakeside-dark.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-heath-light.min.css","path":"css/prettify/atelier-heath-light.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-forest-dark.min.css","path":"css/prettify/atelier-forest-dark.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-plateau-light.min.css","path":"css/prettify/atelier-plateau-light.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-plateau-dark.min.css","path":"css/prettify/atelier-plateau-dark.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-lakeside-light.min.css","path":"css/prettify/atelier-lakeside-light.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-savanna-dark.min.css","path":"css/prettify/atelier-savanna-dark.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-seaside-light.min.css","path":"css/prettify/atelier-seaside-light.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-sulphurpool-dark.min.css","path":"css/prettify/atelier-sulphurpool-dark.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/github.min.css","path":"css/prettify/github.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-savanna-light.min.css","path":"css/prettify/atelier-savanna-light.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-sulphurpool-light.min.css","path":"css/prettify/atelier-sulphurpool-light.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/github-v2.min.css","path":"css/prettify/github-v2.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/hemisu-dark.min.css","path":"css/prettify/hemisu-dark.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-seaside-dark.min.css","path":"css/prettify/atelier-seaside-dark.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/tomorrow-night-bright.min.css","path":"css/prettify/tomorrow-night-bright.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/tomorrow-night-blue.min.css","path":"css/prettify/tomorrow-night-blue.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/tomorrow-night-eighties.min.css","path":"css/prettify/tomorrow-night-eighties.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/hemisu-light.min.css","path":"css/prettify/hemisu-light.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/tomorrow-night.min.css","path":"css/prettify/tomorrow-night.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/tomorrow.min.css","path":"css/prettify/tomorrow.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.ttf","path":"fonts/MaterialIcons-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/tranquil-heart.min.css","path":"css/prettify/tranquil-heart.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.eot","path":"fonts/MaterialIcons-Regular.eot","modified":1,"renderable":1},{"_id":"themes/material/source/css/prettify/vibrant-ink.min.css","path":"css/prettify/vibrant-ink.min.css","modified":1,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-facebook.svg","path":"img/footer/footer_ico-facebook.svg","modified":1,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-github.svg","path":"img/footer/footer_ico-github.svg","modified":1,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-bilibili.svg","path":"img/footer/footer_ico-bilibili.svg","modified":1,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-gplus.svg","path":"img/footer/footer_ico-gplus.svg","modified":1,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-linkedin.svg","path":"img/footer/footer_ico-linkedin.svg","modified":1,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-instagram.svg","path":"img/footer/footer_ico-instagram.svg","modified":1,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-tumblr.svg","path":"img/footer/footer_ico-tumblr.svg","modified":1,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-twitter.svg","path":"img/footer/footer_ico-twitter.svg","modified":1,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-telegram.svg","path":"img/footer/footer_ico-telegram.svg","modified":1,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-v2ex.svg","path":"img/footer/footer_ico-v2ex.svg","modified":1,"renderable":1},{"_id":"themes/material/source/img/gallery/arrow.svg","path":"img/gallery/arrow.svg","modified":1,"renderable":1},{"_id":"themes/material/source/img/gallery/close.svg","path":"img/gallery/close.svg","modified":1,"renderable":1},{"_id":"themes/material/source/img/random/material-10.png","path":"img/random/material-10.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/random/material-12.png","path":"img/random/material-12.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/random/material-17.png","path":"img/random/material-17.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-zhihu.svg","path":"img/footer/footer_ico-zhihu.svg","modified":1,"renderable":1},{"_id":"themes/material/source/img/random/material-4.png","path":"img/random/material-4.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/gallery/spinner.svg","path":"img/gallery/spinner.svg","modified":1,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-weibo.svg","path":"img/footer/footer_ico-weibo.svg","modified":1,"renderable":1},{"_id":"themes/material/source/img/random/material-19.png","path":"img/random/material-19.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/random/material-3.png","path":"img/random/material-3.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/random/material-9.png","path":"img/random/material-9.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/random/material-6.png","path":"img/random/material-6.png","modified":1,"renderable":1},{"_id":"themes/material/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/material/source/js/gallery/gallery.js","path":"js/gallery/gallery.js","modified":1,"renderable":1},{"_id":"themes/material/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/material/source/img/random/material-11.png","path":"img/random/material-11.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/random/material-13.png","path":"img/random/material-13.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/random/material-1.png","path":"img/random/material-1.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/random/material-14.png","path":"img/random/material-14.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/random/material-16.png","path":"img/random/material-16.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/random/material-2.png","path":"img/random/material-2.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/random/material-5.png","path":"img/random/material-5.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/random/material-15.png","path":"img/random/material-15.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/random/material-8.png","path":"img/random/material-8.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/random/material-18.png","path":"img/random/material-18.png","modified":1,"renderable":1},{"_id":"themes/material/source/img/random/material-7.png","path":"img/random/material-7.png","modified":1,"renderable":1},{"_id":"themes/material/source/fonts/Roboto-Medium.ttf","path":"fonts/Roboto-Medium.ttf","modified":1,"renderable":1},{"_id":"themes/material/source/fonts/Roboto-Light.ttf","path":"fonts/Roboto-Light.ttf","modified":1,"renderable":1},{"_id":"themes/material/source/fonts/Roboto-Bold.ttf","path":"fonts/Roboto-Bold.ttf","modified":1,"renderable":1},{"_id":"themes/material/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/material/source/fonts/Roboto-Black.ttf","path":"fonts/Roboto-Black.ttf","modified":1,"renderable":1},{"_id":"themes/material/source/fonts/Roboto-Regular.ttf","path":"fonts/Roboto-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/material/source/fonts/Roboto-Thin.ttf","path":"fonts/Roboto-Thin.ttf","modified":1,"renderable":1}],"Cache":[{"_id":"themes/material/.gitignore","hash":"dd9e9495fc7ce09c026f7fdcef45cf8ddfde40d8","modified":1512210625000},{"_id":"themes/material/CONTRIBUTING.md","hash":"148f555e47d4725fe1faac775107a4d7b03f7136","modified":1512210625000},{"_id":"themes/material/.eslintrc.json","hash":"83ddc0cdc18f28b967795b8dac0421a52cdf7ece","modified":1512210625000},{"_id":"themes/material/CONTRIBUTING.zh-cn.md","hash":"ef3ccef0451d6ac616b3a35fbfedb6abd35e6b41","modified":1512210625000},{"_id":"themes/material/.travis.yml","hash":"10a09fe2b341ccad5b97d4bd9cc2c1c03e1863a3","modified":1512210625000},{"_id":"themes/material/lint.sh","hash":"49c3a65f8ca65754ec7fefcd2dcb6adc187f3856","modified":1512210625000},{"_id":"themes/material/README.md","hash":"408e36745a8aeb187a25f309752c5e7da66f7e67","modified":1512210625000},{"_id":"themes/material/_config.yml","hash":"192353127dc4182eaa70d83f17a02350f85882e8","modified":1534152567359},{"_id":"themes/material/LICENSE","hash":"12d81f50767d4e09aa7877da077ad9d1b915d75b","modified":1512210625000},{"_id":"themes/material/package.json","hash":"e00885ee25ac548685af9869cf4cf895118a744c","modified":1512210625000},{"_id":"themes/material/contributing.json","hash":"1bc0871b1c7822b82533b614090ac0ab7c55282c","modified":1512210625000},{"_id":"source/about/index.md","hash":"a29f5c7e50a15df52acb0bf7dcf8586e35f1b73c","modified":1528866233243},{"_id":"themes/material/_config.template.yml","hash":"909c9b66c782311a0fe16bca4e75dc13e1b289ea","modified":1512210625000},{"_id":"themes/material/languages/de.yml","hash":"bce37d066ffa82f3e249d41d0ee883c913cc2c5f","modified":1512210625000},{"_id":"themes/material/languages/es.yml","hash":"d35f5411bc87277cc2d3a58d9499ddb9cfd46f1b","modified":1512210625000},{"_id":"themes/material/languages/en.yml","hash":"b59136a1b4d0a77e550b0e7e2e430cac44230dd3","modified":1512210625000},{"_id":"themes/material/languages/fr.yml","hash":"f456cf31a72d97f2f18e3bb6cf735285d2b9d2c5","modified":1512210625000},{"_id":"themes/material/languages/ja.yml","hash":"768b8330c9c73287efd475e68741ce4ebad29fd1","modified":1512210625000},{"_id":"themes/material/languages/ms.yml","hash":"237a39bbfcce33e7b918f6c5dc0f01bc79900262","modified":1512210625000},{"_id":"themes/material/languages/nl_NL.yml","hash":"b71e59807716185627d6b9b84e44a79401df639f","modified":1512210625000},{"_id":"themes/material/languages/pt-BR.yml","hash":"a070c2c4d0d3d54f8ca70513cff73c3f7c306db1","modified":1512210625000},{"_id":"themes/material/languages/ar.yml","hash":"472d71f052e08f3c03b15dd67d11ad41f2eee7bf","modified":1512210625000},{"_id":"themes/material/.github/ISSUE_TEMPLATE.md","hash":"52a733a4d2e21a9c4d719495a0353c6719484f9f","modified":1512210625000},{"_id":"themes/material/.github/PULL_REQUEST_TEMPLATE.md","hash":"f2a3a0b929c0909ab99c96fb82853c2c2d67961a","modified":1512210625000},{"_id":"themes/material/languages/zh-CN.yml","hash":"c188cad1a16ab0651e2d2d03cb3fa79962cf65ff","modified":1512210625000},{"_id":"themes/material/languages/ru.yml","hash":"fbff2cf48dbde45adcad781e2fd6c30b523a4ac1","modified":1512210625000},{"_id":"themes/material/scripts/helper.js","hash":"e7111a8b1f0ab5bf3466378c48c260a4f6e527d6","modified":1512210625000},{"_id":"themes/material/languages/zh-TW.yml","hash":"ec55953f0330f81bf1ffb37ff34de258dfda642a","modified":1512210625000},{"_id":"themes/material/layout/layout.ejs","hash":"94f66850b815a262c0f8ff112a32a0a6f43066e3","modified":1512210625000},{"_id":"themes/material/layout/index.ejs","hash":"aca1abb741f891776913c8ea2e6ff626a0ea5736","modified":1512210625000},{"_id":"themes/material/layout/post.ejs","hash":"4dd572a9e84f3a6baa5e3f16d270e58e3cd31a23","modified":1512210625000},{"_id":"themes/material/layout/_partial/Isolation-post-info.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1512210625000},{"_id":"themes/material/scripts/lib/font_lsload.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1512210625000},{"_id":"source/_posts/MOBILE/在线缓存功能开发分享.md","hash":"e1a66cb348282be054c4c0769632c288a21bd7a0","modified":1535709326632},{"_id":"source/_posts/MOBILE/用地分析.md","hash":"6e97cb34043294aad8b47aa17de4cbd5f52540ba","modified":1535709300396},{"_id":"source/_posts/MOBILE/移动一张图专题分析.md","hash":"e6b77038bcecde5b8f4fd2967d9078d33b4c012c","modified":1535709330177},{"_id":"source/_posts/HEXO/hello-world.md","hash":"bf6cb97c8f24565b41ebe90690217a5a180f3f30","modified":1528870820740},{"_id":"source/_posts/HEXO/How-To-Build-Personal-Blog-By-Hexo.md","hash":"8a83b5dbf537c4a4cb111128db9349be3323a326","modified":1528870814550},{"_id":"source/_posts/HEXO/Hexo配置完善.md","hash":"622d696569d64e954e9f179f08c8feb86692ca9f","modified":1528870805341},{"_id":"themes/material/layout/_partial/Paradox-post_entry-thumbnail.ejs","hash":"4d740eba338517d4e10d011a157cdefad45a8e1f","modified":1512210625000},{"_id":"themes/material/layout/_partial/Paradox-post-thumbnail.ejs","hash":"6f1e9a85c089ce98a36a2954839fb9ce3e53739e","modified":1512210625000},{"_id":"themes/material/layout/_partial/Paradox-post-info.ejs","hash":"125cfa5cd9e6e1ca5e958026fdd42f3c3141e34f","modified":1512210625000},{"_id":"themes/material/layout/_partial/comment.ejs","hash":"c9fb1f98a18ca484cb52d60e2ad2bad25b56dfb2","modified":1512210625000},{"_id":"themes/material/layout/_partial/Isolation-post_entry.ejs","hash":"134dc82320b7aed7d4d78960be63e16c5c4a30fb","modified":1512210625000},{"_id":"themes/material/layout/_partial/Paradox-search.ejs","hash":"18a6971b04feccd124a096b8c7cecf1fd4bb914e","modified":1512210625000},{"_id":"themes/material/layout/_partial/Paradox-post_entry.ejs","hash":"5f4d67e5bd70f635203706cf344b036d891073e6","modified":1512210625000},{"_id":"themes/material/layout/_partial/config_css.ejs","hash":"2b1e27faa0446a5e756e61ddf3e969e50948f1ce","modified":1512210625000},{"_id":"themes/material/layout/_partial/footer-left.ejs","hash":"372cdf718e01fea2736b8e427e57bfcfaa8a557f","modified":1512210625000},{"_id":"themes/material/layout/_partial/daily_pic.ejs","hash":"e780fbdb79b5e27091c408545cfd5b64892c9b01","modified":1512210625000},{"_id":"themes/material/layout/_partial/blog_info.ejs","hash":"5e95796e6f9a81163554ca4198573860f7328d4e","modified":1512210625000},{"_id":"themes/material/layout/_partial/footer_top.ejs","hash":"9eaace4feb951c96c0033e7271497f3f300d2476","modified":1512210625000},{"_id":"themes/material/layout/_partial/footer-option.ejs","hash":"be20394eaeaf2d20db28946b948962c839da6ea9","modified":1512210625000},{"_id":"themes/material/layout/_partial/config_font.ejs","hash":"730abeb681758ce288d5541930c46bc4b041a0b1","modified":1512210625000},{"_id":"themes/material/layout/_partial/footer.ejs","hash":"530626c347882579d09d71df68993e25076ca8e2","modified":1512210625000},{"_id":"themes/material/layout/_partial/isolate-sns_list.ejs","hash":"fc5f03ebb847f85975676a9dfee8870e7c908008","modified":1512210625000},{"_id":"themes/material/layout/_partial/isolate_info.ejs","hash":"b8ec76716bfa2e6513b4df6814fe8676536a94c1","modified":1512210625000},{"_id":"themes/material/layout/_partial/post-header.ejs","hash":"b0b8973c48db6376a24d4b4b1d2eb15d18d6508c","modified":1512210625000},{"_id":"themes/material/layout/_partial/post-nav.ejs","hash":"3b6d4568cc46f60c697ad9ec85a4aa5971f3eecc","modified":1512210625000},{"_id":"themes/material/layout/_partial/post-content.ejs","hash":"ad626e3b60bc4a17bacff02cf9b0a8beaba2ad1e","modified":1512210625000},{"_id":"themes/material/layout/_partial/post-info-share.ejs","hash":"9f28d62bf728c2bd89411688426a65d7ee55400c","modified":1512210625000},{"_id":"themes/material/layout/_partial/sidebar-footer_image.ejs","hash":"b9157d2072028a1db3c3419f76bde6637e85cf0e","modified":1512210625000},{"_id":"themes/material/layout/_partial/sidebar-footer.ejs","hash":"6c3486b846473e0d58666f7a8720f5bf4a14e030","modified":1512210625000},{"_id":"themes/material/layout/_partial/sidebar-header.ejs","hash":"06295e01092f55504d30a343c3fdc5091280e495","modified":1512210625000},{"_id":"themes/material/layout/_partial/import_js.ejs","hash":"961b8a0059875e4044fe80bbe91ca6a225f113e5","modified":1512210625000},{"_id":"themes/material/layout/_partial/sidebar.ejs","hash":"c5ce6136e82895cb80dab8a918a7cdf2fe820fea","modified":1512210625000},{"_id":"themes/material/layout/_partial/structured-data.ejs","hash":"e845df290185dc300cc4edcc08b50fddc5b6909b","modified":1512210625000},{"_id":"themes/material/layout/_partial/toc_button.ejs","hash":"688c3fc12e2548ff27fe60688f79dcce2881fd50","modified":1512210625000},{"_id":"themes/material/layout/_widget/leancloud-like.ejs","hash":"e4780fe3bbb049db38d694fc18dee13d799bd51d","modified":1512210625000},{"_id":"themes/material/layout/_partial/head.ejs","hash":"8167f995c7cc21a6a8ddbfbdd03f2f74a7bd904d","modified":1512210625000},{"_id":"themes/material/layout/_widget/dnsprefetch.ejs","hash":"5e4c5359d69a64042183db13f6dd771b1f7f6b31","modified":1512210625000},{"_id":"themes/material/layout/_widget/leancloud-views_num.ejs","hash":"e27baba6a2de406463735d276606b15fb40f5eba","modified":1512210625000},{"_id":"themes/material/layout/_partial/sidebar-navigation.ejs","hash":"ff44901fdfdd952174b0d22e86df7163d7fba9ba","modified":1512210625000},{"_id":"themes/material/layout/_widget/leancloud-views.ejs","hash":"211dc183b8e84f71b2c25b3ac6659d162d81662b","modified":1512210625000},{"_id":"themes/material/layout/_widget/mathjax.ejs","hash":"b68befe1fea84739c8429c344e570a8bc0357401","modified":1512210625000},{"_id":"themes/material/layout/_widget/page-links.ejs","hash":"0ebe18e4326f921d6010df8479a08c2d403ba717","modified":1512210625000},{"_id":"themes/material/layout/_widget/page-tagcloud.ejs","hash":"e71de74e4067cc4e6aef1e09ac429c92bcd178b3","modified":1512210625000},{"_id":"themes/material/layout/_widget/nprogress.ejs","hash":"901a64600854b312209287c702278183600e06b9","modified":1512210625000},{"_id":"themes/material/layout/_widget/search-local-js.ejs","hash":"f42cc040adf47fc7d74f64b0be3c3230e8a3339e","modified":1512210625000},{"_id":"themes/material/layout/_widget/qrcode.ejs","hash":"3212e5d29fe8490c5d9a844ec9c2ce9925532de8","modified":1512210625000},{"_id":"themes/material/layout/_widget/page-gallery.ejs","hash":"81b9410deef7a83ef5bc7cd18ad042df70d70b94","modified":1512210625000},{"_id":"themes/material/scripts/lib/get_file_hex.js","hash":"eb3b9a45f8ca45ef40d5421baef7d4484023982c","modified":1512210625000},{"_id":"themes/material/scripts/lib/js_hex.js","hash":"2704583aa036d538544ce31c2e924c0c125309dd","modified":1512210625000},{"_id":"themes/material/scripts/lib/js_lsload.js","hash":"72f885b13fe0028a0e2acb7168dcc66e39ea1592","modified":1512210625000},{"_id":"themes/material/scripts/lib/path_for.js","hash":"f944e3b53a468962121aa3357cc0bc18ac27a34c","modified":1512210625000},{"_id":"themes/material/scripts/lib/css_lsload.js","hash":"179f5f5e3297a7fb7d90545ddd94eb468a11046e","modified":1512210625000},{"_id":"themes/material/layout/_widget/page-timeline.ejs","hash":"9fa0195e08d9fd40aa0333e9279c98bc65acf604","modified":1512210625000},{"_id":"themes/material/layout/_widget/search-swiftype-js.ejs","hash":"7ad1e843e620ccd9b3c041dccfdcee97921247a1","modified":1512210625000},{"_id":"themes/material/source/css/disqus-proxy.css","hash":"770776d8cec27cd5661bdfd59eff9af263439989","modified":1512210625000},{"_id":"themes/material/source/css/duoshuo.min.css","hash":"89a30544b8b01d061da51c40f2af702a7969de5e","modified":1512210625000},{"_id":"themes/material/source/css/disqus-proxy.min.css","hash":"3f8f99f71d361302288b0ba11fd36072564b08c2","modified":1512210625000},{"_id":"themes/material/source/css/duoshuo.css","hash":"32a02eaa01ff7b66fd9df307b0d33d52810096be","modified":1512210625000},{"_id":"themes/material/source/css/gallery.min.css","hash":"c5333ca835aae49239d809130a7b281af745729e","modified":1512210625000},{"_id":"themes/material/source/css/fontawesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1512210625000},{"_id":"source/_posts/TOOLS/Chrome-Devtool.md","hash":"5460eb6c92c5c2cab55bcfe62da0caee31ff2c41","modified":1534211614531},{"_id":"source/_posts/WEBPACK/Webpack4及模块绑定入门手册.md","hash":"0e30b8dcf368054ed582ba4db0b5fe547c386a95","modified":1531189138240},{"_id":"themes/material/source/css/ie-blocker.css","hash":"dddce7e6250a449291888ae7865697282a213b14","modified":1512210625000},{"_id":"themes/material/source/css/material-icons.css","hash":"f6f95fe5190f3c65931847246621fb83754eb00c","modified":1512210625000},{"_id":"themes/material/source/css/prettify.css","hash":"c395f20ee64e80c2b6b15c7dade02f9aaaeab2c8","modified":1512210625000},{"_id":"themes/material/source/css/prettify.min.css","hash":"62edd8f08656463b0e077dcf893faa3cc8eb5fe4","modified":1512210625000},{"_id":"themes/material/source/css/uc.css","hash":"1e0977a2c9bdf721cc05654dfc025dd250655852","modified":1512210625000},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.woff","hash":"c6c953c2ccb2ca9abb21db8dbf473b5a435f0082","modified":1512210625000},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.woff2","hash":"09963592e8c953cc7e14e3fb0a5b05d5042e8435","modified":1512210625000},{"_id":"themes/material/source/img/avatar.png","hash":"bf483b0d495dbbcfb308348a945818e1c1cc9696","modified":1512210625000},{"_id":"themes/material/source/img/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1512210625000},{"_id":"themes/material/source/img/favicon.png","hash":"b1bcc84cedb2a618e8db93559ce7d58f9274085d","modified":1512210625000},{"_id":"themes/material/source/img/bg.png","hash":"a32f9717e19e821a4030ade551dc2917c889fcd8","modified":1512210625000},{"_id":"themes/material/source/img/logo.png","hash":"b1bcc84cedb2a618e8db93559ce7d58f9274085d","modified":1512210625000},{"_id":"themes/material/source/img/sidebar_header.png","hash":"c47f4d39f421c0a950279d050ae82f9ae6dd19ff","modified":1512210625000},{"_id":"themes/material/source/js/MathJax.js","hash":"a21703b5848325a902c9b39bbf3ca6490d3e1b1b","modified":1512210625000},{"_id":"themes/material/source/js/ie-blocker.zhCN.js","hash":"0ed49b0ec1d1924b128fbd97fca2cf7af7856fdf","modified":1512210625000},{"_id":"themes/material/source/js/Valine.min.js","hash":"6a287a99a772a0ea8f98b133523429c9250cc67f","modified":1512210625000},{"_id":"themes/material/source/js/lazyload.min.js","hash":"5348fd7aa4dbefac9d21091c9fd5e263563b5540","modified":1512210625000},{"_id":"themes/material/source/js/ie-blocker.en.js","hash":"96ca8e677a12048d099319ebdf01983ddc6ca80c","modified":1512210625000},{"_id":"themes/material/source/js/hanabi-browser-bundle.js","hash":"d646647bda386140c8315d60e3ff4ddbdb15c1ea","modified":1512210625000},{"_id":"themes/material/source/js/prettify.min.js","hash":"69908fe0a09cee107c25cb5d769b861723e7b7bb","modified":1512210625000},{"_id":"themes/material/source/js/lsloader.js","hash":"2b14e57784fb6b5f58d71584189c61af45f393e8","modified":1512210625000},{"_id":"themes/material/source/js/queue.min.js","hash":"21aab782ca33efbb1386cc960b6be0a02106760d","modified":1512210625000},{"_id":"themes/material/source/js/nprogress.js","hash":"a3058d4b6afb5d7a14e5afcbb88f778de35864f0","modified":1512210625000},{"_id":"themes/material/source/js/lsloader.min.js","hash":"1a68a8d267948ea8475245b7d365a1a1bd8f732e","modified":1512210625000},{"_id":"themes/material/source/img/upyun_logo.svg","hash":"1f118b2b9c54f431d5e731ccf316ceefe605ba67","modified":1512210625000},{"_id":"themes/material/source/js/queue.js","hash":"dd252616b568b71c222d9cfc859bfe52738e576a","modified":1512210625000},{"_id":"themes/material/source/js/smoothscroll.js","hash":"df56a1c84191a62750ae820943377b6775fca0e2","modified":1512210625000},{"_id":"themes/material/source/css/material.css","hash":"068e2b00f686157b6e8b78b9b808112adbedf4de","modified":1512210625000},{"_id":"themes/material/source/css/material.min.css","hash":"1a19febb9214ab689b02f5bb8ccb23579e6c1181","modified":1512210625000},{"_id":"themes/material/source/css/style.min.css","hash":"a9e9b33e1fcf818f08a04b909c86f2460a05f060","modified":1512210625000},{"_id":"themes/material/source/css/style.css","hash":"a2f27c40f412dc24e1ed5f62a4117523a226eed0","modified":1512210625000},{"_id":"themes/material/source/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1512210625000},{"_id":"themes/material/source/img/daily_pic.png","hash":"5e9a5f6a134889d0242e69061837f2032416d7ce","modified":1512210625000},{"_id":"themes/material/source/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1512210625000},{"_id":"themes/material/source/js/jquery.min.js","hash":"00073d6597d2760b81387274a9ec56b9d5cb1552","modified":1512210625000},{"_id":"themes/material/source/js/js.min.js","hash":"709d347d3be033b841de0493b7cf532b594bb1f6","modified":1512210625000},{"_id":"source/_posts/HEXO/How-To-Build-Personal-Blog-By-Hexo/markdown常见语法.png","hash":"cbec86a7fe14163f7eec14e74683b9a3f64d201c","modified":1522656120982},{"_id":"source/_posts/TOOLS/Chrome-Devtool/memory_png12.png","hash":"caa38e7f3d491f70c25b3b9c97285866a87b8466","modified":1534072011915},{"_id":"source/_posts/TOOLS/Chrome-Devtool/memory_png1.png","hash":"4555c019651639ee5ced4f89ee4c47fbeb4949b4","modified":1534070339751},{"_id":"source/_posts/TOOLS/Chrome-Devtool/memory_png13.png","hash":"8eb0c19588a73880c64a12b48df701d1ed449200","modified":1534072033500},{"_id":"source/_posts/TOOLS/Chrome-Devtool/memory_png10.png","hash":"2d9ee6cb616688ffae21b02698b8f94b088f1331","modified":1534071912132},{"_id":"source/_posts/TOOLS/Chrome-Devtool/memory_png5.png","hash":"42ea8490b3e3d1335314d7fe28cc95bc1cd2e625","modified":1534070713526},{"_id":"source/_posts/TOOLS/Chrome-Devtool/memory_png3.png","hash":"191cb6850e2c407df8d5d5cb1d4d2d9585dae545","modified":1534070360357},{"_id":"source/_posts/TOOLS/Chrome-Devtool/memory_png8.png","hash":"a4fe64f4d0c0ceaa0280aa2d9b3c74c1a82b1a2a","modified":1534071166478},{"_id":"source/_posts/TOOLS/Chrome-Devtool/memory_png7.png","hash":"d94d9fa366e63e75990bcd8083b50ff00870b9c2","modified":1534070910509},{"_id":"source/_posts/TOOLS/Chrome-Devtool/memory_png9.png","hash":"933923f3cb0004801a9f12470ae5ffdf57c53cb0","modified":1534071685200},{"_id":"source/_posts/TOOLS/Chrome-Devtool/png3.png","hash":"5513f35c51f2dc8b91f17ec874235dbc4dede285","modified":1534068899945},{"_id":"source/_posts/TOOLS/Chrome-Devtool/png5.png","hash":"3bf75ceb2cd084892256c3a5679c10d5aa269ece","modified":1534068924043},{"_id":"source/_posts/TOOLS/Chrome-Devtool/memory_png6.png","hash":"ea207c728ceda1a5288b492d44b01e2428a8008b","modified":1534070937283},{"_id":"source/_posts/TOOLS/Chrome-Devtool/png7.png","hash":"25b876d1f60897bc5a796414ea3921c100e27d55","modified":1534068942594},{"_id":"source/_posts/TOOLS/Chrome-Devtool/png4.png","hash":"4b3a8d1c57e4d05ad828f6fe8d3455f75e98c8fe","modified":1534068916737},{"_id":"themes/material/source/js/js.js","hash":"64b3f20e7138674ecf21e6e3982565ea63feae26","modified":1512210625000},{"_id":"themes/material/layout/_widget/analytics/cnzz-analytics.ejs","hash":"1765e3dcd92961292f40d1812e593186c77b17ef","modified":1512210625000},{"_id":"themes/material/source/css/prettify/atelier-cave-dark.min.css","hash":"cb0156cdc36500a26b232ae1c81fdc880eba85e7","modified":1512210625000},{"_id":"themes/material/source/css/prettify/atelier-cave-light.min.css","hash":"4b62dc45aa351b071d6a434dc54fe8c2e15c85cc","modified":1512210625000},{"_id":"themes/material/source/css/prettify/atelier-dune-light.min.css","hash":"b3ad98483e4d5bde72d52a15423d98e0d086db09","modified":1512210625000},{"_id":"themes/material/source/css/prettify/atelier-dune-dark.min.css","hash":"c5094d99ca0e619d97860c88211bf908fdf830b1","modified":1512210625000},{"_id":"themes/material/layout/_widget/analytics/google-analytics.ejs","hash":"3b10ebf524baf0c24b22dcd110b39d15c5acb9b5","modified":1512210625000},{"_id":"themes/material/source/css/prettify/atelier-estuary-dark.min.css","hash":"7e3a065cafeb3acc1d7178f64ef4265f5d5ad2b9","modified":1512210625000},{"_id":"themes/material/source/css/prettify/atelier-estuary-light.min.css","hash":"1d12d8f7fa9c122a186ee76fdf681c191a68f104","modified":1512210625000},{"_id":"themes/material/layout/_widget/analytics/baidu-analytics.ejs","hash":"3866a7fead3c1f94a517f1f9d629f092670b1520","modified":1512210625000},{"_id":"themes/material/source/css/prettify/atelier-forest-light.min.css","hash":"3532f6e86bf4afbba05f7a074b791b73174f9622","modified":1512210625000},{"_id":"themes/material/source/css/prettify/atelier-heath-dark.min.css","hash":"954309acd7918422382a3ff2f9c2988aec0ff956","modified":1512210625000},{"_id":"themes/material/source/css/prettify/atelier-lakeside-dark.min.css","hash":"18575fc6dff855e395a39d0383d2f18807091f0d","modified":1512210625000},{"_id":"themes/material/source/css/prettify/atelier-heath-light.min.css","hash":"a67199fa580b3aa2df031e5d2028929d29ca3b45","modified":1512210625000},{"_id":"themes/material/source/css/prettify/atelier-forest-dark.min.css","hash":"9296b851a5b66785a60afa5da5fe9080bda96bf5","modified":1512210625000},{"_id":"themes/material/source/css/prettify/atelier-plateau-light.min.css","hash":"153801640fdcbb74c0de3f15345110f2210eb991","modified":1512210625000},{"_id":"themes/material/source/css/prettify/atelier-plateau-dark.min.css","hash":"137e3c499a720da3c1d57b4dc53264b1d623e1c5","modified":1512210625000},{"_id":"themes/material/source/css/prettify/atelier-lakeside-light.min.css","hash":"e20e8ac64432fa1aa6f74792b58196af7cf79c12","modified":1512210625000},{"_id":"themes/material/source/css/prettify/atelier-savanna-dark.min.css","hash":"fba92c652fd6704422b8f2bbc11706805a6faed0","modified":1512210625000},{"_id":"themes/material/source/css/prettify/atelier-seaside-light.min.css","hash":"732750b75389c1c49204f37705e6abeee40ce64f","modified":1512210625000},{"_id":"themes/material/source/css/prettify/atelier-sulphurpool-dark.min.css","hash":"015a35dddaee153fa8bb71d7f3818a6ba4d120d8","modified":1512210625000},{"_id":"themes/material/source/css/prettify/github.min.css","hash":"19cf828225288fa5c006f1d8f66c39d11f4ef7f2","modified":1512210625000},{"_id":"themes/material/source/css/prettify/atelier-savanna-light.min.css","hash":"d9425ffb7c60d646190c22b9a5f72091ee5f9ace","modified":1512210625000},{"_id":"themes/material/source/css/prettify/atelier-sulphurpool-light.min.css","hash":"ab1a6200eab648cab443c3df77fde9b237ef27b6","modified":1512210625000},{"_id":"themes/material/source/css/prettify/github-v2.min.css","hash":"57630621d20842a529bdea7b17fc90f520e562ef","modified":1512210625000},{"_id":"themes/material/source/css/prettify/hemisu-dark.min.css","hash":"a671248cfd573292026d2174817e82e593691052","modified":1512210625000},{"_id":"themes/material/source/css/prettify/atelier-seaside-dark.min.css","hash":"e0e6bbacc75a349b1e49c236d374b0e42f1fd485","modified":1512210625000},{"_id":"themes/material/source/css/prettify/tomorrow-night-bright.min.css","hash":"cf251fd3edfd736695272a0f1b41d509b7bb1fb9","modified":1512210625000},{"_id":"themes/material/source/css/prettify/tomorrow-night-blue.min.css","hash":"c442728d96485bcf816151fe6bd96993aae09852","modified":1512210625000},{"_id":"themes/material/source/css/prettify/tomorrow-night-eighties.min.css","hash":"6ce259d674bb4edda23eea32b2379be17d0e0e6e","modified":1512210625000},{"_id":"themes/material/source/css/prettify/hemisu-light.min.css","hash":"b2556ff41e513fd13d032ec84a37ee260a905815","modified":1512210625000},{"_id":"themes/material/source/css/prettify/tomorrow-night.min.css","hash":"d989206d124035494acb4b0cdc7fbc89f3b7d108","modified":1512210625000},{"_id":"themes/material/source/css/prettify/tomorrow.min.css","hash":"b2c6d610b77f0273fefab5aa4ad26a7f58956f87","modified":1512210625000},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.ttf","hash":"fc05de31234e0090f7ddc28ce1b23af4026cb1da","modified":1512210625000},{"_id":"themes/material/source/css/prettify/tranquil-heart.min.css","hash":"0f6eefbdda8e410832e9c516a5dd19899217ef06","modified":1512210625000},{"_id":"themes/material/source/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1512210625000},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.eot","hash":"26fb8cecb5512223277b4d290a24492a0f09ede1","modified":1512210625000},{"_id":"themes/material/source/css/prettify/vibrant-ink.min.css","hash":"c265bac6c31cf622b536b29c8a6bc46955d6fe63","modified":1512210625000},{"_id":"source/_posts/TOOLS/Chrome-Devtool/png6.png","hash":"1d2efed33d038cf42742af5cdc8f7091055525a8","modified":1534068934488},{"_id":"themes/material/source/img/footer/footer_ico-facebook.svg","hash":"74b3b3c6bd1d76b7eaaf75d36ac929b11a5a3e82","modified":1512210625000},{"_id":"themes/material/source/img/footer/footer_ico-github.svg","hash":"5f1f9f53e6a87ad674108c6bd16e424a1e888c61","modified":1512210625000},{"_id":"themes/material/source/img/footer/footer_ico-bilibili.svg","hash":"1a007ae30d69aa597f589edb4ee0638a9814c988","modified":1512210625000},{"_id":"themes/material/source/img/footer/footer_ico-gplus.svg","hash":"b50274133ab263bcacdf729871d0446b615ac984","modified":1512210625000},{"_id":"themes/material/source/img/footer/footer_ico-linkedin.svg","hash":"9831c86352ec5ff283a3277d033120f86388c277","modified":1512210625000},{"_id":"themes/material/source/img/footer/footer_ico-instagram.svg","hash":"294c511e62063ea49f61e23958ab27d643ba0228","modified":1512210625000},{"_id":"themes/material/source/img/footer/footer_ico-tumblr.svg","hash":"11daf4fa4220787306fc21a879429e98b7db8d03","modified":1512210625000},{"_id":"themes/material/source/img/footer/footer_ico-twitter.svg","hash":"58df7777d6fcee8fa3c42453c091714bb3f97c95","modified":1512210625000},{"_id":"themes/material/source/img/footer/footer_ico-telegram.svg","hash":"413d66e40ca476deeb49364935d49d2f7839cdfd","modified":1512210625000},{"_id":"themes/material/source/img/footer/footer_ico-v2ex.svg","hash":"c5ffaf67a97e534c266d1585a9a3b56f1bfe3052","modified":1512210625000},{"_id":"source/_posts/TOOLS/Chrome-Devtool/png8.png","hash":"9440a3d33615bdea7121e6a092ba91cb49c02c27","modified":1534068950715},{"_id":"themes/material/source/img/gallery/arrow.svg","hash":"144d73877e52acc5068bc0c9d1e69ef450e69f26","modified":1512210625000},{"_id":"themes/material/source/img/gallery/close.svg","hash":"2690088060811f01c9360df75be80070156ff176","modified":1512210625000},{"_id":"source/_posts/TOOLS/Chrome-Devtool/png9.png","hash":"3582802b73aa253d56f7f7df195b18750595e22e","modified":1534068958215},{"_id":"themes/material/source/img/random/material-10.png","hash":"363466a376e4df9e61acc904cd25f3c7ae1a7280","modified":1512210625000},{"_id":"themes/material/source/img/random/material-12.png","hash":"d020b3d42542715c7ae95b3d8603fe3180bfe8f3","modified":1512210625000},{"_id":"themes/material/source/img/random/material-17.png","hash":"ece82810e31f711576db598c845c3d97bd49fe67","modified":1512210625000},{"_id":"themes/material/source/img/footer/footer_ico-zhihu.svg","hash":"d3f8da320fffefc5144822665dfe17d25af4061c","modified":1512210625000},{"_id":"themes/material/source/img/random/material-4.png","hash":"b475dfbf67a076a4e17a5527fd1973b1d4adac07","modified":1512210625000},{"_id":"themes/material/source/img/gallery/spinner.svg","hash":"fc9d1cd1118ac896d4f5326e110a653f3ea32b11","modified":1512210625000},{"_id":"themes/material/source/img/footer/footer_ico-weibo.svg","hash":"26d0cdb77f0c4afd60111176167eacfa222bc4c1","modified":1512210625000},{"_id":"themes/material/source/img/random/material-19.png","hash":"768ed1a4966e2e418cb00f6b36d2fc9058328eb3","modified":1512210625000},{"_id":"themes/material/source/img/random/material-3.png","hash":"848eaa70b9b0cd7a2204c78e8aa324d8f96bb097","modified":1512210625000},{"_id":"themes/material/source/img/random/material-9.png","hash":"840319c4d1f38fb8df79eb4669ed2e14d89fd680","modified":1512210625000},{"_id":"themes/material/source/img/random/material-6.png","hash":"2f841e0c064fecb607ad1e149662a0c96d9e725d","modified":1512210625000},{"_id":"source/_posts/HEXO/How-To-Build-Personal-Blog-By-Hexo/github配置.png","hash":"e45496cb5a9b51b7b09d1020913bd391616a9658","modified":1522652631702},{"_id":"themes/material/source/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1512210625000},{"_id":"source/_posts/TOOLS/Chrome-Devtool/memory_png11.png","hash":"0744d4f088a0f7fe41907cf04dce3e3264585964","modified":1534071943255},{"_id":"source/_posts/TOOLS/Chrome-Devtool/memory_png2.png","hash":"ede79a2a2d45bdc391ed94bcf76e23aae9bf9186","modified":1534070081186},{"_id":"source/_posts/TOOLS/Chrome-Devtool/memory_png4.png","hash":"413f7a265c1191816e82fad9e6ab874b276d3b65","modified":1534070425232},{"_id":"source/_posts/TOOLS/Chrome-Devtool/png1.png","hash":"a2f7af5b8ec4fc4b65ec6fd2e782cdac733ec6fd","modified":1534068497464},{"_id":"source/_posts/TOOLS/Chrome-Devtool/png2.png","hash":"64d1c59183e5d944669d9ff9469a7155f36b2a5a","modified":1534068759624},{"_id":"themes/material/source/js/gallery/gallery.js","hash":"8ee48312a183b42a9886211a0ec825ea0d041301","modified":1512210625000},{"_id":"themes/material/layout/_widget/comment/livere/common.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1512210625000},{"_id":"themes/material/layout/_widget/comment/valine/common.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1512210625000},{"_id":"themes/material/source/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1512210625000},{"_id":"themes/material/source/img/random/material-11.png","hash":"ce20b0ad08a248c036115374f2edb7301ff60b72","modified":1512210625000},{"_id":"themes/material/source/img/random/material-13.png","hash":"1a8378db3121b583485e2b939cb1aa0e0b14b0c8","modified":1512210625000},{"_id":"themes/material/source/img/random/material-1.png","hash":"4839299eaa4db7272befa7b824e54b647fbbfc44","modified":1512210625000},{"_id":"themes/material/source/img/random/material-14.png","hash":"b4f65b601960138c69f57171b0ddd55895483f45","modified":1512210625000},{"_id":"themes/material/source/img/random/material-16.png","hash":"ade7f75200d3fb38326e3cf1e9f1a812fb12a43b","modified":1512210625000},{"_id":"themes/material/source/img/random/material-2.png","hash":"faba2ce69c19d6c1dac392dd10b054e0061f6fb7","modified":1512210625000},{"_id":"themes/material/source/img/random/material-5.png","hash":"5041ebd073a139c67f8ed271e74c967c7eb9c5be","modified":1512210625000},{"_id":"themes/material/source/img/random/material-15.png","hash":"36b9937cf3810e4970902b78797ad29b0831f065","modified":1512210625000},{"_id":"themes/material/source/img/random/material-8.png","hash":"57db542d526ef6866cb34e261096e93a0e6f3a82","modified":1512210625000},{"_id":"themes/material/layout/_widget/comment/changyan/common.ejs","hash":"40e1fc76d6b7f64e226693fb2fe1a6bb17bae245","modified":1512210625000},{"_id":"themes/material/layout/_widget/comment/disqus/common.ejs","hash":"c11cfceb0906a96399dede5da01ff7fe4787f8a5","modified":1512210625000},{"_id":"themes/material/layout/_widget/comment/changyan/enter.ejs","hash":"e3cfb4f37ea35457f112f3e822e130c930086497","modified":1512210625000},{"_id":"themes/material/layout/_widget/comment/disqus_click/common.ejs","hash":"d243f576b366a62191066459efcc6fd0ab79d00a","modified":1512210625000},{"_id":"themes/material/layout/_widget/comment/disqus/enter.ejs","hash":"39192034766349e47967da63184f9104fdded2ab","modified":1512210625000},{"_id":"themes/material/layout/_widget/comment/disqus_click/enter.ejs","hash":"d82f0296f8bae25223ec44e6e05b817d3a234884","modified":1512210625000},{"_id":"themes/material/layout/_widget/comment/gitalk/common.ejs","hash":"f739897518011e1b3de7807c8c5d734984711282","modified":1512210625000},{"_id":"themes/material/layout/_widget/comment/disqus/main.ejs","hash":"21e0eeff664191b818d7a0071ae7edcdfc270442","modified":1512210625000},{"_id":"themes/material/layout/_widget/comment/gitalk/enter.ejs","hash":"4d70d76465469a57def29a221962a5520fb34ebe","modified":1512210625000},{"_id":"themes/material/layout/_widget/comment/gitment/common.ejs","hash":"9c6c8d1b448c32afb01c2d0351e87f4d4a17ec3c","modified":1512210625000},{"_id":"themes/material/layout/_widget/comment/changyan/main.ejs","hash":"77539ff32cc9d1204b848e01b5277fff5cbd61e0","modified":1512210625000},{"_id":"themes/material/layout/_widget/comment/gitment/main.ejs","hash":"e622660eda38cda05847aadc2a3e31a228fc519b","modified":1512210625000},{"_id":"themes/material/layout/_widget/comment/gitalk/main.ejs","hash":"1ee7a7b2b9b5ae8c4fa8c4b09c7973b9e085bdf2","modified":1512210625000},{"_id":"themes/material/layout/_widget/comment/livere/enter.ejs","hash":"194b7bb581a3b8608a7ab135b6953d7908f51cc8","modified":1512210625000},{"_id":"themes/material/layout/_widget/comment/disqus_click/main.ejs","hash":"f53de208ca46c669a868a1922488e39509c6fe3b","modified":1512210625000},{"_id":"themes/material/layout/_widget/comment/valine/enter.ejs","hash":"ab528aad46237d9e7f1c5b4b2b310dd628b2de63","modified":1512210625000},{"_id":"themes/material/source/img/random/material-18.png","hash":"4b98204abe36ecd3f30678d2c22059130e0db328","modified":1512210625000},{"_id":"themes/material/source/img/random/material-7.png","hash":"5c49ff3c064aaeb21227c2bd98b5ae422ddca84c","modified":1512210625000},{"_id":"themes/material/layout/_widget/comment/gitment/enter.ejs","hash":"bfc36b9e74e69d9727012b3f39fb612e5a8b7f5b","modified":1534152123305},{"_id":"themes/material/layout/_widget/comment/livere/main.ejs","hash":"1c4be9ba104a8cbcc11d45f11bf8cfe7704b93a5","modified":1512210625000},{"_id":"themes/material/layout/_widget/comment/valine/main.ejs","hash":"3d5d8559e6ad4ffb58a61d96439b2718eb9999b6","modified":1512210625000},{"_id":"themes/material/source/fonts/Roboto-Medium.ttf","hash":"3965419aab480c184f66bc5e39c1719a373a4ef6","modified":1512210625000},{"_id":"themes/material/source/fonts/Roboto-Light.ttf","hash":"b9ea2eaf26ff8fdcb5aee3e0c2c7a6084ebb6aac","modified":1512210625000},{"_id":"themes/material/source/fonts/Roboto-Bold.ttf","hash":"d1864343b543978bd491d40c80010cea50c1b7bf","modified":1512210625000},{"_id":"themes/material/source/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1512210625000},{"_id":"themes/material/source/fonts/Roboto-Black.ttf","hash":"0244e6497a51fb8a38ca7e6fe297b066e2e09af5","modified":1512210625000},{"_id":"themes/material/source/fonts/Roboto-Regular.ttf","hash":"06691e103d4d3ce1f1108d9b7d21254b714a41f8","modified":1512210625000},{"_id":"themes/material/source/fonts/Roboto-Thin.ttf","hash":"ed5101c3a800f35e925603a406e0c2dc5278b96c","modified":1512210625000},{"_id":"public/search.xml","hash":"c730d648e43bbc671df30fe74867c51be593cc7c","modified":1535709718173},{"_id":"public/about/index.html","hash":"cb46052eb5ab9af49e59cdac6c838acc03051f8e","modified":1535709718386},{"_id":"public/2018/08/31/MOBILE/移动一张图专题分析/index.html","hash":"b549449fe7c7a09b508cf656d06d86fecf0c40db","modified":1535709718386},{"_id":"public/2018/08/14/TOOLS/Chrome-Devtool/index.html","hash":"4c100ead65f62a7b774eee9c87c2895debd53301","modified":1535709718386},{"_id":"public/2018/08/13/MOBILE/用地分析/index.html","hash":"c5bf1eb8b273e8842edafdf3ba8a9ffcc9c2766a","modified":1535709718387},{"_id":"public/2018/08/10/MOBILE/在线缓存功能开发分享/index.html","hash":"d3f271e7d15549f62f5d30db636cfd68f64ae670","modified":1535709718387},{"_id":"public/2018/08/10/HEXO/hello-world/index.html","hash":"1f382c64fa6dc3f4f22ab689b78ed040e676a8b5","modified":1535709718387},{"_id":"public/2018/08/10/HEXO/Hexo配置完善/index.html","hash":"4dc2392abba4417ca7e7a87f5b09c944cda505ea","modified":1535709718387},{"_id":"public/2018/07/10/WEBPACK/Webpack4及模块绑定入门手册/index.html","hash":"579407cbdf756346467983e7a96a5e0f9c49db89","modified":1535709718387},{"_id":"public/2018/06/13/HEXO/How-To-Build-Personal-Blog-By-Hexo/index.html","hash":"cf95b5b36f20f84d8182164574a02386bf8d4fc4","modified":1535709718387},{"_id":"public/archives/index.html","hash":"de572328590ec006eacf8310d8d5345c7b95ff75","modified":1535709718387},{"_id":"public/index.html","hash":"4d20de1f826d14a0d0d466b62c1de3ed4d775e66","modified":1535709718387},{"_id":"public/categories/hexo/index.html","hash":"42baa09c19c69e529106f4c0f8c25801ca92a82e","modified":1535709718387},{"_id":"public/categories/mobile/index.html","hash":"08915441a066a000d0d64ee70df97bc28eb0ca33","modified":1535709718388},{"_id":"public/categories/tools/index.html","hash":"486240e5eec5a26b70a9e9cecfd050f66b4800cc","modified":1535709718388},{"_id":"public/categories/webpack/index.html","hash":"5b60847a8d63149fbf47c065f12d9de3ab0d5f97","modified":1535709718388},{"_id":"public/tags/Hexo/index.html","hash":"f91e5f04ffe0a321611c52cbd3bf32d0e3286baa","modified":1535709718388},{"_id":"public/tags/移动/index.html","hash":"bfc53466e005a72739d2ef89c4db78e65e72d022","modified":1535709718388},{"_id":"public/tags/chrome-devtool-性能分析-内存泄露/index.html","hash":"cd8a001dfec7360460e9421787ca25a04788505c","modified":1535709718389},{"_id":"public/tags/WebPack/index.html","hash":"71bee3fdae2f0e0f2f78417b6e2f393a07c8e165","modified":1535709718389},{"_id":"public/img/avatar.png","hash":"bf483b0d495dbbcfb308348a945818e1c1cc9696","modified":1535709718421},{"_id":"public/img/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1535709718421},{"_id":"public/img/logo.png","hash":"b1bcc84cedb2a618e8db93559ce7d58f9274085d","modified":1535709718421},{"_id":"public/img/bg.png","hash":"a32f9717e19e821a4030ade551dc2917c889fcd8","modified":1535709718422},{"_id":"public/img/sidebar_header.png","hash":"c47f4d39f421c0a950279d050ae82f9ae6dd19ff","modified":1535709718422},{"_id":"public/img/upyun_logo.svg","hash":"1f118b2b9c54f431d5e731ccf316ceefe605ba67","modified":1535709718422},{"_id":"public/img/footer/footer_ico-github.svg","hash":"5f1f9f53e6a87ad674108c6bd16e424a1e888c61","modified":1535709718422},{"_id":"public/img/footer/footer_ico-facebook.svg","hash":"74b3b3c6bd1d76b7eaaf75d36ac929b11a5a3e82","modified":1535709718422},{"_id":"public/img/footer/footer_ico-bilibili.svg","hash":"1a007ae30d69aa597f589edb4ee0638a9814c988","modified":1535709718422},{"_id":"public/img/footer/footer_ico-gplus.svg","hash":"b50274133ab263bcacdf729871d0446b615ac984","modified":1535709718422},{"_id":"public/img/footer/footer_ico-linkedin.svg","hash":"9831c86352ec5ff283a3277d033120f86388c277","modified":1535709718422},{"_id":"public/img/footer/footer_ico-instagram.svg","hash":"294c511e62063ea49f61e23958ab27d643ba0228","modified":1535709718422},{"_id":"public/img/footer/footer_ico-tumblr.svg","hash":"11daf4fa4220787306fc21a879429e98b7db8d03","modified":1535709718422},{"_id":"public/img/footer/footer_ico-twitter.svg","hash":"58df7777d6fcee8fa3c42453c091714bb3f97c95","modified":1535709718422},{"_id":"public/img/footer/footer_ico-telegram.svg","hash":"413d66e40ca476deeb49364935d49d2f7839cdfd","modified":1535709718422},{"_id":"public/img/footer/footer_ico-v2ex.svg","hash":"c5ffaf67a97e534c266d1585a9a3b56f1bfe3052","modified":1535709718422},{"_id":"public/img/gallery/arrow.svg","hash":"144d73877e52acc5068bc0c9d1e69ef450e69f26","modified":1535709718422},{"_id":"public/img/gallery/close.svg","hash":"2690088060811f01c9360df75be80070156ff176","modified":1535709718423},{"_id":"public/img/footer/footer_ico-zhihu.svg","hash":"d3f8da320fffefc5144822665dfe17d25af4061c","modified":1535709718423},{"_id":"public/img/random/material-17.png","hash":"ece82810e31f711576db598c845c3d97bd49fe67","modified":1535709718423},{"_id":"public/img/random/material-12.png","hash":"d020b3d42542715c7ae95b3d8603fe3180bfe8f3","modified":1535709718423},{"_id":"public/img/gallery/spinner.svg","hash":"fc9d1cd1118ac896d4f5326e110a653f3ea32b11","modified":1535709718423},{"_id":"public/img/footer/footer_ico-weibo.svg","hash":"26d0cdb77f0c4afd60111176167eacfa222bc4c1","modified":1535709718423},{"_id":"public/img/random/material-4.png","hash":"b475dfbf67a076a4e17a5527fd1973b1d4adac07","modified":1535709718423},{"_id":"public/img/random/material-10.png","hash":"363466a376e4df9e61acc904cd25f3c7ae1a7280","modified":1535709718423},{"_id":"public/img/random/material-3.png","hash":"848eaa70b9b0cd7a2204c78e8aa324d8f96bb097","modified":1535709718424},{"_id":"public/img/random/material-6.png","hash":"2f841e0c064fecb607ad1e149662a0c96d9e725d","modified":1535709718424},{"_id":"public/img/random/material-9.png","hash":"840319c4d1f38fb8df79eb4669ed2e14d89fd680","modified":1535709718424},{"_id":"public/2018/08/14/TOOLS/Chrome-Devtool/memory_png1.png","hash":"4555c019651639ee5ced4f89ee4c47fbeb4949b4","modified":1535709718424},{"_id":"public/2018/06/13/HEXO/How-To-Build-Personal-Blog-By-Hexo/markdown常见语法.png","hash":"cbec86a7fe14163f7eec14e74683b9a3f64d201c","modified":1535709718424},{"_id":"public/2018/08/14/TOOLS/Chrome-Devtool/memory_png11.png","hash":"0744d4f088a0f7fe41907cf04dce3e3264585964","modified":1535709718424},{"_id":"public/2018/08/14/TOOLS/Chrome-Devtool/memory_png10.png","hash":"2d9ee6cb616688ffae21b02698b8f94b088f1331","modified":1535709718424},{"_id":"public/2018/08/14/TOOLS/Chrome-Devtool/memory_png13.png","hash":"8eb0c19588a73880c64a12b48df701d1ed449200","modified":1535709718424},{"_id":"public/2018/08/14/TOOLS/Chrome-Devtool/memory_png12.png","hash":"caa38e7f3d491f70c25b3b9c97285866a87b8466","modified":1535709718424},{"_id":"public/2018/08/14/TOOLS/Chrome-Devtool/memory_png3.png","hash":"191cb6850e2c407df8d5d5cb1d4d2d9585dae545","modified":1535709718425},{"_id":"public/2018/08/14/TOOLS/Chrome-Devtool/memory_png6.png","hash":"ea207c728ceda1a5288b492d44b01e2428a8008b","modified":1535709718425},{"_id":"public/2018/08/14/TOOLS/Chrome-Devtool/memory_png7.png","hash":"d94d9fa366e63e75990bcd8083b50ff00870b9c2","modified":1535709718425},{"_id":"public/2018/08/14/TOOLS/Chrome-Devtool/memory_png5.png","hash":"42ea8490b3e3d1335314d7fe28cc95bc1cd2e625","modified":1535709718425},{"_id":"public/2018/08/14/TOOLS/Chrome-Devtool/memory_png9.png","hash":"933923f3cb0004801a9f12470ae5ffdf57c53cb0","modified":1535709718425},{"_id":"public/2018/08/14/TOOLS/Chrome-Devtool/memory_png8.png","hash":"a4fe64f4d0c0ceaa0280aa2d9b3c74c1a82b1a2a","modified":1535709718425},{"_id":"public/2018/08/14/TOOLS/Chrome-Devtool/png4.png","hash":"4b3a8d1c57e4d05ad828f6fe8d3455f75e98c8fe","modified":1535709718425},{"_id":"public/2018/08/14/TOOLS/Chrome-Devtool/png3.png","hash":"5513f35c51f2dc8b91f17ec874235dbc4dede285","modified":1535709718425},{"_id":"public/2018/08/14/TOOLS/Chrome-Devtool/png5.png","hash":"3bf75ceb2cd084892256c3a5679c10d5aa269ece","modified":1535709718425},{"_id":"public/2018/08/14/TOOLS/Chrome-Devtool/png7.png","hash":"25b876d1f60897bc5a796414ea3921c100e27d55","modified":1535709718426},{"_id":"public/2018/08/14/TOOLS/Chrome-Devtool/png6.png","hash":"1d2efed33d038cf42742af5cdc8f7091055525a8","modified":1535709718426},{"_id":"public/2018/08/14/TOOLS/Chrome-Devtool/png9.png","hash":"3582802b73aa253d56f7f7df195b18750595e22e","modified":1535709718426},{"_id":"public/2018/08/14/TOOLS/Chrome-Devtool/png8.png","hash":"9440a3d33615bdea7121e6a092ba91cb49c02c27","modified":1535709718426},{"_id":"public/fonts/MaterialIcons-Regular.woff","hash":"c6c953c2ccb2ca9abb21db8dbf473b5a435f0082","modified":1535709718435},{"_id":"public/fonts/MaterialIcons-Regular.woff2","hash":"09963592e8c953cc7e14e3fb0a5b05d5042e8435","modified":1535709718436},{"_id":"public/img/favicon.png","hash":"b1bcc84cedb2a618e8db93559ce7d58f9274085d","modified":1535709718437},{"_id":"public/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1535709718437},{"_id":"public/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1535709718437},{"_id":"public/img/daily_pic.png","hash":"5e9a5f6a134889d0242e69061837f2032416d7ce","modified":1535709718437},{"_id":"public/img/random/material-19.png","hash":"768ed1a4966e2e418cb00f6b36d2fc9058328eb3","modified":1535709718437},{"_id":"public/img/random/material-1.png","hash":"4839299eaa4db7272befa7b824e54b647fbbfc44","modified":1535709718437},{"_id":"public/img/random/material-14.png","hash":"b4f65b601960138c69f57171b0ddd55895483f45","modified":1535709718437},{"_id":"public/img/random/material-2.png","hash":"faba2ce69c19d6c1dac392dd10b054e0061f6fb7","modified":1535709718437},{"_id":"public/img/random/material-13.png","hash":"1a8378db3121b583485e2b939cb1aa0e0b14b0c8","modified":1535709718437},{"_id":"public/img/random/material-16.png","hash":"ade7f75200d3fb38326e3cf1e9f1a812fb12a43b","modified":1535709718437},{"_id":"public/img/random/material-11.png","hash":"ce20b0ad08a248c036115374f2edb7301ff60b72","modified":1535709718437},{"_id":"public/img/random/material-5.png","hash":"5041ebd073a139c67f8ed271e74c967c7eb9c5be","modified":1535709718437},{"_id":"public/img/random/material-8.png","hash":"57db542d526ef6866cb34e261096e93a0e6f3a82","modified":1535709718438},{"_id":"public/img/random/material-7.png","hash":"5c49ff3c064aaeb21227c2bd98b5ae422ddca84c","modified":1535709718438},{"_id":"public/img/random/material-18.png","hash":"4b98204abe36ecd3f30678d2c22059130e0db328","modified":1535709718438},{"_id":"public/img/random/material-15.png","hash":"36b9937cf3810e4970902b78797ad29b0831f065","modified":1535709718438},{"_id":"public/2018/06/13/HEXO/How-To-Build-Personal-Blog-By-Hexo/github配置.png","hash":"e45496cb5a9b51b7b09d1020913bd391616a9658","modified":1535709718438},{"_id":"public/2018/08/14/TOOLS/Chrome-Devtool/memory_png4.png","hash":"413f7a265c1191816e82fad9e6ab874b276d3b65","modified":1535709718439},{"_id":"public/2018/08/14/TOOLS/Chrome-Devtool/memory_png2.png","hash":"ede79a2a2d45bdc391ed94bcf76e23aae9bf9186","modified":1535709718439},{"_id":"public/2018/08/14/TOOLS/Chrome-Devtool/png1.png","hash":"a2f7af5b8ec4fc4b65ec6fd2e782cdac733ec6fd","modified":1535709718439},{"_id":"public/2018/08/14/TOOLS/Chrome-Devtool/png2.png","hash":"64d1c59183e5d944669d9ff9469a7155f36b2a5a","modified":1535709718439},{"_id":"public/css/ie-blocker.css","hash":"dddce7e6250a449291888ae7865697282a213b14","modified":1535709718448},{"_id":"public/css/prettify.css","hash":"c395f20ee64e80c2b6b15c7dade02f9aaaeab2c8","modified":1535709718448},{"_id":"public/css/prettify.min.css","hash":"62edd8f08656463b0e077dcf893faa3cc8eb5fe4","modified":1535709718448},{"_id":"public/css/uc.css","hash":"1e0977a2c9bdf721cc05654dfc025dd250655852","modified":1535709718448},{"_id":"public/js/lazyload.min.js","hash":"5348fd7aa4dbefac9d21091c9fd5e263563b5540","modified":1535709718449},{"_id":"public/js/ie-blocker.zhCN.js","hash":"0ed49b0ec1d1924b128fbd97fca2cf7af7856fdf","modified":1535709718449},{"_id":"public/js/ie-blocker.en.js","hash":"96ca8e677a12048d099319ebdf01983ddc6ca80c","modified":1535709718449},{"_id":"public/js/queue.min.js","hash":"21aab782ca33efbb1386cc960b6be0a02106760d","modified":1535709718449},{"_id":"public/js/lsloader.min.js","hash":"1a68a8d267948ea8475245b7d365a1a1bd8f732e","modified":1535709718449},{"_id":"public/js/hanabi-browser-bundle.js","hash":"d646647bda386140c8315d60e3ff4ddbdb15c1ea","modified":1535709718449},{"_id":"public/js/queue.js","hash":"dd252616b568b71c222d9cfc859bfe52738e576a","modified":1535709718450},{"_id":"public/js/smoothscroll.js","hash":"df56a1c84191a62750ae820943377b6775fca0e2","modified":1535709718450},{"_id":"public/js/nprogress.js","hash":"a3058d4b6afb5d7a14e5afcbb88f778de35864f0","modified":1535709718450},{"_id":"public/css/prettify/atelier-cave-light.min.css","hash":"4b62dc45aa351b071d6a434dc54fe8c2e15c85cc","modified":1535709718450},{"_id":"public/css/prettify/atelier-cave-dark.min.css","hash":"cb0156cdc36500a26b232ae1c81fdc880eba85e7","modified":1535709718450},{"_id":"public/css/prettify/atelier-dune-light.min.css","hash":"b3ad98483e4d5bde72d52a15423d98e0d086db09","modified":1535709718450},{"_id":"public/css/prettify/atelier-dune-dark.min.css","hash":"c5094d99ca0e619d97860c88211bf908fdf830b1","modified":1535709718450},{"_id":"public/css/prettify/atelier-estuary-dark.min.css","hash":"7e3a065cafeb3acc1d7178f64ef4265f5d5ad2b9","modified":1535709718450},{"_id":"public/css/prettify/atelier-forest-light.min.css","hash":"3532f6e86bf4afbba05f7a074b791b73174f9622","modified":1535709718451},{"_id":"public/css/prettify/atelier-estuary-light.min.css","hash":"1d12d8f7fa9c122a186ee76fdf681c191a68f104","modified":1535709718451},{"_id":"public/css/prettify/atelier-heath-dark.min.css","hash":"954309acd7918422382a3ff2f9c2988aec0ff956","modified":1535709718451},{"_id":"public/css/prettify/atelier-lakeside-dark.min.css","hash":"18575fc6dff855e395a39d0383d2f18807091f0d","modified":1535709718451},{"_id":"public/css/prettify/atelier-heath-light.min.css","hash":"a67199fa580b3aa2df031e5d2028929d29ca3b45","modified":1535709718451},{"_id":"public/css/prettify/atelier-forest-dark.min.css","hash":"9296b851a5b66785a60afa5da5fe9080bda96bf5","modified":1535709718451},{"_id":"public/css/prettify/atelier-plateau-light.min.css","hash":"153801640fdcbb74c0de3f15345110f2210eb991","modified":1535709718451},{"_id":"public/css/prettify/atelier-lakeside-light.min.css","hash":"e20e8ac64432fa1aa6f74792b58196af7cf79c12","modified":1535709718452},{"_id":"public/css/prettify/atelier-plateau-dark.min.css","hash":"137e3c499a720da3c1d57b4dc53264b1d623e1c5","modified":1535709718452},{"_id":"public/css/prettify/atelier-savanna-dark.min.css","hash":"fba92c652fd6704422b8f2bbc11706805a6faed0","modified":1535709718452},{"_id":"public/css/prettify/atelier-seaside-light.min.css","hash":"732750b75389c1c49204f37705e6abeee40ce64f","modified":1535709718452},{"_id":"public/css/prettify/atelier-sulphurpool-dark.min.css","hash":"015a35dddaee153fa8bb71d7f3818a6ba4d120d8","modified":1535709718453},{"_id":"public/css/prettify/github.min.css","hash":"19cf828225288fa5c006f1d8f66c39d11f4ef7f2","modified":1535709718453},{"_id":"public/css/prettify/atelier-savanna-light.min.css","hash":"d9425ffb7c60d646190c22b9a5f72091ee5f9ace","modified":1535709718453},{"_id":"public/css/prettify/atelier-sulphurpool-light.min.css","hash":"ab1a6200eab648cab443c3df77fde9b237ef27b6","modified":1535709718453},{"_id":"public/css/prettify/github-v2.min.css","hash":"57630621d20842a529bdea7b17fc90f520e562ef","modified":1535709718453},{"_id":"public/css/prettify/hemisu-dark.min.css","hash":"a671248cfd573292026d2174817e82e593691052","modified":1535709718453},{"_id":"public/css/prettify/atelier-seaside-dark.min.css","hash":"e0e6bbacc75a349b1e49c236d374b0e42f1fd485","modified":1535709718453},{"_id":"public/css/prettify/tomorrow-night-bright.min.css","hash":"cf251fd3edfd736695272a0f1b41d509b7bb1fb9","modified":1535709718453},{"_id":"public/css/prettify/tomorrow-night-blue.min.css","hash":"c442728d96485bcf816151fe6bd96993aae09852","modified":1535709718453},{"_id":"public/css/prettify/hemisu-light.min.css","hash":"b2556ff41e513fd13d032ec84a37ee260a905815","modified":1535709718453},{"_id":"public/css/prettify/tomorrow-night-eighties.min.css","hash":"6ce259d674bb4edda23eea32b2379be17d0e0e6e","modified":1535709718453},{"_id":"public/css/prettify/tomorrow.min.css","hash":"b2c6d610b77f0273fefab5aa4ad26a7f58956f87","modified":1535709718453},{"_id":"public/css/prettify/tomorrow-night.min.css","hash":"d989206d124035494acb4b0cdc7fbc89f3b7d108","modified":1535709718453},{"_id":"public/css/prettify/tranquil-heart.min.css","hash":"0f6eefbdda8e410832e9c516a5dd19899217ef06","modified":1535709718453},{"_id":"public/css/prettify/vibrant-ink.min.css","hash":"c265bac6c31cf622b536b29c8a6bc46955d6fe63","modified":1535709718453},{"_id":"public/fonts/MaterialIcons-Regular.ttf","hash":"fc05de31234e0090f7ddc28ce1b23af4026cb1da","modified":1535709718453},{"_id":"public/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1535709718454},{"_id":"public/css/duoshuo.min.css","hash":"89a30544b8b01d061da51c40f2af702a7969de5e","modified":1535709718468},{"_id":"public/css/disqus-proxy.min.css","hash":"3f8f99f71d361302288b0ba11fd36072564b08c2","modified":1535709718468},{"_id":"public/css/duoshuo.css","hash":"32a02eaa01ff7b66fd9df307b0d33d52810096be","modified":1535709718468},{"_id":"public/js/prettify.min.js","hash":"69908fe0a09cee107c25cb5d769b861723e7b7bb","modified":1535709718468},{"_id":"public/js/lsloader.js","hash":"2b14e57784fb6b5f58d71584189c61af45f393e8","modified":1535709718468},{"_id":"public/fonts/MaterialIcons-Regular.eot","hash":"26fb8cecb5512223277b4d290a24492a0f09ede1","modified":1535709718468},{"_id":"public/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1535709718468},{"_id":"public/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1535709718469},{"_id":"public/css/disqus-proxy.css","hash":"d5086cda8aaae20b8d3f9dd50f0be5ccb717e42a","modified":1535709718475},{"_id":"public/js/Valine.min.js","hash":"6a287a99a772a0ea8f98b133523429c9250cc67f","modified":1535709718475},{"_id":"public/css/fontawesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1535709718480},{"_id":"public/css/gallery.min.css","hash":"c5333ca835aae49239d809130a7b281af745729e","modified":1535709718480},{"_id":"public/js/gallery/gallery.js","hash":"8ee48312a183b42a9886211a0ec825ea0d041301","modified":1535709718480},{"_id":"public/css/material-icons.css","hash":"f6f95fe5190f3c65931847246621fb83754eb00c","modified":1535709718517},{"_id":"public/js/MathJax.js","hash":"a21703b5848325a902c9b39bbf3ca6490d3e1b1b","modified":1535709718527},{"_id":"public/css/style.min.css","hash":"a9e9b33e1fcf818f08a04b909c86f2460a05f060","modified":1535709718543},{"_id":"public/fonts/Roboto-Regular.ttf","hash":"06691e103d4d3ce1f1108d9b7d21254b714a41f8","modified":1535709718543},{"_id":"public/fonts/Roboto-Black.ttf","hash":"0244e6497a51fb8a38ca7e6fe297b066e2e09af5","modified":1535709718544},{"_id":"public/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1535709718545},{"_id":"public/fonts/Roboto-Medium.ttf","hash":"3965419aab480c184f66bc5e39c1719a373a4ef6","modified":1535709718547},{"_id":"public/fonts/Roboto-Thin.ttf","hash":"ed5101c3a800f35e925603a406e0c2dc5278b96c","modified":1535709718547},{"_id":"public/css/material.min.css","hash":"1a19febb9214ab689b02f5bb8ccb23579e6c1181","modified":1535709718555},{"_id":"public/fonts/Roboto-Bold.ttf","hash":"d1864343b543978bd491d40c80010cea50c1b7bf","modified":1535709718555},{"_id":"public/css/style.css","hash":"a2f27c40f412dc24e1ed5f62a4117523a226eed0","modified":1535709718558},{"_id":"public/js/jquery.min.js","hash":"00073d6597d2760b81387274a9ec56b9d5cb1552","modified":1535709718558},{"_id":"public/css/material.css","hash":"068e2b00f686157b6e8b78b9b808112adbedf4de","modified":1535709718562},{"_id":"public/js/js.min.js","hash":"709d347d3be033b841de0493b7cf532b594bb1f6","modified":1535709718562},{"_id":"public/fonts/Roboto-Light.ttf","hash":"b9ea2eaf26ff8fdcb5aee3e0c2c7a6084ebb6aac","modified":1535709718565},{"_id":"public/js/js.js","hash":"64b3f20e7138674ecf21e6e3982565ea63feae26","modified":1535709718569}],"Category":[{"name":"hexo","_id":"cjlhtwxdp0003xcl5mzir89dx"},{"name":"mobile","_id":"cjlhtwxeg000ixcl5ql7sxcr3"},{"name":"tools","_id":"cjlhtwxeo000txcl5jwa7cdic"},{"name":"webpack","_id":"cjlhtwxf00011xcl5hx6upycw"}],"Data":[],"Page":[{"title":"about","date":"2018-06-13T05:04:32.000Z","_content":"\n# 关于团队\n\n### github: DIST-XDATA\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2018-06-13 13:04:32\n---\n\n# 关于团队\n\n### github: DIST-XDATA\n","updated":"2018-06-13T05:03:53.243Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjlhtwxay0000xcl5463rkolk","content":"<h1 id=\"关于团队\"><a href=\"#关于团队\" class=\"headerlink\" title=\"关于团队\"></a>关于团队</h1><h3 id=\"github-DIST-XDATA\"><a href=\"#github-DIST-XDATA\" class=\"headerlink\" title=\"github: DIST-XDATA\"></a>github: DIST-XDATA</h3>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"关于团队\"><a href=\"#关于团队\" class=\"headerlink\" title=\"关于团队\"></a>关于团队</h1><h3 id=\"github-DIST-XDATA\"><a href=\"#github-DIST-XDATA\" class=\"headerlink\" title=\"github: DIST-XDATA\"></a>github: DIST-XDATA</h3>"}],"Post":[{"title":"Hello World With Hexo","_content":"\n## 快速开始\n\n### 创建一篇新的博客\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\n详情: [Writing](https://hexo.io/docs/writing.html)\n\n<!-- more -->\n\n### 启动服务器\n\n``` bash\n$ hexo server\n```\n\n详情: [Server](https://hexo.io/docs/server.html)\n\n### 生成博客静态文件\n\n``` bash\n$ hexo generate\n```\n\n详情: [Generating](https://hexo.io/docs/generating.html)\n\n### 发布到服务器\n\n``` bash\n$ hexo deploy\n```\n\n详情: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/HEXO/hello-world.md","raw":"---\ntitle: Hello World With Hexo\ntags: Hexo\ncategories: hexo\n---\n\n## 快速开始\n\n### 创建一篇新的博客\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\n详情: [Writing](https://hexo.io/docs/writing.html)\n\n<!-- more -->\n\n### 启动服务器\n\n``` bash\n$ hexo server\n```\n\n详情: [Server](https://hexo.io/docs/server.html)\n\n### 生成博客静态文件\n\n``` bash\n$ hexo generate\n```\n\n详情: [Generating](https://hexo.io/docs/generating.html)\n\n### 发布到服务器\n\n``` bash\n$ hexo deploy\n```\n\n详情: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"HEXO/hello-world","published":1,"date":"2018-08-09T16:22:05.104Z","updated":"2018-06-13T06:20:20.740Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlhtwxdi0001xcl5uhq17xgp","content":"<h2 id=\"快速开始\"><a href=\"#快速开始\" class=\"headerlink\" title=\"快速开始\"></a>快速开始</h2><h3 id=\"创建一篇新的博客\"><a href=\"#创建一篇新的博客\" class=\"headerlink\" title=\"创建一篇新的博客\"></a>创建一篇新的博客</h3><pre><code class=\"bash\">$ hexo new &quot;My New Post&quot;\n</code></pre>\n<p>详情: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<a id=\"more\"></a>\n<h3 id=\"启动服务器\"><a href=\"#启动服务器\" class=\"headerlink\" title=\"启动服务器\"></a>启动服务器</h3><pre><code class=\"bash\">$ hexo server\n</code></pre>\n<p>详情: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"生成博客静态文件\"><a href=\"#生成博客静态文件\" class=\"headerlink\" title=\"生成博客静态文件\"></a>生成博客静态文件</h3><pre><code class=\"bash\">$ hexo generate\n</code></pre>\n<p>详情: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"发布到服务器\"><a href=\"#发布到服务器\" class=\"headerlink\" title=\"发布到服务器\"></a>发布到服务器</h3><pre><code class=\"bash\">$ hexo deploy\n</code></pre>\n<p>详情: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"快速开始\"><a href=\"#快速开始\" class=\"headerlink\" title=\"快速开始\"></a>快速开始</h2><h3 id=\"创建一篇新的博客\"><a href=\"#创建一篇新的博客\" class=\"headerlink\" title=\"创建一篇新的博客\"></a>创建一篇新的博客</h3><pre><code class=\"bash\">$ hexo new &quot;My New Post&quot;\n</code></pre>\n<p>详情: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>","more":"<h3 id=\"启动服务器\"><a href=\"#启动服务器\" class=\"headerlink\" title=\"启动服务器\"></a>启动服务器</h3><pre><code class=\"bash\">$ hexo server\n</code></pre>\n<p>详情: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"生成博客静态文件\"><a href=\"#生成博客静态文件\" class=\"headerlink\" title=\"生成博客静态文件\"></a>生成博客静态文件</h3><pre><code class=\"bash\">$ hexo generate\n</code></pre>\n<p>详情: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"发布到服务器\"><a href=\"#发布到服务器\" class=\"headerlink\" title=\"发布到服务器\"></a>发布到服务器</h3><pre><code class=\"bash\">$ hexo deploy\n</code></pre>\n<p>详情: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>"},{"title":"How To Build Personal Blog By Hexo","date":"2018-06-13T06:36:05.000Z","_content":"\n# Hexo,Github搭建个人Blog踩坑\n\n## 准备工作\n* 下载安装node.js(推荐使用淘宝npm镜像)\n* 下载安装git\n* 下载安装github desktop(用于blog与github关联时验证账户)\n* 利用npm安装hexo( npm install -g hexo)\n\n<!-- more -->\n\n## 部署Hexo\n* 创建工作空间,cd到工作空间\n* 初始化hexo <code>hexo init</code>\n* 安装依赖(npm install)\n\n## 本地启动\n* 发布静态网页(hexo g),在public目录下\n* 启动本地服务器(hexo server),默认端口4000\n\n## 将博客与Github关联\n* 在Github上创建名字为XXX.github.io的项目,XXX为自己的github用户名。\n* 打开工作空间下的_config.yml配置文件，添加配置\n![添加github配置](./github配置.png)\n* 运行<code>npm install hexo-deployer-git -save</code>\n* <code>hexo g</code>生成静态文件\n* <code>hexo d</code>将本地静态文件推送至github,中途可能会进行用户验证\n* 浏览器访问[https://hertz9409.github.io/](https://hertz9409.github.io/)\n\n## 创建博客文章并发布\n* hexo new \"my new md\"\n* 编写markdown内容\n* hexo clean,删除本地静态文件\n* hexo g,重新生成本地静态文件\n* hexo deploy,将本地静态文件推送至github\n\n## 在文章中使用图片\n方法一\n* 在文章中写入<code>![](/upload_image/1.jpg)</code>\n* 在themes主题文件夹下source目录下，新建目录upload_image，把图片放到该目录下\n* 执行hexo g命令时会自动上传图片\n方法二\n* 安装npm插件hexo-asset-image\n\n## 使用主题\n* 进入[主题商店](https://hexo.io/themes/),查看主题\n* cd 工作空间中的themes文件夹\n* 执行命令<code>git clone https://github.com/Ben02/hexo-theme-Anatole.git themes/anatole</code>\n* 主题更新<code>cd anatole<code>\n* <code>git pull</code>\n\n\n## 常见MarkDown语法\n![常见MarkDown语法](./markdown常见语法.png)\n","source":"_posts/HEXO/How-To-Build-Personal-Blog-By-Hexo.md","raw":"---\ntitle: How To Build Personal Blog By Hexo\ndate: 2018-06-13 14:36:05\ntags: Hexo\ncategories: hexo\n---\n\n# Hexo,Github搭建个人Blog踩坑\n\n## 准备工作\n* 下载安装node.js(推荐使用淘宝npm镜像)\n* 下载安装git\n* 下载安装github desktop(用于blog与github关联时验证账户)\n* 利用npm安装hexo( npm install -g hexo)\n\n<!-- more -->\n\n## 部署Hexo\n* 创建工作空间,cd到工作空间\n* 初始化hexo <code>hexo init</code>\n* 安装依赖(npm install)\n\n## 本地启动\n* 发布静态网页(hexo g),在public目录下\n* 启动本地服务器(hexo server),默认端口4000\n\n## 将博客与Github关联\n* 在Github上创建名字为XXX.github.io的项目,XXX为自己的github用户名。\n* 打开工作空间下的_config.yml配置文件，添加配置\n![添加github配置](./github配置.png)\n* 运行<code>npm install hexo-deployer-git -save</code>\n* <code>hexo g</code>生成静态文件\n* <code>hexo d</code>将本地静态文件推送至github,中途可能会进行用户验证\n* 浏览器访问[https://hertz9409.github.io/](https://hertz9409.github.io/)\n\n## 创建博客文章并发布\n* hexo new \"my new md\"\n* 编写markdown内容\n* hexo clean,删除本地静态文件\n* hexo g,重新生成本地静态文件\n* hexo deploy,将本地静态文件推送至github\n\n## 在文章中使用图片\n方法一\n* 在文章中写入<code>![](/upload_image/1.jpg)</code>\n* 在themes主题文件夹下source目录下，新建目录upload_image，把图片放到该目录下\n* 执行hexo g命令时会自动上传图片\n方法二\n* 安装npm插件hexo-asset-image\n\n## 使用主题\n* 进入[主题商店](https://hexo.io/themes/),查看主题\n* cd 工作空间中的themes文件夹\n* 执行命令<code>git clone https://github.com/Ben02/hexo-theme-Anatole.git themes/anatole</code>\n* 主题更新<code>cd anatole<code>\n* <code>git pull</code>\n\n\n## 常见MarkDown语法\n![常见MarkDown语法](./markdown常见语法.png)\n","slug":"HEXO/How-To-Build-Personal-Blog-By-Hexo","published":1,"updated":"2018-06-13T06:20:14.550Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlhtwxdn0002xcl5f72ps02o","content":"<h1 id=\"Hexo-Github搭建个人Blog踩坑\"><a href=\"#Hexo-Github搭建个人Blog踩坑\" class=\"headerlink\" title=\"Hexo,Github搭建个人Blog踩坑\"></a>Hexo,Github搭建个人Blog踩坑</h1><h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><ul>\n<li>下载安装node.js(推荐使用淘宝npm镜像)</li>\n<li>下载安装git</li>\n<li>下载安装github desktop(用于blog与github关联时验证账户)</li>\n<li>利用npm安装hexo( npm install -g hexo)</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"部署Hexo\"><a href=\"#部署Hexo\" class=\"headerlink\" title=\"部署Hexo\"></a>部署Hexo</h2><ul>\n<li>创建工作空间,cd到工作空间</li>\n<li>初始化hexo <code>hexo init</code></li>\n<li>安装依赖(npm install)</li>\n</ul>\n<h2 id=\"本地启动\"><a href=\"#本地启动\" class=\"headerlink\" title=\"本地启动\"></a>本地启动</h2><ul>\n<li>发布静态网页(hexo g),在public目录下</li>\n<li>启动本地服务器(hexo server),默认端口4000</li>\n</ul>\n<h2 id=\"将博客与Github关联\"><a href=\"#将博客与Github关联\" class=\"headerlink\" title=\"将博客与Github关联\"></a>将博客与Github关联</h2><ul>\n<li>在Github上创建名字为XXX.github.io的项目,XXX为自己的github用户名。</li>\n<li>打开工作空间下的_config.yml配置文件，添加配置<br><img src=\"./github配置.png\" alt=\"添加github配置\"></li>\n<li>运行<code>npm install hexo-deployer-git -save</code></li>\n<li><code>hexo g</code>生成静态文件</li>\n<li><code>hexo d</code>将本地静态文件推送至github,中途可能会进行用户验证</li>\n<li>浏览器访问<a href=\"https://hertz9409.github.io/\" target=\"_blank\" rel=\"noopener\">https://hertz9409.github.io/</a></li>\n</ul>\n<h2 id=\"创建博客文章并发布\"><a href=\"#创建博客文章并发布\" class=\"headerlink\" title=\"创建博客文章并发布\"></a>创建博客文章并发布</h2><ul>\n<li>hexo new “my new md”</li>\n<li>编写markdown内容</li>\n<li>hexo clean,删除本地静态文件</li>\n<li>hexo g,重新生成本地静态文件</li>\n<li>hexo deploy,将本地静态文件推送至github</li>\n</ul>\n<h2 id=\"在文章中使用图片\"><a href=\"#在文章中使用图片\" class=\"headerlink\" title=\"在文章中使用图片\"></a>在文章中使用图片</h2><p>方法一</p>\n<ul>\n<li>在文章中写入<code><img src=\"/upload_image/1.jpg\" alt=\"\"></code></li>\n<li>在themes主题文件夹下source目录下，新建目录upload_image，把图片放到该目录下</li>\n<li>执行hexo g命令时会自动上传图片<br>方法二</li>\n<li>安装npm插件hexo-asset-image</li>\n</ul>\n<h2 id=\"使用主题\"><a href=\"#使用主题\" class=\"headerlink\" title=\"使用主题\"></a>使用主题</h2><ul>\n<li>进入<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">主题商店</a>,查看主题</li>\n<li>cd 工作空间中的themes文件夹</li>\n<li>执行命令<code>git clone <a href=\"https://github.com/Ben02/hexo-theme-Anatole.git\" target=\"_blank\" rel=\"noopener\">https://github.com/Ben02/hexo-theme-Anatole.git</a> themes/anatole</code></li>\n<li>主题更新<code>cd anatole<code></code></code></li>\n<li><code>git pull</code></li>\n</ul>\n<h2 id=\"常见MarkDown语法\"><a href=\"#常见MarkDown语法\" class=\"headerlink\" title=\"常见MarkDown语法\"></a>常见MarkDown语法</h2><p><img src=\"./markdown常见语法.png\" alt=\"常见MarkDown语法\"></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Hexo-Github搭建个人Blog踩坑\"><a href=\"#Hexo-Github搭建个人Blog踩坑\" class=\"headerlink\" title=\"Hexo,Github搭建个人Blog踩坑\"></a>Hexo,Github搭建个人Blog踩坑</h1><h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><ul>\n<li>下载安装node.js(推荐使用淘宝npm镜像)</li>\n<li>下载安装git</li>\n<li>下载安装github desktop(用于blog与github关联时验证账户)</li>\n<li>利用npm安装hexo( npm install -g hexo)</li>\n</ul>","more":"<h2 id=\"部署Hexo\"><a href=\"#部署Hexo\" class=\"headerlink\" title=\"部署Hexo\"></a>部署Hexo</h2><ul>\n<li>创建工作空间,cd到工作空间</li>\n<li>初始化hexo <code>hexo init</code></li>\n<li>安装依赖(npm install)</li>\n</ul>\n<h2 id=\"本地启动\"><a href=\"#本地启动\" class=\"headerlink\" title=\"本地启动\"></a>本地启动</h2><ul>\n<li>发布静态网页(hexo g),在public目录下</li>\n<li>启动本地服务器(hexo server),默认端口4000</li>\n</ul>\n<h2 id=\"将博客与Github关联\"><a href=\"#将博客与Github关联\" class=\"headerlink\" title=\"将博客与Github关联\"></a>将博客与Github关联</h2><ul>\n<li>在Github上创建名字为XXX.github.io的项目,XXX为自己的github用户名。</li>\n<li>打开工作空间下的_config.yml配置文件，添加配置<br><img src=\"./github配置.png\" alt=\"添加github配置\"></li>\n<li>运行<code>npm install hexo-deployer-git -save</code></li>\n<li><code>hexo g</code>生成静态文件</li>\n<li><code>hexo d</code>将本地静态文件推送至github,中途可能会进行用户验证</li>\n<li>浏览器访问<a href=\"https://hertz9409.github.io/\" target=\"_blank\" rel=\"noopener\">https://hertz9409.github.io/</a></li>\n</ul>\n<h2 id=\"创建博客文章并发布\"><a href=\"#创建博客文章并发布\" class=\"headerlink\" title=\"创建博客文章并发布\"></a>创建博客文章并发布</h2><ul>\n<li>hexo new “my new md”</li>\n<li>编写markdown内容</li>\n<li>hexo clean,删除本地静态文件</li>\n<li>hexo g,重新生成本地静态文件</li>\n<li>hexo deploy,将本地静态文件推送至github</li>\n</ul>\n<h2 id=\"在文章中使用图片\"><a href=\"#在文章中使用图片\" class=\"headerlink\" title=\"在文章中使用图片\"></a>在文章中使用图片</h2><p>方法一</p>\n<ul>\n<li>在文章中写入<code><img src=\"/upload_image/1.jpg\" alt=\"\"></code></li>\n<li>在themes主题文件夹下source目录下，新建目录upload_image，把图片放到该目录下</li>\n<li>执行hexo g命令时会自动上传图片<br>方法二</li>\n<li>安装npm插件hexo-asset-image</li>\n</ul>\n<h2 id=\"使用主题\"><a href=\"#使用主题\" class=\"headerlink\" title=\"使用主题\"></a>使用主题</h2><ul>\n<li>进入<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">主题商店</a>,查看主题</li>\n<li>cd 工作空间中的themes文件夹</li>\n<li>执行命令<code>git clone <a href=\"https://github.com/Ben02/hexo-theme-Anatole.git\" target=\"_blank\" rel=\"noopener\">https://github.com/Ben02/hexo-theme-Anatole.git</a> themes/anatole</code></li>\n<li>主题更新<code>cd anatole<code></code></code></li>\n<li><code>git pull</code></li>\n</ul>\n<h2 id=\"常见MarkDown语法\"><a href=\"#常见MarkDown语法\" class=\"headerlink\" title=\"常见MarkDown语法\"></a>常见MarkDown语法</h2><p><img src=\"./markdown常见语法.png\" alt=\"常见MarkDown语法\"></p>"},{"title":"Hexo 配置完善","_content":"\nhexo搭建后,我们需要加入许多个性化功能,在此进行记录.\n\n<!-- more -->\n\n## 添加返回顶部按钮\n\n1. 打开\\themes\\landscape\\layout\\_partial,新建文件名称为totop.ejs.\n\n        <div id=\"totop\">\n            <a title=\"javascript:;\">返回<br>顶部</a>\n        </div>\n\n2. 打开\\themes\\landscape\\source\\js,新建文件totop.js.\n\n        (function($) {\n            var upperLimit = 1000;\n\n            // Our scroll link element\n            var scrollElem = $('#totop');\n\n            // Scroll to top speed\n            var scrollSpeed = 1600;\n            scrollElem.hide();\n            $(window).scroll(function () {\n                var scrollTop = $(document).scrollTop();\n                if ( scrollTop > upperLimit ) {\n                    $(scrollElem).stop().fadeTo(300, 1); \n                }else{\n                    $(scrollElem).stop().fadeTo(300, 0); \n                }\n            });\n            $(scrollElem).click(function(){\n                $('html, body').animate({scrollTop:0}, scrollSpeed); return false;\n            });\n        })(jQuery);\n\n3. 打开\\themes\\landscape\\layout\\_partial\\after_footer.ejs,添加代码\n\n        <%- partial('totop') %>\n        <script src=\"<%- config.root %>js/totop.js\"></script>\n\n4. 设置样式,打开\\themes\\landscape\\source\\css\\_partial,创建文件totop.styl,添加样式代码\n\n        #totop\n            position:fixed\n            bottom:50px\n            right:30px\n            text-align: center\n            z-index: 100\n            a\n                display: block\n                padding 4px 8px\n                color: #fff\n                background-color: #258fb8\n                cursor: pointer\n                border-radius: 5px\n                &:hover\n                    opacity: .8\n\n    打开\\themes\\landscape\\source\\css\\style.styl,添加代码\n\n            @import \"_partial/totop\"","source":"_posts/HEXO/Hexo配置完善.md","raw":"---\ntitle: Hexo 配置完善\ntags: Hexo\ncategories: hexo\n---\n\nhexo搭建后,我们需要加入许多个性化功能,在此进行记录.\n\n<!-- more -->\n\n## 添加返回顶部按钮\n\n1. 打开\\themes\\landscape\\layout\\_partial,新建文件名称为totop.ejs.\n\n        <div id=\"totop\">\n            <a title=\"javascript:;\">返回<br>顶部</a>\n        </div>\n\n2. 打开\\themes\\landscape\\source\\js,新建文件totop.js.\n\n        (function($) {\n            var upperLimit = 1000;\n\n            // Our scroll link element\n            var scrollElem = $('#totop');\n\n            // Scroll to top speed\n            var scrollSpeed = 1600;\n            scrollElem.hide();\n            $(window).scroll(function () {\n                var scrollTop = $(document).scrollTop();\n                if ( scrollTop > upperLimit ) {\n                    $(scrollElem).stop().fadeTo(300, 1); \n                }else{\n                    $(scrollElem).stop().fadeTo(300, 0); \n                }\n            });\n            $(scrollElem).click(function(){\n                $('html, body').animate({scrollTop:0}, scrollSpeed); return false;\n            });\n        })(jQuery);\n\n3. 打开\\themes\\landscape\\layout\\_partial\\after_footer.ejs,添加代码\n\n        <%- partial('totop') %>\n        <script src=\"<%- config.root %>js/totop.js\"></script>\n\n4. 设置样式,打开\\themes\\landscape\\source\\css\\_partial,创建文件totop.styl,添加样式代码\n\n        #totop\n            position:fixed\n            bottom:50px\n            right:30px\n            text-align: center\n            z-index: 100\n            a\n                display: block\n                padding 4px 8px\n                color: #fff\n                background-color: #258fb8\n                cursor: pointer\n                border-radius: 5px\n                &:hover\n                    opacity: .8\n\n    打开\\themes\\landscape\\source\\css\\style.styl,添加代码\n\n            @import \"_partial/totop\"","slug":"HEXO/Hexo配置完善","published":1,"date":"2018-08-09T16:22:05.100Z","updated":"2018-06-13T06:20:05.341Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlhtwxdr0005xcl5739w3abr","content":"<p>hexo搭建后,我们需要加入许多个性化功能,在此进行记录.</p>\n<a id=\"more\"></a>\n<h2 id=\"添加返回顶部按钮\"><a href=\"#添加返回顶部按钮\" class=\"headerlink\" title=\"添加返回顶部按钮\"></a>添加返回顶部按钮</h2><ol>\n<li><p>打开\\themes\\landscape\\layout_partial,新建文件名称为totop.ejs.</p>\n<pre><code> &lt;div id=&quot;totop&quot;&gt;\n     &lt;a title=&quot;javascript:;&quot;&gt;返回&lt;br&gt;顶部&lt;/a&gt;\n &lt;/div&gt;\n</code></pre></li>\n<li><p>打开\\themes\\landscape\\source\\js,新建文件totop.js.</p>\n<pre><code> (function($) {\n     var upperLimit = 1000;\n\n     // Our scroll link element\n     var scrollElem = $(&#39;#totop&#39;);\n\n     // Scroll to top speed\n     var scrollSpeed = 1600;\n     scrollElem.hide();\n     $(window).scroll(function () {\n         var scrollTop = $(document).scrollTop();\n         if ( scrollTop &gt; upperLimit ) {\n             $(scrollElem).stop().fadeTo(300, 1); \n         }else{\n             $(scrollElem).stop().fadeTo(300, 0); \n         }\n     });\n     $(scrollElem).click(function(){\n         $(&#39;html, body&#39;).animate({scrollTop:0}, scrollSpeed); return false;\n     });\n })(jQuery);\n</code></pre></li>\n<li><p>打开\\themes\\landscape\\layout_partial\\after_footer.ejs,添加代码</p>\n<pre><code> &lt;%- partial(&#39;totop&#39;) %&gt;\n &lt;script src=&quot;&lt;%- config.root %&gt;js/totop.js&quot;&gt;&lt;/script&gt;\n</code></pre></li>\n<li><p>设置样式,打开\\themes\\landscape\\source\\css_partial,创建文件totop.styl,添加样式代码</p>\n<pre><code> #totop\n     position:fixed\n     bottom:50px\n     right:30px\n     text-align: center\n     z-index: 100\n     a\n         display: block\n         padding 4px 8px\n         color: #fff\n         background-color: #258fb8\n         cursor: pointer\n         border-radius: 5px\n         &amp;:hover\n             opacity: .8\n</code></pre><p> 打开\\themes\\landscape\\source\\css\\style.styl,添加代码</p>\n<pre><code>     @import &quot;_partial/totop&quot;\n</code></pre></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>hexo搭建后,我们需要加入许多个性化功能,在此进行记录.</p>","more":"<h2 id=\"添加返回顶部按钮\"><a href=\"#添加返回顶部按钮\" class=\"headerlink\" title=\"添加返回顶部按钮\"></a>添加返回顶部按钮</h2><ol>\n<li><p>打开\\themes\\landscape\\layout_partial,新建文件名称为totop.ejs.</p>\n<pre><code> &lt;div id=&quot;totop&quot;&gt;\n     &lt;a title=&quot;javascript:;&quot;&gt;返回&lt;br&gt;顶部&lt;/a&gt;\n &lt;/div&gt;\n</code></pre></li>\n<li><p>打开\\themes\\landscape\\source\\js,新建文件totop.js.</p>\n<pre><code> (function($) {\n     var upperLimit = 1000;\n\n     // Our scroll link element\n     var scrollElem = $(&#39;#totop&#39;);\n\n     // Scroll to top speed\n     var scrollSpeed = 1600;\n     scrollElem.hide();\n     $(window).scroll(function () {\n         var scrollTop = $(document).scrollTop();\n         if ( scrollTop &gt; upperLimit ) {\n             $(scrollElem).stop().fadeTo(300, 1); \n         }else{\n             $(scrollElem).stop().fadeTo(300, 0); \n         }\n     });\n     $(scrollElem).click(function(){\n         $(&#39;html, body&#39;).animate({scrollTop:0}, scrollSpeed); return false;\n     });\n })(jQuery);\n</code></pre></li>\n<li><p>打开\\themes\\landscape\\layout_partial\\after_footer.ejs,添加代码</p>\n<pre><code> &lt;%- partial(&#39;totop&#39;) %&gt;\n &lt;script src=&quot;&lt;%- config.root %&gt;js/totop.js&quot;&gt;&lt;/script&gt;\n</code></pre></li>\n<li><p>设置样式,打开\\themes\\landscape\\source\\css_partial,创建文件totop.styl,添加样式代码</p>\n<pre><code> #totop\n     position:fixed\n     bottom:50px\n     right:30px\n     text-align: center\n     z-index: 100\n     a\n         display: block\n         padding 4px 8px\n         color: #fff\n         background-color: #258fb8\n         cursor: pointer\n         border-radius: 5px\n         &amp;:hover\n             opacity: .8\n</code></pre><p> 打开\\themes\\landscape\\source\\css\\style.styl,添加代码</p>\n<pre><code>     @import &quot;_partial/totop&quot;\n</code></pre></li>\n</ol>"},{"title":"移动用地分析","_content":"\n<header> \n<td bgcolor=#0099ff>   \n\n   <center><table><tr><td bgcolor=#333333><font size =7 face=\"黑体\" color=#ffffff>**移动用地分析功能**</td></tr></table></center>\n   \n\n</td>\n</header>\n\n<!-- more -->\n\n* <font size=\"6\" face=\"黑体\" color=#005432 >**简介**</font>\n\n\n\n<font size=\"4\">用地分析是指在对地区各自然要素进行综合分析研究的基础上，按照城市规划和建设要求、用地整备工程技术的可能性和经济性，对城市规划用地进行适用性分析评定，以划出城市用地的不同等级。</font>\n<br>\n<font size=\"4\">另外用于查清村和农、林、牧、渔场，居民点及其以外的独立工矿企事业单位土地权属界线和村以上各级行政界线，查清各类用地面积、分布和利用状况。</font>\n<br>\n<font color=#664499 size=\"4\">在本文中，用地分析主要实现为对所选中区域进行土地类别、面积和分布的识别与判断，计算其中各个层级占其父级的百分比以及面积情况。</font>\n<br>\n\n<hr>\n<br>\n\n* <font size=\"6\" face=\"黑体\" color=#005432 >**实现逻辑略析**</font>\n\n\n1. 可视化与相关功能操作窗口的基本实现<br>\n\n\n2. 加载功能基础的地图底图与分析操作图层<br>\n\n\n3. 分析区域的选择并获取当前图形<br>\n\n\n4. <font color=#664499>离线调用FeatureQuery（在线调用QueryTask）进行要素查询与过滤</font><br>\n\n\n5. <font color=#664499>获得结果FeatureResult，从中获取Geometry<font color=#ee0000>（并非与绘制图形做过交叉处理的Geometry）</font>与Attribute</font><br>\n\n\n6. <font color =#664499>图形切割与面积计算</font><br>\n\n\n7. 通过GraphicLayer进行图形展示以及图形条组与相应控件Item绑定<br>\n\n\n\n\n<hr>\n<br>\n\n\n* <font size=\"6\" face=\"黑体\" color=#005432 >**重要部分代码实现**</font>\n\n\n1.<font size=\"5\" face=\"黑体\">**分析区域选择**</font><br>\n\n\n\t//通过多点集合绘制几何图形\n\tpolygon.lineTo(currentPoint);\n\tcurrentGraphic = new Graphic(polygon, symbol);\n\tdrawLayer.updateGraphic(currentGraphicIndex,currentGraphic);\n\tpointGraphic=new Graphic(multiPoint,pointSymbol);\n\tdrawLayer.updateGraphic(pointGraphicIndex,pointGraphic);\n\tmultiPoint.add(currentPoint);\n\tif(lastGraphicIndex!=-1){\n\t\tdrawLayer.removeGraphic(lastGraphicIndex);\n\t}\n\tlastGraphic=new Graphic(currentPoint,lastSymbol);\n\tlastGraphicIndex=drawLayer.addGraphic(lastGraphic);\n    \n<br>\n\n2.<font size=\"5\" face=\"黑体\" color=#ff0000>**地图查询**</font><br>\n\n>   离线查询\n\n离线查询通过初始化一个QueryParameter并设置其参数，调用FeatureLayer对象的QueryFeature方法进行查询，拿到查询结果的Geometry与Attribute。\n\n\tQueryParameters queryParams=new QueryParameters();\n\t//设置区域\n\tif (isALL) {\n\tqueryParams.setGeometry(mapView_main.getExtent());\n\t}else {\n\t\tPolygon queryPolygon=measureManager.getpolygon();\n\t\tqueryParams.setGeometry(queryPolygon);\n\t}\n\t//设置过滤字段\n\tqueryParams.setOutFields(new String[]{\"*\"});\n\tlandAnalysisResultInfos=new ArrayList<>();\n\tList<LandAnalysisResultInfo> analysisResultInfos=new ArrayList<>();                    \n\tFuture<FeatureResult> resultFuture=null;\n\tFeatureResult featureResult=null;\n\tFeatureLayer featureLayer=(FeatureLayer)layer;\n\tresultFuture=featureLayer.getFeatureTable().queryFeatures(queryParams,callbackListener);\n\ttry {\n\t\t//获取结果\n\t\tfeatureResult=resultFuture.get();\n\t} catch (InterruptedException e) {\n\t\te.printStackTrace();\n\t} catch (ExecutionException e) {\n\t\te.printStackTrace();\n\t}\n\tif (featureResult!=null&&featureResult.featureCount()>0) {\n\t\tIterator it = featureResult.iterator();\n\t\t while (it.hasNext()){\n\t\tGeodatabaseFeature geodatabaseFeature= (GeodatabaseFeature) it.next();\n\t\tGeometry geometry=geodatabaseFeature.getGeometry();\n\t\t<String, Object> featureMap=geodatabaseFeature.getAttributes();\n\n\t\tif(geometry!=null){\n\t\t\t//进行图形处理\n\t\t}\n\t\tif (featureMap!=null&&featureMap.size()>0) {\n\t\t\t//进行内容详情提取处理\n\t\t}\n\t}\n<br>\n>   在线查询\n\n在线查询通过初始化一个QueryParameter并设置其参数，然后通过在线图层的URL初始化一个QueryTask，通过其对象的execute方法拿到查询结果的Geometry与Attribute。\n\n\tQueryParameters queryParams=new QueryParameters();\n\tPolygon Querypolygon=measureManager.getpolygon();\n\tqueryParams.setGeometry(Querypolygon);\n    landAnalysisResultInfos=new ArrayList<>();\n    queryParams.setOutFields(new String[]{\"*\"});\n    List<LandAnalysisResultInfo> analysisResultInfos=new ArrayList<>();\n    Future<FeatureResult> resultFuture=null;\n\tFeatureResult featureResult=null;\n\tArcGISDynamicMapServiceLayer featureLayer=(ArcGISDynamicMapServiceLayer)layer;\n\tQueryTask queryTask=new QueryTask(featureLayer.getQueryUrl(0));\n\tresultFuture=queryTask.execute(queryParams, callbackListener);\n\ttry {\n\t\tfeatureResult=resultFuture.get();\n\t} catch (InterruptedException e) {\n\t\te.printStackTrace();\n\t} catch (ExecutionException e) {\n\t\te.printStackTrace();\n\t}\n\tif (featureResult!=null&&featureResult.featureCount()>0) {\n\t\tfor (Object element : featureResult) {\n\t\t\tif (element instanceof Feature) {\n\t\t\t\tFeature f = (Feature) element;\n\t\t\t\tGeometry geometry=f.getGeometry();\n\t\t\t\tMap<String, Object> featureMap=f.getAttributes();\n\t\t\t\tif(geometry!=null){\n\t\t\t\t\t//进行图形处理\n\t\t\t\t}\n\t\t\t\tif (featureMap!=null&&featureMap.size()>0) {\n\t\t\t\t\t//进行内容详情提取处理\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}        \n<br>\n\n3.<font size=\"5\" face=\"黑体\" color=#ff0000>**图形交叉处理**</font><br>\n\n>  通过调用GeometeyEngine.intersect()方法获取。\n\n\tGeometry geometry = GeometryEngine.intersect(geometry,measureManager.getpolygon(),mapView_main.getSpatialReference());\n\n<br>\n\n4.<font size=\"5\" face=\"黑体\">**面积计算**</font><br>\n\n>由于获取的Geometry的面积与其父Geometry的面积均为调用Geometry对象的calculateArea2D()方法，并非实际面积。<br>\n>所以我们需要通过Attribute获得的实际面积计算切割Geometry与其父Geometry的实际面积，并计算其百分比。\n\n\t/**\n     *通过在地图上的Area大小计算百分比与实际面积\n     *\n     * @param landResourceInfos 分析结果的数组 成员： {@link LandAnalysisResultInfo}\n     * @return 一个结果的数组 变更了参数数组中成员的属性\n     */\n    public static List<LandAnalysisResultInfo> getLandPercentValue(List<LandAnalysisResultInfo> landResourceInfos){\n        /*计算实际面积 */\n        double MUM=0;\n        for (LandAnalysisResultInfo landResourceInfo : landResourceInfos) {\n            if (landResourceInfo.getYDMJ()==null) {\n                landResourceInfos.remove(landResourceInfo);\n                continue;\n            }\n            Double visualArea=landResourceInfo.getGeometry().calculateArea2D();\n            Double visualParentArea=landResourceInfo.getParentGeometry().calculateArea2D();\n            Double realArea=landResourceInfo.getYDMJ()/visualParentArea*visualArea;\n            landResourceInfo.setYDMJ(realArea);\n\n            //累计求和\n            MUM=MUM+landResourceInfo.getYDMJ();\n        }\n        /*分别计算百分比*/\n        for (LandAnalysisResultInfo landResourceInfo : landResourceInfos) {\n            landResourceInfo.setPercentValue(String.valueOf(landResourceInfo.getYDMJ()/MUM*100));\n        }\n        return landResourceInfos;\n    }\n<br>\n\n5.<font size=\"5\" face=\"黑体\">**图形展示**</font><br>\n\n>由于本次使用为列表显示，故图形展示在点击子Item的时候进行Geometry的绘制与添加。\n\n\t/**\n     * 结果列表点击效果\n     */\n    private AdapterView.OnItemClickListener resultListOnItemClickListener =new AdapterView.OnItemClickListener() {\n        @Override\n        public void onItemClick(AdapterView<?> parent, View view, int position, long id) {\n            resultDrawerLayer.removeAll();\n            resultDrawerLayer.addGraphic(new Graphic(landAnalysisResultInfos.get(position).getGeometry(), MapViewTapTool.getLabelSymbol(MainMapActivity.this,Geometry.Type.POLYGON, Color.BLUE)));\n            resultDrawerLayer.addGraphic(new Graphic(landAnalysisResultInfos.get(position).getParentGeometry(),MapViewTapTool.getLabelSymbol(MainMapActivity.this,Geometry.Type.POLYLINE, Color.BLACK)));\n            Envelope tempEnvelope = new Envelope();\n            landAnalysisResultInfos.get(position).getParentGeometry().queryEnvelope(tempEnvelope);\n            Point tempPoint = tEnvelope.getCenter();\n            mapView_main.centerAt(tempPoint,true);\n        }\n    };\n\n\n\n<hr>\n<br>\n\n\n* <font size=\"6\" face=\"黑体\" color=#005432 >**结语**</font>\n\n\n&emsp;&emsp;用地分析功能的开发，既减少了用户查看地图计算面积的时间，提高了地图的可阅读性。让用户通过移动设备简单的操作即可获取选取区域中各类型的板块内容与面积，并通过绘制图层让用户在地图上更直观的看清板块对象。\n\n<font  size = 3>[相关关键代码查看](https://github.com/xiaoshuiz/Rep4MarkDown/tree/%E7%94%A8%E5%9C%B0%E5%88%86%E6%9E%90%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81/%E7%94%A8%E5%9C%B0%E5%88%86%E6%9E%90 \"点击进去作者Git\")</font>\n<br>\n<br>\n\n<image src=\"http://www.dist.com.cn/templates/cn/images/logo.png\" align=\"right\">\n<br>&emsp;\n\n<br>\n<hr>\n\n","source":"_posts/MOBILE/用地分析.md","raw":"---\ntitle: 移动用地分析\ntags: 移动\ncategories: mobile\n---\n\n<header> \n<td bgcolor=#0099ff>   \n\n   <center><table><tr><td bgcolor=#333333><font size =7 face=\"黑体\" color=#ffffff>**移动用地分析功能**</td></tr></table></center>\n   \n\n</td>\n</header>\n\n<!-- more -->\n\n* <font size=\"6\" face=\"黑体\" color=#005432 >**简介**</font>\n\n\n\n<font size=\"4\">用地分析是指在对地区各自然要素进行综合分析研究的基础上，按照城市规划和建设要求、用地整备工程技术的可能性和经济性，对城市规划用地进行适用性分析评定，以划出城市用地的不同等级。</font>\n<br>\n<font size=\"4\">另外用于查清村和农、林、牧、渔场，居民点及其以外的独立工矿企事业单位土地权属界线和村以上各级行政界线，查清各类用地面积、分布和利用状况。</font>\n<br>\n<font color=#664499 size=\"4\">在本文中，用地分析主要实现为对所选中区域进行土地类别、面积和分布的识别与判断，计算其中各个层级占其父级的百分比以及面积情况。</font>\n<br>\n\n<hr>\n<br>\n\n* <font size=\"6\" face=\"黑体\" color=#005432 >**实现逻辑略析**</font>\n\n\n1. 可视化与相关功能操作窗口的基本实现<br>\n\n\n2. 加载功能基础的地图底图与分析操作图层<br>\n\n\n3. 分析区域的选择并获取当前图形<br>\n\n\n4. <font color=#664499>离线调用FeatureQuery（在线调用QueryTask）进行要素查询与过滤</font><br>\n\n\n5. <font color=#664499>获得结果FeatureResult，从中获取Geometry<font color=#ee0000>（并非与绘制图形做过交叉处理的Geometry）</font>与Attribute</font><br>\n\n\n6. <font color =#664499>图形切割与面积计算</font><br>\n\n\n7. 通过GraphicLayer进行图形展示以及图形条组与相应控件Item绑定<br>\n\n\n\n\n<hr>\n<br>\n\n\n* <font size=\"6\" face=\"黑体\" color=#005432 >**重要部分代码实现**</font>\n\n\n1.<font size=\"5\" face=\"黑体\">**分析区域选择**</font><br>\n\n\n\t//通过多点集合绘制几何图形\n\tpolygon.lineTo(currentPoint);\n\tcurrentGraphic = new Graphic(polygon, symbol);\n\tdrawLayer.updateGraphic(currentGraphicIndex,currentGraphic);\n\tpointGraphic=new Graphic(multiPoint,pointSymbol);\n\tdrawLayer.updateGraphic(pointGraphicIndex,pointGraphic);\n\tmultiPoint.add(currentPoint);\n\tif(lastGraphicIndex!=-1){\n\t\tdrawLayer.removeGraphic(lastGraphicIndex);\n\t}\n\tlastGraphic=new Graphic(currentPoint,lastSymbol);\n\tlastGraphicIndex=drawLayer.addGraphic(lastGraphic);\n    \n<br>\n\n2.<font size=\"5\" face=\"黑体\" color=#ff0000>**地图查询**</font><br>\n\n>   离线查询\n\n离线查询通过初始化一个QueryParameter并设置其参数，调用FeatureLayer对象的QueryFeature方法进行查询，拿到查询结果的Geometry与Attribute。\n\n\tQueryParameters queryParams=new QueryParameters();\n\t//设置区域\n\tif (isALL) {\n\tqueryParams.setGeometry(mapView_main.getExtent());\n\t}else {\n\t\tPolygon queryPolygon=measureManager.getpolygon();\n\t\tqueryParams.setGeometry(queryPolygon);\n\t}\n\t//设置过滤字段\n\tqueryParams.setOutFields(new String[]{\"*\"});\n\tlandAnalysisResultInfos=new ArrayList<>();\n\tList<LandAnalysisResultInfo> analysisResultInfos=new ArrayList<>();                    \n\tFuture<FeatureResult> resultFuture=null;\n\tFeatureResult featureResult=null;\n\tFeatureLayer featureLayer=(FeatureLayer)layer;\n\tresultFuture=featureLayer.getFeatureTable().queryFeatures(queryParams,callbackListener);\n\ttry {\n\t\t//获取结果\n\t\tfeatureResult=resultFuture.get();\n\t} catch (InterruptedException e) {\n\t\te.printStackTrace();\n\t} catch (ExecutionException e) {\n\t\te.printStackTrace();\n\t}\n\tif (featureResult!=null&&featureResult.featureCount()>0) {\n\t\tIterator it = featureResult.iterator();\n\t\t while (it.hasNext()){\n\t\tGeodatabaseFeature geodatabaseFeature= (GeodatabaseFeature) it.next();\n\t\tGeometry geometry=geodatabaseFeature.getGeometry();\n\t\t<String, Object> featureMap=geodatabaseFeature.getAttributes();\n\n\t\tif(geometry!=null){\n\t\t\t//进行图形处理\n\t\t}\n\t\tif (featureMap!=null&&featureMap.size()>0) {\n\t\t\t//进行内容详情提取处理\n\t\t}\n\t}\n<br>\n>   在线查询\n\n在线查询通过初始化一个QueryParameter并设置其参数，然后通过在线图层的URL初始化一个QueryTask，通过其对象的execute方法拿到查询结果的Geometry与Attribute。\n\n\tQueryParameters queryParams=new QueryParameters();\n\tPolygon Querypolygon=measureManager.getpolygon();\n\tqueryParams.setGeometry(Querypolygon);\n    landAnalysisResultInfos=new ArrayList<>();\n    queryParams.setOutFields(new String[]{\"*\"});\n    List<LandAnalysisResultInfo> analysisResultInfos=new ArrayList<>();\n    Future<FeatureResult> resultFuture=null;\n\tFeatureResult featureResult=null;\n\tArcGISDynamicMapServiceLayer featureLayer=(ArcGISDynamicMapServiceLayer)layer;\n\tQueryTask queryTask=new QueryTask(featureLayer.getQueryUrl(0));\n\tresultFuture=queryTask.execute(queryParams, callbackListener);\n\ttry {\n\t\tfeatureResult=resultFuture.get();\n\t} catch (InterruptedException e) {\n\t\te.printStackTrace();\n\t} catch (ExecutionException e) {\n\t\te.printStackTrace();\n\t}\n\tif (featureResult!=null&&featureResult.featureCount()>0) {\n\t\tfor (Object element : featureResult) {\n\t\t\tif (element instanceof Feature) {\n\t\t\t\tFeature f = (Feature) element;\n\t\t\t\tGeometry geometry=f.getGeometry();\n\t\t\t\tMap<String, Object> featureMap=f.getAttributes();\n\t\t\t\tif(geometry!=null){\n\t\t\t\t\t//进行图形处理\n\t\t\t\t}\n\t\t\t\tif (featureMap!=null&&featureMap.size()>0) {\n\t\t\t\t\t//进行内容详情提取处理\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}        \n<br>\n\n3.<font size=\"5\" face=\"黑体\" color=#ff0000>**图形交叉处理**</font><br>\n\n>  通过调用GeometeyEngine.intersect()方法获取。\n\n\tGeometry geometry = GeometryEngine.intersect(geometry,measureManager.getpolygon(),mapView_main.getSpatialReference());\n\n<br>\n\n4.<font size=\"5\" face=\"黑体\">**面积计算**</font><br>\n\n>由于获取的Geometry的面积与其父Geometry的面积均为调用Geometry对象的calculateArea2D()方法，并非实际面积。<br>\n>所以我们需要通过Attribute获得的实际面积计算切割Geometry与其父Geometry的实际面积，并计算其百分比。\n\n\t/**\n     *通过在地图上的Area大小计算百分比与实际面积\n     *\n     * @param landResourceInfos 分析结果的数组 成员： {@link LandAnalysisResultInfo}\n     * @return 一个结果的数组 变更了参数数组中成员的属性\n     */\n    public static List<LandAnalysisResultInfo> getLandPercentValue(List<LandAnalysisResultInfo> landResourceInfos){\n        /*计算实际面积 */\n        double MUM=0;\n        for (LandAnalysisResultInfo landResourceInfo : landResourceInfos) {\n            if (landResourceInfo.getYDMJ()==null) {\n                landResourceInfos.remove(landResourceInfo);\n                continue;\n            }\n            Double visualArea=landResourceInfo.getGeometry().calculateArea2D();\n            Double visualParentArea=landResourceInfo.getParentGeometry().calculateArea2D();\n            Double realArea=landResourceInfo.getYDMJ()/visualParentArea*visualArea;\n            landResourceInfo.setYDMJ(realArea);\n\n            //累计求和\n            MUM=MUM+landResourceInfo.getYDMJ();\n        }\n        /*分别计算百分比*/\n        for (LandAnalysisResultInfo landResourceInfo : landResourceInfos) {\n            landResourceInfo.setPercentValue(String.valueOf(landResourceInfo.getYDMJ()/MUM*100));\n        }\n        return landResourceInfos;\n    }\n<br>\n\n5.<font size=\"5\" face=\"黑体\">**图形展示**</font><br>\n\n>由于本次使用为列表显示，故图形展示在点击子Item的时候进行Geometry的绘制与添加。\n\n\t/**\n     * 结果列表点击效果\n     */\n    private AdapterView.OnItemClickListener resultListOnItemClickListener =new AdapterView.OnItemClickListener() {\n        @Override\n        public void onItemClick(AdapterView<?> parent, View view, int position, long id) {\n            resultDrawerLayer.removeAll();\n            resultDrawerLayer.addGraphic(new Graphic(landAnalysisResultInfos.get(position).getGeometry(), MapViewTapTool.getLabelSymbol(MainMapActivity.this,Geometry.Type.POLYGON, Color.BLUE)));\n            resultDrawerLayer.addGraphic(new Graphic(landAnalysisResultInfos.get(position).getParentGeometry(),MapViewTapTool.getLabelSymbol(MainMapActivity.this,Geometry.Type.POLYLINE, Color.BLACK)));\n            Envelope tempEnvelope = new Envelope();\n            landAnalysisResultInfos.get(position).getParentGeometry().queryEnvelope(tempEnvelope);\n            Point tempPoint = tEnvelope.getCenter();\n            mapView_main.centerAt(tempPoint,true);\n        }\n    };\n\n\n\n<hr>\n<br>\n\n\n* <font size=\"6\" face=\"黑体\" color=#005432 >**结语**</font>\n\n\n&emsp;&emsp;用地分析功能的开发，既减少了用户查看地图计算面积的时间，提高了地图的可阅读性。让用户通过移动设备简单的操作即可获取选取区域中各类型的板块内容与面积，并通过绘制图层让用户在地图上更直观的看清板块对象。\n\n<font  size = 3>[相关关键代码查看](https://github.com/xiaoshuiz/Rep4MarkDown/tree/%E7%94%A8%E5%9C%B0%E5%88%86%E6%9E%90%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81/%E7%94%A8%E5%9C%B0%E5%88%86%E6%9E%90 \"点击进去作者Git\")</font>\n<br>\n<br>\n\n<image src=\"http://www.dist.com.cn/templates/cn/images/logo.png\" align=\"right\">\n<br>&emsp;\n\n<br>\n<hr>\n\n","slug":"MOBILE/用地分析","published":1,"date":"2018-08-13T07:56:34.321Z","updated":"2018-08-31T09:55:00.396Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlhtwxee000gxcl5d65pd133","content":"<header><br><td bgcolor=\"#0099ff\"><br><br>   <center><table><tr><td bgcolor=\"#333333\"><font size=\"7\" face=\"黑体\" color=\"#ffffff\"><strong>移动用地分析功能</strong></font></td></tr></table></center><br><br><br></td><br></header>\n\n<a id=\"more\"></a>\n<ul>\n<li><font size=\"6\" face=\"黑体\" color=\"#005432\"><strong>简介</strong></font>\n\n\n\n</li>\n</ul>\n<font size=\"4\">用地分析是指在对地区各自然要素进行综合分析研究的基础上，按照城市规划和建设要求、用地整备工程技术的可能性和经济性，对城市规划用地进行适用性分析评定，以划出城市用地的不同等级。</font><br><br><br><font size=\"4\">另外用于查清村和农、林、牧、渔场，居民点及其以外的独立工矿企事业单位土地权属界线和村以上各级行政界线，查清各类用地面积、分布和利用状况。</font><br><br><br><font color=\"#664499\" size=\"4\">在本文中，用地分析主要实现为对所选中区域进行土地类别、面积和分布的识别与判断，计算其中各个层级占其父级的百分比以及面积情况。</font><br><br><br><br><hr><br><br><br><br>* <font size=\"6\" face=\"黑体\" color=\"#005432\"><strong>实现逻辑略析</strong></font>\n\n\n<ol>\n<li>可视化与相关功能操作窗口的基本实现<br></li>\n</ol>\n<ol start=\"2\">\n<li>加载功能基础的地图底图与分析操作图层<br></li>\n</ol>\n<ol start=\"3\">\n<li>分析区域的选择并获取当前图形<br></li>\n</ol>\n<ol start=\"4\">\n<li><font color=\"#664499\">离线调用FeatureQuery（在线调用QueryTask）进行要素查询与过滤</font><br></li>\n</ol>\n<ol start=\"5\">\n<li><font color=\"#664499\">获得结果FeatureResult，从中获取Geometry<font color=\"#ee0000\">（并非与绘制图形做过交叉处理的Geometry）</font>与Attribute</font><br></li>\n</ol>\n<ol start=\"6\">\n<li><font color=\"#664499\">图形切割与面积计算</font><br></li>\n</ol>\n<ol start=\"7\">\n<li>通过GraphicLayer进行图形展示以及图形条组与相应控件Item绑定<br></li>\n</ol>\n<p><hr><br><br></p>\n<ul>\n<li><font size=\"6\" face=\"黑体\" color=\"#005432\"><strong>重要部分代码实现</strong></font>\n\n\n</li>\n</ul>\n<p>1.<font size=\"5\" face=\"黑体\"><strong>分析区域选择</strong></font><br></p>\n<pre><code>//通过多点集合绘制几何图形\npolygon.lineTo(currentPoint);\ncurrentGraphic = new Graphic(polygon, symbol);\ndrawLayer.updateGraphic(currentGraphicIndex,currentGraphic);\npointGraphic=new Graphic(multiPoint,pointSymbol);\ndrawLayer.updateGraphic(pointGraphicIndex,pointGraphic);\nmultiPoint.add(currentPoint);\nif(lastGraphicIndex!=-1){\n    drawLayer.removeGraphic(lastGraphicIndex);\n}\nlastGraphic=new Graphic(currentPoint,lastSymbol);\nlastGraphicIndex=drawLayer.addGraphic(lastGraphic);\n</code></pre><p><br></p>\n<p>2.<font size=\"5\" face=\"黑体\" color=\"#ff0000\"><strong>地图查询</strong></font><br></p>\n<blockquote>\n<p>  离线查询</p>\n</blockquote>\n<p>离线查询通过初始化一个QueryParameter并设置其参数，调用FeatureLayer对象的QueryFeature方法进行查询，拿到查询结果的Geometry与Attribute。</p>\n<pre><code>QueryParameters queryParams=new QueryParameters();\n//设置区域\nif (isALL) {\nqueryParams.setGeometry(mapView_main.getExtent());\n}else {\n    Polygon queryPolygon=measureManager.getpolygon();\n    queryParams.setGeometry(queryPolygon);\n}\n//设置过滤字段\nqueryParams.setOutFields(new String[]{&quot;*&quot;});\nlandAnalysisResultInfos=new ArrayList&lt;&gt;();\nList&lt;LandAnalysisResultInfo&gt; analysisResultInfos=new ArrayList&lt;&gt;();                    \nFuture&lt;FeatureResult&gt; resultFuture=null;\nFeatureResult featureResult=null;\nFeatureLayer featureLayer=(FeatureLayer)layer;\nresultFuture=featureLayer.getFeatureTable().queryFeatures(queryParams,callbackListener);\ntry {\n    //获取结果\n    featureResult=resultFuture.get();\n} catch (InterruptedException e) {\n    e.printStackTrace();\n} catch (ExecutionException e) {\n    e.printStackTrace();\n}\nif (featureResult!=null&amp;&amp;featureResult.featureCount()&gt;0) {\n    Iterator it = featureResult.iterator();\n     while (it.hasNext()){\n    GeodatabaseFeature geodatabaseFeature= (GeodatabaseFeature) it.next();\n    Geometry geometry=geodatabaseFeature.getGeometry();\n    &lt;String, Object&gt; featureMap=geodatabaseFeature.getAttributes();\n\n    if(geometry!=null){\n        //进行图形处理\n    }\n    if (featureMap!=null&amp;&amp;featureMap.size()&gt;0) {\n        //进行内容详情提取处理\n    }\n}\n</code></pre><p><br></p>\n<blockquote>\n<p>  在线查询</p>\n</blockquote>\n<p>在线查询通过初始化一个QueryParameter并设置其参数，然后通过在线图层的URL初始化一个QueryTask，通过其对象的execute方法拿到查询结果的Geometry与Attribute。</p>\n<pre><code>QueryParameters queryParams=new QueryParameters();\nPolygon Querypolygon=measureManager.getpolygon();\nqueryParams.setGeometry(Querypolygon);\nlandAnalysisResultInfos=new ArrayList&lt;&gt;();\nqueryParams.setOutFields(new String[]{&quot;*&quot;});\nList&lt;LandAnalysisResultInfo&gt; analysisResultInfos=new ArrayList&lt;&gt;();\nFuture&lt;FeatureResult&gt; resultFuture=null;\nFeatureResult featureResult=null;\nArcGISDynamicMapServiceLayer featureLayer=(ArcGISDynamicMapServiceLayer)layer;\nQueryTask queryTask=new QueryTask(featureLayer.getQueryUrl(0));\nresultFuture=queryTask.execute(queryParams, callbackListener);\ntry {\n    featureResult=resultFuture.get();\n} catch (InterruptedException e) {\n    e.printStackTrace();\n} catch (ExecutionException e) {\n    e.printStackTrace();\n}\nif (featureResult!=null&amp;&amp;featureResult.featureCount()&gt;0) {\n    for (Object element : featureResult) {\n        if (element instanceof Feature) {\n            Feature f = (Feature) element;\n            Geometry geometry=f.getGeometry();\n            Map&lt;String, Object&gt; featureMap=f.getAttributes();\n            if(geometry!=null){\n                //进行图形处理\n            }\n            if (featureMap!=null&amp;&amp;featureMap.size()&gt;0) {\n                //进行内容详情提取处理\n            }\n        }\n    }\n}        \n</code></pre><p><br></p>\n<p>3.<font size=\"5\" face=\"黑体\" color=\"#ff0000\"><strong>图形交叉处理</strong></font><br></p>\n<blockquote>\n<p> 通过调用GeometeyEngine.intersect()方法获取。</p>\n</blockquote>\n<pre><code>Geometry geometry = GeometryEngine.intersect(geometry,measureManager.getpolygon(),mapView_main.getSpatialReference());\n</code></pre><p><br></p>\n<p>4.<font size=\"5\" face=\"黑体\"><strong>面积计算</strong></font><br></p>\n<blockquote>\n<p>由于获取的Geometry的面积与其父Geometry的面积均为调用Geometry对象的calculateArea2D()方法，并非实际面积。<br><br>所以我们需要通过Attribute获得的实际面积计算切割Geometry与其父Geometry的实际面积，并计算其百分比。</p>\n</blockquote>\n<pre><code>/**\n *通过在地图上的Area大小计算百分比与实际面积\n *\n * @param landResourceInfos 分析结果的数组 成员： {@link LandAnalysisResultInfo}\n * @return 一个结果的数组 变更了参数数组中成员的属性\n */\npublic static List&lt;LandAnalysisResultInfo&gt; getLandPercentValue(List&lt;LandAnalysisResultInfo&gt; landResourceInfos){\n    /*计算实际面积 */\n    double MUM=0;\n    for (LandAnalysisResultInfo landResourceInfo : landResourceInfos) {\n        if (landResourceInfo.getYDMJ()==null) {\n            landResourceInfos.remove(landResourceInfo);\n            continue;\n        }\n        Double visualArea=landResourceInfo.getGeometry().calculateArea2D();\n        Double visualParentArea=landResourceInfo.getParentGeometry().calculateArea2D();\n        Double realArea=landResourceInfo.getYDMJ()/visualParentArea*visualArea;\n        landResourceInfo.setYDMJ(realArea);\n\n        //累计求和\n        MUM=MUM+landResourceInfo.getYDMJ();\n    }\n    /*分别计算百分比*/\n    for (LandAnalysisResultInfo landResourceInfo : landResourceInfos) {\n        landResourceInfo.setPercentValue(String.valueOf(landResourceInfo.getYDMJ()/MUM*100));\n    }\n    return landResourceInfos;\n}\n</code></pre><p><br></p>\n<p>5.<font size=\"5\" face=\"黑体\"><strong>图形展示</strong></font><br></p>\n<blockquote>\n<p>由于本次使用为列表显示，故图形展示在点击子Item的时候进行Geometry的绘制与添加。</p>\n</blockquote>\n<pre><code>/**\n * 结果列表点击效果\n */\nprivate AdapterView.OnItemClickListener resultListOnItemClickListener =new AdapterView.OnItemClickListener() {\n    @Override\n    public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {\n        resultDrawerLayer.removeAll();\n        resultDrawerLayer.addGraphic(new Graphic(landAnalysisResultInfos.get(position).getGeometry(), MapViewTapTool.getLabelSymbol(MainMapActivity.this,Geometry.Type.POLYGON, Color.BLUE)));\n        resultDrawerLayer.addGraphic(new Graphic(landAnalysisResultInfos.get(position).getParentGeometry(),MapViewTapTool.getLabelSymbol(MainMapActivity.this,Geometry.Type.POLYLINE, Color.BLACK)));\n        Envelope tempEnvelope = new Envelope();\n        landAnalysisResultInfos.get(position).getParentGeometry().queryEnvelope(tempEnvelope);\n        Point tempPoint = tEnvelope.getCenter();\n        mapView_main.centerAt(tempPoint,true);\n    }\n};\n</code></pre><p><hr><br><br></p>\n<ul>\n<li><font size=\"6\" face=\"黑体\" color=\"#005432\"><strong>结语</strong></font>\n\n\n</li>\n</ul>\n<p>&emsp;&emsp;用地分析功能的开发，既减少了用户查看地图计算面积的时间，提高了地图的可阅读性。让用户通过移动设备简单的操作即可获取选取区域中各类型的板块内容与面积，并通过绘制图层让用户在地图上更直观的看清板块对象。</p>\n<p><font size=\"3\"><a href=\"https://github.com/xiaoshuiz/Rep4MarkDown/tree/%E7%94%A8%E5%9C%B0%E5%88%86%E6%9E%90%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81/%E7%94%A8%E5%9C%B0%E5%88%86%E6%9E%90\" title=\"点击进去作者Git\" target=\"_blank\" rel=\"noopener\">相关关键代码查看</a></font><br><br><br><br></p>\n<p><image src=\"http://www.dist.com.cn/templates/cn/images/logo.png\" align=\"right\"><br><br>&emsp;</image></p>\n<p><br></p>\n<hr>\n\n","site":{"data":{}},"excerpt":"<header><br><td bgcolor=\"#0099ff\"><br><br>   <center><table><tr><td bgcolor=\"#333333\"><font size=\"7\" face=\"黑体\" color=\"#ffffff\"><strong>移动用地分析功能</strong></font></td></tr></table></center><br><br><br></td><br></header>","more":"<ul>\n<li><font size=\"6\" face=\"黑体\" color=\"#005432\"><strong>简介</strong></font>\n\n\n\n</li>\n</ul>\n<font size=\"4\">用地分析是指在对地区各自然要素进行综合分析研究的基础上，按照城市规划和建设要求、用地整备工程技术的可能性和经济性，对城市规划用地进行适用性分析评定，以划出城市用地的不同等级。</font><br><br><br><font size=\"4\">另外用于查清村和农、林、牧、渔场，居民点及其以外的独立工矿企事业单位土地权属界线和村以上各级行政界线，查清各类用地面积、分布和利用状况。</font><br><br><br><font color=\"#664499\" size=\"4\">在本文中，用地分析主要实现为对所选中区域进行土地类别、面积和分布的识别与判断，计算其中各个层级占其父级的百分比以及面积情况。</font><br><br><br><br><hr><br><br><br><br>* <font size=\"6\" face=\"黑体\" color=\"#005432\"><strong>实现逻辑略析</strong></font>\n\n\n<ol>\n<li>可视化与相关功能操作窗口的基本实现<br></li>\n</ol>\n<ol start=\"2\">\n<li>加载功能基础的地图底图与分析操作图层<br></li>\n</ol>\n<ol start=\"3\">\n<li>分析区域的选择并获取当前图形<br></li>\n</ol>\n<ol start=\"4\">\n<li><font color=\"#664499\">离线调用FeatureQuery（在线调用QueryTask）进行要素查询与过滤</font><br></li>\n</ol>\n<ol start=\"5\">\n<li><font color=\"#664499\">获得结果FeatureResult，从中获取Geometry<font color=\"#ee0000\">（并非与绘制图形做过交叉处理的Geometry）</font>与Attribute</font><br></li>\n</ol>\n<ol start=\"6\">\n<li><font color=\"#664499\">图形切割与面积计算</font><br></li>\n</ol>\n<ol start=\"7\">\n<li>通过GraphicLayer进行图形展示以及图形条组与相应控件Item绑定<br></li>\n</ol>\n<p><hr><br><br></p>\n<ul>\n<li><font size=\"6\" face=\"黑体\" color=\"#005432\"><strong>重要部分代码实现</strong></font>\n\n\n</li>\n</ul>\n<p>1.<font size=\"5\" face=\"黑体\"><strong>分析区域选择</strong></font><br></p>\n<pre><code>//通过多点集合绘制几何图形\npolygon.lineTo(currentPoint);\ncurrentGraphic = new Graphic(polygon, symbol);\ndrawLayer.updateGraphic(currentGraphicIndex,currentGraphic);\npointGraphic=new Graphic(multiPoint,pointSymbol);\ndrawLayer.updateGraphic(pointGraphicIndex,pointGraphic);\nmultiPoint.add(currentPoint);\nif(lastGraphicIndex!=-1){\n    drawLayer.removeGraphic(lastGraphicIndex);\n}\nlastGraphic=new Graphic(currentPoint,lastSymbol);\nlastGraphicIndex=drawLayer.addGraphic(lastGraphic);\n</code></pre><p><br></p>\n<p>2.<font size=\"5\" face=\"黑体\" color=\"#ff0000\"><strong>地图查询</strong></font><br></p>\n<blockquote>\n<p>  离线查询</p>\n</blockquote>\n<p>离线查询通过初始化一个QueryParameter并设置其参数，调用FeatureLayer对象的QueryFeature方法进行查询，拿到查询结果的Geometry与Attribute。</p>\n<pre><code>QueryParameters queryParams=new QueryParameters();\n//设置区域\nif (isALL) {\nqueryParams.setGeometry(mapView_main.getExtent());\n}else {\n    Polygon queryPolygon=measureManager.getpolygon();\n    queryParams.setGeometry(queryPolygon);\n}\n//设置过滤字段\nqueryParams.setOutFields(new String[]{&quot;*&quot;});\nlandAnalysisResultInfos=new ArrayList&lt;&gt;();\nList&lt;LandAnalysisResultInfo&gt; analysisResultInfos=new ArrayList&lt;&gt;();                    \nFuture&lt;FeatureResult&gt; resultFuture=null;\nFeatureResult featureResult=null;\nFeatureLayer featureLayer=(FeatureLayer)layer;\nresultFuture=featureLayer.getFeatureTable().queryFeatures(queryParams,callbackListener);\ntry {\n    //获取结果\n    featureResult=resultFuture.get();\n} catch (InterruptedException e) {\n    e.printStackTrace();\n} catch (ExecutionException e) {\n    e.printStackTrace();\n}\nif (featureResult!=null&amp;&amp;featureResult.featureCount()&gt;0) {\n    Iterator it = featureResult.iterator();\n     while (it.hasNext()){\n    GeodatabaseFeature geodatabaseFeature= (GeodatabaseFeature) it.next();\n    Geometry geometry=geodatabaseFeature.getGeometry();\n    &lt;String, Object&gt; featureMap=geodatabaseFeature.getAttributes();\n\n    if(geometry!=null){\n        //进行图形处理\n    }\n    if (featureMap!=null&amp;&amp;featureMap.size()&gt;0) {\n        //进行内容详情提取处理\n    }\n}\n</code></pre><p><br></p>\n<blockquote>\n<p>  在线查询</p>\n</blockquote>\n<p>在线查询通过初始化一个QueryParameter并设置其参数，然后通过在线图层的URL初始化一个QueryTask，通过其对象的execute方法拿到查询结果的Geometry与Attribute。</p>\n<pre><code>QueryParameters queryParams=new QueryParameters();\nPolygon Querypolygon=measureManager.getpolygon();\nqueryParams.setGeometry(Querypolygon);\nlandAnalysisResultInfos=new ArrayList&lt;&gt;();\nqueryParams.setOutFields(new String[]{&quot;*&quot;});\nList&lt;LandAnalysisResultInfo&gt; analysisResultInfos=new ArrayList&lt;&gt;();\nFuture&lt;FeatureResult&gt; resultFuture=null;\nFeatureResult featureResult=null;\nArcGISDynamicMapServiceLayer featureLayer=(ArcGISDynamicMapServiceLayer)layer;\nQueryTask queryTask=new QueryTask(featureLayer.getQueryUrl(0));\nresultFuture=queryTask.execute(queryParams, callbackListener);\ntry {\n    featureResult=resultFuture.get();\n} catch (InterruptedException e) {\n    e.printStackTrace();\n} catch (ExecutionException e) {\n    e.printStackTrace();\n}\nif (featureResult!=null&amp;&amp;featureResult.featureCount()&gt;0) {\n    for (Object element : featureResult) {\n        if (element instanceof Feature) {\n            Feature f = (Feature) element;\n            Geometry geometry=f.getGeometry();\n            Map&lt;String, Object&gt; featureMap=f.getAttributes();\n            if(geometry!=null){\n                //进行图形处理\n            }\n            if (featureMap!=null&amp;&amp;featureMap.size()&gt;0) {\n                //进行内容详情提取处理\n            }\n        }\n    }\n}        \n</code></pre><p><br></p>\n<p>3.<font size=\"5\" face=\"黑体\" color=\"#ff0000\"><strong>图形交叉处理</strong></font><br></p>\n<blockquote>\n<p> 通过调用GeometeyEngine.intersect()方法获取。</p>\n</blockquote>\n<pre><code>Geometry geometry = GeometryEngine.intersect(geometry,measureManager.getpolygon(),mapView_main.getSpatialReference());\n</code></pre><p><br></p>\n<p>4.<font size=\"5\" face=\"黑体\"><strong>面积计算</strong></font><br></p>\n<blockquote>\n<p>由于获取的Geometry的面积与其父Geometry的面积均为调用Geometry对象的calculateArea2D()方法，并非实际面积。<br><br>所以我们需要通过Attribute获得的实际面积计算切割Geometry与其父Geometry的实际面积，并计算其百分比。</p>\n</blockquote>\n<pre><code>/**\n *通过在地图上的Area大小计算百分比与实际面积\n *\n * @param landResourceInfos 分析结果的数组 成员： {@link LandAnalysisResultInfo}\n * @return 一个结果的数组 变更了参数数组中成员的属性\n */\npublic static List&lt;LandAnalysisResultInfo&gt; getLandPercentValue(List&lt;LandAnalysisResultInfo&gt; landResourceInfos){\n    /*计算实际面积 */\n    double MUM=0;\n    for (LandAnalysisResultInfo landResourceInfo : landResourceInfos) {\n        if (landResourceInfo.getYDMJ()==null) {\n            landResourceInfos.remove(landResourceInfo);\n            continue;\n        }\n        Double visualArea=landResourceInfo.getGeometry().calculateArea2D();\n        Double visualParentArea=landResourceInfo.getParentGeometry().calculateArea2D();\n        Double realArea=landResourceInfo.getYDMJ()/visualParentArea*visualArea;\n        landResourceInfo.setYDMJ(realArea);\n\n        //累计求和\n        MUM=MUM+landResourceInfo.getYDMJ();\n    }\n    /*分别计算百分比*/\n    for (LandAnalysisResultInfo landResourceInfo : landResourceInfos) {\n        landResourceInfo.setPercentValue(String.valueOf(landResourceInfo.getYDMJ()/MUM*100));\n    }\n    return landResourceInfos;\n}\n</code></pre><p><br></p>\n<p>5.<font size=\"5\" face=\"黑体\"><strong>图形展示</strong></font><br></p>\n<blockquote>\n<p>由于本次使用为列表显示，故图形展示在点击子Item的时候进行Geometry的绘制与添加。</p>\n</blockquote>\n<pre><code>/**\n * 结果列表点击效果\n */\nprivate AdapterView.OnItemClickListener resultListOnItemClickListener =new AdapterView.OnItemClickListener() {\n    @Override\n    public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {\n        resultDrawerLayer.removeAll();\n        resultDrawerLayer.addGraphic(new Graphic(landAnalysisResultInfos.get(position).getGeometry(), MapViewTapTool.getLabelSymbol(MainMapActivity.this,Geometry.Type.POLYGON, Color.BLUE)));\n        resultDrawerLayer.addGraphic(new Graphic(landAnalysisResultInfos.get(position).getParentGeometry(),MapViewTapTool.getLabelSymbol(MainMapActivity.this,Geometry.Type.POLYLINE, Color.BLACK)));\n        Envelope tempEnvelope = new Envelope();\n        landAnalysisResultInfos.get(position).getParentGeometry().queryEnvelope(tempEnvelope);\n        Point tempPoint = tEnvelope.getCenter();\n        mapView_main.centerAt(tempPoint,true);\n    }\n};\n</code></pre><p><hr><br><br></p>\n<ul>\n<li><font size=\"6\" face=\"黑体\" color=\"#005432\"><strong>结语</strong></font>\n\n\n</li>\n</ul>\n<p>&emsp;&emsp;用地分析功能的开发，既减少了用户查看地图计算面积的时间，提高了地图的可阅读性。让用户通过移动设备简单的操作即可获取选取区域中各类型的板块内容与面积，并通过绘制图层让用户在地图上更直观的看清板块对象。</p>\n<p><font size=\"3\"><a href=\"https://github.com/xiaoshuiz/Rep4MarkDown/tree/%E7%94%A8%E5%9C%B0%E5%88%86%E6%9E%90%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81/%E7%94%A8%E5%9C%B0%E5%88%86%E6%9E%90\" title=\"点击进去作者Git\" target=\"_blank\" rel=\"noopener\">相关关键代码查看</a></font><br><br><br><br></p>\n<p><image src=\"http://www.dist.com.cn/templates/cn/images/logo.png\" align=\"right\"><br><br>&emsp;</image></p>\n<p><br></p>\n<hr>"},{"title":"移动在线缓存功能","_content":"\n#1. 简介\n1. 离线在线一体化\n数据存储在企业级地理数据库中，通过Arcgis桌面加载后配图处理，并发布到Arcgis for Server中，供移动端设备编辑使用，并可以同步回传版本化存档。\n\n<!-- more -->\n\n2. 应用场景\n在没有网络的情况下我们需要用到在线的地图数据进行操作，这些数据需要有一定的时效性，如果采用，打包离线包的方式提前做好离线数据，那时效性相对较差。所以，用在线缓存技术可以支持这一点。\n#2. 在线缓存的实现逻辑思路\n- 在地图上选定区域，作为需要下载对应离线数据的地图范围（可以设定范围，也可以自定义）\n- 获取下载滴地图服务所需要的具体参数\n- 在本地创建文件，存放下载的数据，以供使用\n#3. 用到的核心功能类以及说明\n- GeodatabaseSyncTask类，实现下载同步功能\n- GenerateGeodatabaseParameters，下载数据时所需的参数对象，该类构造函数一共有7个根据需要选择\n![image.png](https://upload-images.jianshu.io/upload_images/13449852-0a6c357a2b8c670d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n-  CallbackListener<Geodatabase>，完成GDB数据库下载的回调函数类，在该回调中我们只可以执行一些操作，如示例里在回调中删除了在线的服务图层，加载离线的数据图层到地图上进行显示。通过Geodatabase本地数据库可以获取要素图层列表[List](http://blog.csdn.net/arcgis_all/article/details/20442663)<[GdbFeatureTable](http://blog.csdn.net/arcgis_all/article/details/20442663)>对象，通过newFeatureLayer(gdbFeatureTable)来创建一个离线要素图层进行要素显示。\n-  GeodatabaseStatusCallback，本地数据库回调状态类，在数据下载过程中会有很多状态改变，各种状态改变时都会走这个类的回调函数。\n-  GeodatabaseTask.generateGeodatabase，通过该方法生成离线数据库和相应的要素表，方法需要传递上面介绍的三个参数和一个数据库存储的路径。\n#4. 代码示例\n1. 在地图上自定义一个区域\n```\n     /**\n     * 绘制出在线缓存区域\n     * */\n    private void polygonState(Point currentPoint)throws Exception{\n        if(startPoint!=null&&!startPoint.isEmpty()){\n            polygon.lineTo(currentPoint);\n            currentGraphic = new Graphic(polygon, symbol);\n            drawLayer.updateGraphic(currentGraphicIndex,currentGraphic);\n\n            pointGraphic=new Graphic(multiPoint,pointSymbol);\n            drawLayer.updateGraphic(pointGraphicIndex,pointGraphic);\n            multiPoint.add(currentPoint);\n            if(lastGraphicIndex!=-1){\n                drawLayer.removeGraphic(lastGraphicIndex);\n            }\n            lastGraphic=new Graphic(currentPoint,lastSymbol);\n            lastGraphicIndex=drawLayer.addGraphic(lastGraphic);\n\n            if(polygon.getPointCount()>=3){\n                isCheckedSave=true;\n                isSave=isCheckedSave;\n                onlinesave.setTextColor(ContextCompat.getColor(mActivity,R.color.blue));\n                onlinesave.setClickable(isSave);\n            }\n        }else{\n            polygon=new Polygon();\n            multiPoint=new MultiPoint();\n            polygon.startPath(currentPoint);\n            startPoint=currentPoint;\n            currentGraphic=new Graphic(startPoint,symbol);\n            currentGraphicIndex=drawLayer.addGraphic(currentGraphic);\n            pointGraphic=new Graphic(startPoint,lastSymbol);\n            pointGraphicIndex=drawLayer.addGraphic(pointGraphic);\n            multiPoint.add(currentPoint);\n        }\n    }\n    /**\n     * 确定所选区域范围\n     * */\n    public void SaveLabel()throws Exception{\n        if(isSave&&drawLayer!=null) {\n            startPoint = null;\n            isCheckedSave=false;\n            isSave=isCheckedSave;\n            onlinesave.setTextColor(ContextCompat.getColor(mActivity,R.color.gray));\n            onlinesave.setClickable(isSave);\n            if(currentGraphicIndex!=-1){\n                Graphic graphic = drawLayer.getGraphic(currentGraphicIndex);\n                if(graphic!=null){\n                    Geometry geometry=graphic.getGeometry();\n                    Graphic saveGraphic=null;\n                    if(geometryType.equals(Geometry.Type.POLYGON)){\n                        symbol=MapViewTapTool.getLabelSymbol(mActivity,geometryType,ContextCompat.getColor(mActivity,R.color.green_transparent));\n                        saveGraphic=new Graphic(geometry,symbol);\n                        pointSymbol=MapViewTapTool.getCircleGreenSymbol(mActivity);\n                        pointGraphic=new Graphic(geometry,pointSymbol);\n                    }else{\n                        symbol=MapViewTapTool.getLabelSymbol(mActivity,geometryType,ContextCompat.getColor(mActivity,R.color.green));\n                        saveGraphic=new Graphic(geometry,symbol);\n                        pointSymbol=MapViewTapTool.getCircleGreenSymbol(mActivity);\n                        pointGraphic=new Graphic(geometry,pointSymbol);\n                    }\n                    if(onlineCacheInfoList!=null&&onlineCacheInfoList.size()>0){\n                        setView();\n                        int i = 0;\n                        if(onlineCacheInfoList.get(i).getCacheurl().trim().length()>0) {\n                            downloadData(onlineCacheInfoList.get(i), geometry, i);//缓存featureLayer\n                        }\n                    }\n                }\n            }\n        }else{\n            isCheckedSave=false;\n            isSave=isCheckedSave;\n            onlinesave.setTextColor(ContextCompat.getColor(mActivity,R.color.gray));\n            onlinesave.setClickable(isSave);\n        }\n    }\n```\n2. 下载选定区域所对应的在线缓存的文件\n```\nprivate void downloadData(final OnlineCacheInfo onlineCacheInfo, final Geometry geometry, final int i) {\n        gdbSyncTask = new GeodatabaseSyncTask(onlineCacheInfo.getCacheurl(), null);\n        gdbSyncTask.fetchFeatureServiceInfo(new CallbackListener<FeatureServiceInfo>() {\n                    @Override\n                    public void onError(Throwable arg0) {\n                        Log.e(TAG, \"Error fetching FeatureServiceInfo\");\n                    }\n\n                    @Override\n                    public void onCallback(FeatureServiceInfo fsInfo) {\n                        if (fsInfo.isSyncEnabled()) {\n                           //回调获取所需要的下载的图层信息\n                            createGeodatabase(onlineCacheInfo.getIds(),geometry,i);\n                        }\n                    }\n                });\n\n    }\n    //创建下载\n    private void createGeodatabase(int[] ids, final Geometry geometry, final int i) {\n        SpatialReference sp=mOneMapView.getSpatialReference();\n        GenerateGeodatabaseParameters params = new GenerateGeodatabaseParameters(ids, geometry,sp,true, SyncModel.GEODATABASE);\n\n        CallbackListener<String> gdbResponseCallback = new CallbackListener<String>() {\n            @Override\n            public void onError(final Throwable e) {\n                Log.e(TAG, \"Error creating geodatabase\");\n                Toast.makeText(mActivity, \"数据下载失败!\", Toast.LENGTH_LONG).show();\n                pDialog.dismiss();\n            }\n\n            @Override\n            public void onCallback(String path) {\n                updateFeatureLayer(path);\n                if(i<onlineCacheInfoList.size()&&onlineCacheInfoList.get(i+1).getCacheurl().trim().length()>0){\n                    downloadData(onlineCacheInfoList.get(i+1),geometry,i+1);\n                }else {\n                    pDialog.dismiss();\n                    Toast.makeText(mActivity, \"数据下载完成!\", Toast.LENGTH_LONG).show();\n                }\n            }\n        };\n        localGdbFilePath = \"对应在本地存储的存储路径以及存储名称\";\n        submitTask(params, localGdbFilePath, statusCallback,\n                gdbResponseCallback);\n    }\n    private void submitTask(GenerateGeodatabaseParameters params,\n                            String file, GeodatabaseStatusCallback statusCallback,\n                            CallbackListener<String> gdbResponseCallback) {\n        // submit task\n        gdbSyncTask.generateGeodatabase(params, file, false, statusCallback,\n                gdbResponseCallback);\n    }\n```\n\n3. 将下载完成的数据再地图上展示\n\n```\n//加载数据\nprivate void updateFeatureLayer(String featureLayerPath) {\n        // create a new geodatabase\n        Geodatabase localGdb = null;\n        try {\n            localGdb = new Geodatabase(featureLayerPath);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n\n        if (localGdb != null) {\n            for (GeodatabaseFeatureTable gdbFeatureTable : localGdb\n                    .getGeodatabaseTables()) {\n                if (gdbFeatureTable.hasGeometry()){\n                    mOneMapView.addLayer(new FeatureLayer(gdbFeatureTable));\n                }\n            }\n        }\n    }\n```\n#5. 结语\n在线缓存的应用，减少了手动制作离线数据的步骤，大大提高了地图制作的效率，只需发布对应的地图服务就能实现离线数据的在线下载。另外也同时保证了数据的时效性，如果对应地图服务有新的数据更改，那我们可以重新下载新的在线数据，不需要再去手动打包地图文件。\n\n\n- 最后感谢您的阅读，有机会一起探讨！\n","source":"_posts/MOBILE/在线缓存功能开发分享.md","raw":"---\ntitle: 移动在线缓存功能\ntags: 移动\ncategories: mobile\n---\n\n#1. 简介\n1. 离线在线一体化\n数据存储在企业级地理数据库中，通过Arcgis桌面加载后配图处理，并发布到Arcgis for Server中，供移动端设备编辑使用，并可以同步回传版本化存档。\n\n<!-- more -->\n\n2. 应用场景\n在没有网络的情况下我们需要用到在线的地图数据进行操作，这些数据需要有一定的时效性，如果采用，打包离线包的方式提前做好离线数据，那时效性相对较差。所以，用在线缓存技术可以支持这一点。\n#2. 在线缓存的实现逻辑思路\n- 在地图上选定区域，作为需要下载对应离线数据的地图范围（可以设定范围，也可以自定义）\n- 获取下载滴地图服务所需要的具体参数\n- 在本地创建文件，存放下载的数据，以供使用\n#3. 用到的核心功能类以及说明\n- GeodatabaseSyncTask类，实现下载同步功能\n- GenerateGeodatabaseParameters，下载数据时所需的参数对象，该类构造函数一共有7个根据需要选择\n![image.png](https://upload-images.jianshu.io/upload_images/13449852-0a6c357a2b8c670d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n-  CallbackListener<Geodatabase>，完成GDB数据库下载的回调函数类，在该回调中我们只可以执行一些操作，如示例里在回调中删除了在线的服务图层，加载离线的数据图层到地图上进行显示。通过Geodatabase本地数据库可以获取要素图层列表[List](http://blog.csdn.net/arcgis_all/article/details/20442663)<[GdbFeatureTable](http://blog.csdn.net/arcgis_all/article/details/20442663)>对象，通过newFeatureLayer(gdbFeatureTable)来创建一个离线要素图层进行要素显示。\n-  GeodatabaseStatusCallback，本地数据库回调状态类，在数据下载过程中会有很多状态改变，各种状态改变时都会走这个类的回调函数。\n-  GeodatabaseTask.generateGeodatabase，通过该方法生成离线数据库和相应的要素表，方法需要传递上面介绍的三个参数和一个数据库存储的路径。\n#4. 代码示例\n1. 在地图上自定义一个区域\n```\n     /**\n     * 绘制出在线缓存区域\n     * */\n    private void polygonState(Point currentPoint)throws Exception{\n        if(startPoint!=null&&!startPoint.isEmpty()){\n            polygon.lineTo(currentPoint);\n            currentGraphic = new Graphic(polygon, symbol);\n            drawLayer.updateGraphic(currentGraphicIndex,currentGraphic);\n\n            pointGraphic=new Graphic(multiPoint,pointSymbol);\n            drawLayer.updateGraphic(pointGraphicIndex,pointGraphic);\n            multiPoint.add(currentPoint);\n            if(lastGraphicIndex!=-1){\n                drawLayer.removeGraphic(lastGraphicIndex);\n            }\n            lastGraphic=new Graphic(currentPoint,lastSymbol);\n            lastGraphicIndex=drawLayer.addGraphic(lastGraphic);\n\n            if(polygon.getPointCount()>=3){\n                isCheckedSave=true;\n                isSave=isCheckedSave;\n                onlinesave.setTextColor(ContextCompat.getColor(mActivity,R.color.blue));\n                onlinesave.setClickable(isSave);\n            }\n        }else{\n            polygon=new Polygon();\n            multiPoint=new MultiPoint();\n            polygon.startPath(currentPoint);\n            startPoint=currentPoint;\n            currentGraphic=new Graphic(startPoint,symbol);\n            currentGraphicIndex=drawLayer.addGraphic(currentGraphic);\n            pointGraphic=new Graphic(startPoint,lastSymbol);\n            pointGraphicIndex=drawLayer.addGraphic(pointGraphic);\n            multiPoint.add(currentPoint);\n        }\n    }\n    /**\n     * 确定所选区域范围\n     * */\n    public void SaveLabel()throws Exception{\n        if(isSave&&drawLayer!=null) {\n            startPoint = null;\n            isCheckedSave=false;\n            isSave=isCheckedSave;\n            onlinesave.setTextColor(ContextCompat.getColor(mActivity,R.color.gray));\n            onlinesave.setClickable(isSave);\n            if(currentGraphicIndex!=-1){\n                Graphic graphic = drawLayer.getGraphic(currentGraphicIndex);\n                if(graphic!=null){\n                    Geometry geometry=graphic.getGeometry();\n                    Graphic saveGraphic=null;\n                    if(geometryType.equals(Geometry.Type.POLYGON)){\n                        symbol=MapViewTapTool.getLabelSymbol(mActivity,geometryType,ContextCompat.getColor(mActivity,R.color.green_transparent));\n                        saveGraphic=new Graphic(geometry,symbol);\n                        pointSymbol=MapViewTapTool.getCircleGreenSymbol(mActivity);\n                        pointGraphic=new Graphic(geometry,pointSymbol);\n                    }else{\n                        symbol=MapViewTapTool.getLabelSymbol(mActivity,geometryType,ContextCompat.getColor(mActivity,R.color.green));\n                        saveGraphic=new Graphic(geometry,symbol);\n                        pointSymbol=MapViewTapTool.getCircleGreenSymbol(mActivity);\n                        pointGraphic=new Graphic(geometry,pointSymbol);\n                    }\n                    if(onlineCacheInfoList!=null&&onlineCacheInfoList.size()>0){\n                        setView();\n                        int i = 0;\n                        if(onlineCacheInfoList.get(i).getCacheurl().trim().length()>0) {\n                            downloadData(onlineCacheInfoList.get(i), geometry, i);//缓存featureLayer\n                        }\n                    }\n                }\n            }\n        }else{\n            isCheckedSave=false;\n            isSave=isCheckedSave;\n            onlinesave.setTextColor(ContextCompat.getColor(mActivity,R.color.gray));\n            onlinesave.setClickable(isSave);\n        }\n    }\n```\n2. 下载选定区域所对应的在线缓存的文件\n```\nprivate void downloadData(final OnlineCacheInfo onlineCacheInfo, final Geometry geometry, final int i) {\n        gdbSyncTask = new GeodatabaseSyncTask(onlineCacheInfo.getCacheurl(), null);\n        gdbSyncTask.fetchFeatureServiceInfo(new CallbackListener<FeatureServiceInfo>() {\n                    @Override\n                    public void onError(Throwable arg0) {\n                        Log.e(TAG, \"Error fetching FeatureServiceInfo\");\n                    }\n\n                    @Override\n                    public void onCallback(FeatureServiceInfo fsInfo) {\n                        if (fsInfo.isSyncEnabled()) {\n                           //回调获取所需要的下载的图层信息\n                            createGeodatabase(onlineCacheInfo.getIds(),geometry,i);\n                        }\n                    }\n                });\n\n    }\n    //创建下载\n    private void createGeodatabase(int[] ids, final Geometry geometry, final int i) {\n        SpatialReference sp=mOneMapView.getSpatialReference();\n        GenerateGeodatabaseParameters params = new GenerateGeodatabaseParameters(ids, geometry,sp,true, SyncModel.GEODATABASE);\n\n        CallbackListener<String> gdbResponseCallback = new CallbackListener<String>() {\n            @Override\n            public void onError(final Throwable e) {\n                Log.e(TAG, \"Error creating geodatabase\");\n                Toast.makeText(mActivity, \"数据下载失败!\", Toast.LENGTH_LONG).show();\n                pDialog.dismiss();\n            }\n\n            @Override\n            public void onCallback(String path) {\n                updateFeatureLayer(path);\n                if(i<onlineCacheInfoList.size()&&onlineCacheInfoList.get(i+1).getCacheurl().trim().length()>0){\n                    downloadData(onlineCacheInfoList.get(i+1),geometry,i+1);\n                }else {\n                    pDialog.dismiss();\n                    Toast.makeText(mActivity, \"数据下载完成!\", Toast.LENGTH_LONG).show();\n                }\n            }\n        };\n        localGdbFilePath = \"对应在本地存储的存储路径以及存储名称\";\n        submitTask(params, localGdbFilePath, statusCallback,\n                gdbResponseCallback);\n    }\n    private void submitTask(GenerateGeodatabaseParameters params,\n                            String file, GeodatabaseStatusCallback statusCallback,\n                            CallbackListener<String> gdbResponseCallback) {\n        // submit task\n        gdbSyncTask.generateGeodatabase(params, file, false, statusCallback,\n                gdbResponseCallback);\n    }\n```\n\n3. 将下载完成的数据再地图上展示\n\n```\n//加载数据\nprivate void updateFeatureLayer(String featureLayerPath) {\n        // create a new geodatabase\n        Geodatabase localGdb = null;\n        try {\n            localGdb = new Geodatabase(featureLayerPath);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n\n        if (localGdb != null) {\n            for (GeodatabaseFeatureTable gdbFeatureTable : localGdb\n                    .getGeodatabaseTables()) {\n                if (gdbFeatureTable.hasGeometry()){\n                    mOneMapView.addLayer(new FeatureLayer(gdbFeatureTable));\n                }\n            }\n        }\n    }\n```\n#5. 结语\n在线缓存的应用，减少了手动制作离线数据的步骤，大大提高了地图制作的效率，只需发布对应的地图服务就能实现离线数据的在线下载。另外也同时保证了数据的时效性，如果对应地图服务有新的数据更改，那我们可以重新下载新的在线数据，不需要再去手动打包地图文件。\n\n\n- 最后感谢您的阅读，有机会一起探讨！\n","slug":"MOBILE/在线缓存功能开发分享","published":1,"date":"2018-08-09T16:22:05.105Z","updated":"2018-08-31T09:55:26.632Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlhtwxef000hxcl5bswkqebw","content":"<p>#1. 简介</p>\n<ol>\n<li>离线在线一体化<br>数据存储在企业级地理数据库中，通过Arcgis桌面加载后配图处理，并发布到Arcgis for Server中，供移动端设备编辑使用，并可以同步回传版本化存档。</li>\n</ol>\n<a id=\"more\"></a>\n<ol start=\"2\">\n<li>应用场景<br>在没有网络的情况下我们需要用到在线的地图数据进行操作，这些数据需要有一定的时效性，如果采用，打包离线包的方式提前做好离线数据，那时效性相对较差。所以，用在线缓存技术可以支持这一点。<br>#2. 在线缓存的实现逻辑思路</li>\n</ol>\n<ul>\n<li>在地图上选定区域，作为需要下载对应离线数据的地图范围（可以设定范围，也可以自定义）</li>\n<li>获取下载滴地图服务所需要的具体参数</li>\n<li>在本地创建文件，存放下载的数据，以供使用<br>#3. 用到的核心功能类以及说明</li>\n<li>GeodatabaseSyncTask类，实现下载同步功能</li>\n<li>GenerateGeodatabaseParameters，下载数据时所需的参数对象，该类构造函数一共有7个根据需要选择<br><img src=\"https://upload-images.jianshu.io/upload_images/13449852-0a6c357a2b8c670d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></li>\n<li>CallbackListener<geodatabase>，完成GDB数据库下载的回调函数类，在该回调中我们只可以执行一些操作，如示例里在回调中删除了在线的服务图层，加载离线的数据图层到地图上进行显示。通过Geodatabase本地数据库可以获取要素图层列表<a href=\"http://blog.csdn.net/arcgis_all/article/details/20442663\" target=\"_blank\" rel=\"noopener\">List</a>&lt;<a href=\"http://blog.csdn.net/arcgis_all/article/details/20442663\" target=\"_blank\" rel=\"noopener\">GdbFeatureTable</a>&gt;对象，通过newFeatureLayer(gdbFeatureTable)来创建一个离线要素图层进行要素显示。</geodatabase></li>\n<li>GeodatabaseStatusCallback，本地数据库回调状态类，在数据下载过程中会有很多状态改变，各种状态改变时都会走这个类的回调函数。</li>\n<li>GeodatabaseTask.generateGeodatabase，通过该方法生成离线数据库和相应的要素表，方法需要传递上面介绍的三个参数和一个数据库存储的路径。<br>#4. 代码示例</li>\n</ul>\n<ol>\n<li><p>在地图上自定义一个区域</p>\n<pre><code>  /**\n  * 绘制出在线缓存区域\n  * */\n private void polygonState(Point currentPoint)throws Exception{\n     if(startPoint!=null&amp;&amp;!startPoint.isEmpty()){\n         polygon.lineTo(currentPoint);\n         currentGraphic = new Graphic(polygon, symbol);\n         drawLayer.updateGraphic(currentGraphicIndex,currentGraphic);\n\n         pointGraphic=new Graphic(multiPoint,pointSymbol);\n         drawLayer.updateGraphic(pointGraphicIndex,pointGraphic);\n         multiPoint.add(currentPoint);\n         if(lastGraphicIndex!=-1){\n             drawLayer.removeGraphic(lastGraphicIndex);\n         }\n         lastGraphic=new Graphic(currentPoint,lastSymbol);\n         lastGraphicIndex=drawLayer.addGraphic(lastGraphic);\n\n         if(polygon.getPointCount()&gt;=3){\n             isCheckedSave=true;\n             isSave=isCheckedSave;\n             onlinesave.setTextColor(ContextCompat.getColor(mActivity,R.color.blue));\n             onlinesave.setClickable(isSave);\n         }\n     }else{\n         polygon=new Polygon();\n         multiPoint=new MultiPoint();\n         polygon.startPath(currentPoint);\n         startPoint=currentPoint;\n         currentGraphic=new Graphic(startPoint,symbol);\n         currentGraphicIndex=drawLayer.addGraphic(currentGraphic);\n         pointGraphic=new Graphic(startPoint,lastSymbol);\n         pointGraphicIndex=drawLayer.addGraphic(pointGraphic);\n         multiPoint.add(currentPoint);\n     }\n }\n /**\n  * 确定所选区域范围\n  * */\n public void SaveLabel()throws Exception{\n     if(isSave&amp;&amp;drawLayer!=null) {\n         startPoint = null;\n         isCheckedSave=false;\n         isSave=isCheckedSave;\n         onlinesave.setTextColor(ContextCompat.getColor(mActivity,R.color.gray));\n         onlinesave.setClickable(isSave);\n         if(currentGraphicIndex!=-1){\n             Graphic graphic = drawLayer.getGraphic(currentGraphicIndex);\n             if(graphic!=null){\n                 Geometry geometry=graphic.getGeometry();\n                 Graphic saveGraphic=null;\n                 if(geometryType.equals(Geometry.Type.POLYGON)){\n                     symbol=MapViewTapTool.getLabelSymbol(mActivity,geometryType,ContextCompat.getColor(mActivity,R.color.green_transparent));\n                     saveGraphic=new Graphic(geometry,symbol);\n                     pointSymbol=MapViewTapTool.getCircleGreenSymbol(mActivity);\n                     pointGraphic=new Graphic(geometry,pointSymbol);\n                 }else{\n                     symbol=MapViewTapTool.getLabelSymbol(mActivity,geometryType,ContextCompat.getColor(mActivity,R.color.green));\n                     saveGraphic=new Graphic(geometry,symbol);\n                     pointSymbol=MapViewTapTool.getCircleGreenSymbol(mActivity);\n                     pointGraphic=new Graphic(geometry,pointSymbol);\n                 }\n                 if(onlineCacheInfoList!=null&amp;&amp;onlineCacheInfoList.size()&gt;0){\n                     setView();\n                     int i = 0;\n                     if(onlineCacheInfoList.get(i).getCacheurl().trim().length()&gt;0) {\n                         downloadData(onlineCacheInfoList.get(i), geometry, i);//缓存featureLayer\n                     }\n                 }\n             }\n         }\n     }else{\n         isCheckedSave=false;\n         isSave=isCheckedSave;\n         onlinesave.setTextColor(ContextCompat.getColor(mActivity,R.color.gray));\n         onlinesave.setClickable(isSave);\n     }\n }\n</code></pre></li>\n<li><p>下载选定区域所对应的在线缓存的文件</p>\n<pre><code>private void downloadData(final OnlineCacheInfo onlineCacheInfo, final Geometry geometry, final int i) {\n     gdbSyncTask = new GeodatabaseSyncTask(onlineCacheInfo.getCacheurl(), null);\n     gdbSyncTask.fetchFeatureServiceInfo(new CallbackListener&lt;FeatureServiceInfo&gt;() {\n                 @Override\n                 public void onError(Throwable arg0) {\n                     Log.e(TAG, &quot;Error fetching FeatureServiceInfo&quot;);\n                 }\n\n                 @Override\n                 public void onCallback(FeatureServiceInfo fsInfo) {\n                     if (fsInfo.isSyncEnabled()) {\n                        //回调获取所需要的下载的图层信息\n                         createGeodatabase(onlineCacheInfo.getIds(),geometry,i);\n                     }\n                 }\n             });\n\n }\n //创建下载\n private void createGeodatabase(int[] ids, final Geometry geometry, final int i) {\n     SpatialReference sp=mOneMapView.getSpatialReference();\n     GenerateGeodatabaseParameters params = new GenerateGeodatabaseParameters(ids, geometry,sp,true, SyncModel.GEODATABASE);\n\n     CallbackListener&lt;String&gt; gdbResponseCallback = new CallbackListener&lt;String&gt;() {\n         @Override\n         public void onError(final Throwable e) {\n             Log.e(TAG, &quot;Error creating geodatabase&quot;);\n             Toast.makeText(mActivity, &quot;数据下载失败!&quot;, Toast.LENGTH_LONG).show();\n             pDialog.dismiss();\n         }\n\n         @Override\n         public void onCallback(String path) {\n             updateFeatureLayer(path);\n             if(i&lt;onlineCacheInfoList.size()&amp;&amp;onlineCacheInfoList.get(i+1).getCacheurl().trim().length()&gt;0){\n                 downloadData(onlineCacheInfoList.get(i+1),geometry,i+1);\n             }else {\n                 pDialog.dismiss();\n                 Toast.makeText(mActivity, &quot;数据下载完成!&quot;, Toast.LENGTH_LONG).show();\n             }\n         }\n     };\n     localGdbFilePath = &quot;对应在本地存储的存储路径以及存储名称&quot;;\n     submitTask(params, localGdbFilePath, statusCallback,\n             gdbResponseCallback);\n }\n private void submitTask(GenerateGeodatabaseParameters params,\n                         String file, GeodatabaseStatusCallback statusCallback,\n                         CallbackListener&lt;String&gt; gdbResponseCallback) {\n     // submit task\n     gdbSyncTask.generateGeodatabase(params, file, false, statusCallback,\n             gdbResponseCallback);\n }\n</code></pre></li>\n<li><p>将下载完成的数据再地图上展示</p>\n</li>\n</ol>\n<pre><code>//加载数据\nprivate void updateFeatureLayer(String featureLayerPath) {\n        // create a new geodatabase\n        Geodatabase localGdb = null;\n        try {\n            localGdb = new Geodatabase(featureLayerPath);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n\n        if (localGdb != null) {\n            for (GeodatabaseFeatureTable gdbFeatureTable : localGdb\n                    .getGeodatabaseTables()) {\n                if (gdbFeatureTable.hasGeometry()){\n                    mOneMapView.addLayer(new FeatureLayer(gdbFeatureTable));\n                }\n            }\n        }\n    }\n</code></pre><p>#5. 结语<br>在线缓存的应用，减少了手动制作离线数据的步骤，大大提高了地图制作的效率，只需发布对应的地图服务就能实现离线数据的在线下载。另外也同时保证了数据的时效性，如果对应地图服务有新的数据更改，那我们可以重新下载新的在线数据，不需要再去手动打包地图文件。</p>\n<ul>\n<li>最后感谢您的阅读，有机会一起探讨！</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>#1. 简介</p>\n<ol>\n<li>离线在线一体化<br>数据存储在企业级地理数据库中，通过Arcgis桌面加载后配图处理，并发布到Arcgis for Server中，供移动端设备编辑使用，并可以同步回传版本化存档。</li>\n</ol>","more":"<ol start=\"2\">\n<li>应用场景<br>在没有网络的情况下我们需要用到在线的地图数据进行操作，这些数据需要有一定的时效性，如果采用，打包离线包的方式提前做好离线数据，那时效性相对较差。所以，用在线缓存技术可以支持这一点。<br>#2. 在线缓存的实现逻辑思路</li>\n</ol>\n<ul>\n<li>在地图上选定区域，作为需要下载对应离线数据的地图范围（可以设定范围，也可以自定义）</li>\n<li>获取下载滴地图服务所需要的具体参数</li>\n<li>在本地创建文件，存放下载的数据，以供使用<br>#3. 用到的核心功能类以及说明</li>\n<li>GeodatabaseSyncTask类，实现下载同步功能</li>\n<li>GenerateGeodatabaseParameters，下载数据时所需的参数对象，该类构造函数一共有7个根据需要选择<br><img src=\"https://upload-images.jianshu.io/upload_images/13449852-0a6c357a2b8c670d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></li>\n<li>CallbackListener<geodatabase>，完成GDB数据库下载的回调函数类，在该回调中我们只可以执行一些操作，如示例里在回调中删除了在线的服务图层，加载离线的数据图层到地图上进行显示。通过Geodatabase本地数据库可以获取要素图层列表<a href=\"http://blog.csdn.net/arcgis_all/article/details/20442663\" target=\"_blank\" rel=\"noopener\">List</a>&lt;<a href=\"http://blog.csdn.net/arcgis_all/article/details/20442663\" target=\"_blank\" rel=\"noopener\">GdbFeatureTable</a>&gt;对象，通过newFeatureLayer(gdbFeatureTable)来创建一个离线要素图层进行要素显示。</geodatabase></li>\n<li>GeodatabaseStatusCallback，本地数据库回调状态类，在数据下载过程中会有很多状态改变，各种状态改变时都会走这个类的回调函数。</li>\n<li>GeodatabaseTask.generateGeodatabase，通过该方法生成离线数据库和相应的要素表，方法需要传递上面介绍的三个参数和一个数据库存储的路径。<br>#4. 代码示例</li>\n</ul>\n<ol>\n<li><p>在地图上自定义一个区域</p>\n<pre><code>  /**\n  * 绘制出在线缓存区域\n  * */\n private void polygonState(Point currentPoint)throws Exception{\n     if(startPoint!=null&amp;&amp;!startPoint.isEmpty()){\n         polygon.lineTo(currentPoint);\n         currentGraphic = new Graphic(polygon, symbol);\n         drawLayer.updateGraphic(currentGraphicIndex,currentGraphic);\n\n         pointGraphic=new Graphic(multiPoint,pointSymbol);\n         drawLayer.updateGraphic(pointGraphicIndex,pointGraphic);\n         multiPoint.add(currentPoint);\n         if(lastGraphicIndex!=-1){\n             drawLayer.removeGraphic(lastGraphicIndex);\n         }\n         lastGraphic=new Graphic(currentPoint,lastSymbol);\n         lastGraphicIndex=drawLayer.addGraphic(lastGraphic);\n\n         if(polygon.getPointCount()&gt;=3){\n             isCheckedSave=true;\n             isSave=isCheckedSave;\n             onlinesave.setTextColor(ContextCompat.getColor(mActivity,R.color.blue));\n             onlinesave.setClickable(isSave);\n         }\n     }else{\n         polygon=new Polygon();\n         multiPoint=new MultiPoint();\n         polygon.startPath(currentPoint);\n         startPoint=currentPoint;\n         currentGraphic=new Graphic(startPoint,symbol);\n         currentGraphicIndex=drawLayer.addGraphic(currentGraphic);\n         pointGraphic=new Graphic(startPoint,lastSymbol);\n         pointGraphicIndex=drawLayer.addGraphic(pointGraphic);\n         multiPoint.add(currentPoint);\n     }\n }\n /**\n  * 确定所选区域范围\n  * */\n public void SaveLabel()throws Exception{\n     if(isSave&amp;&amp;drawLayer!=null) {\n         startPoint = null;\n         isCheckedSave=false;\n         isSave=isCheckedSave;\n         onlinesave.setTextColor(ContextCompat.getColor(mActivity,R.color.gray));\n         onlinesave.setClickable(isSave);\n         if(currentGraphicIndex!=-1){\n             Graphic graphic = drawLayer.getGraphic(currentGraphicIndex);\n             if(graphic!=null){\n                 Geometry geometry=graphic.getGeometry();\n                 Graphic saveGraphic=null;\n                 if(geometryType.equals(Geometry.Type.POLYGON)){\n                     symbol=MapViewTapTool.getLabelSymbol(mActivity,geometryType,ContextCompat.getColor(mActivity,R.color.green_transparent));\n                     saveGraphic=new Graphic(geometry,symbol);\n                     pointSymbol=MapViewTapTool.getCircleGreenSymbol(mActivity);\n                     pointGraphic=new Graphic(geometry,pointSymbol);\n                 }else{\n                     symbol=MapViewTapTool.getLabelSymbol(mActivity,geometryType,ContextCompat.getColor(mActivity,R.color.green));\n                     saveGraphic=new Graphic(geometry,symbol);\n                     pointSymbol=MapViewTapTool.getCircleGreenSymbol(mActivity);\n                     pointGraphic=new Graphic(geometry,pointSymbol);\n                 }\n                 if(onlineCacheInfoList!=null&amp;&amp;onlineCacheInfoList.size()&gt;0){\n                     setView();\n                     int i = 0;\n                     if(onlineCacheInfoList.get(i).getCacheurl().trim().length()&gt;0) {\n                         downloadData(onlineCacheInfoList.get(i), geometry, i);//缓存featureLayer\n                     }\n                 }\n             }\n         }\n     }else{\n         isCheckedSave=false;\n         isSave=isCheckedSave;\n         onlinesave.setTextColor(ContextCompat.getColor(mActivity,R.color.gray));\n         onlinesave.setClickable(isSave);\n     }\n }\n</code></pre></li>\n<li><p>下载选定区域所对应的在线缓存的文件</p>\n<pre><code>private void downloadData(final OnlineCacheInfo onlineCacheInfo, final Geometry geometry, final int i) {\n     gdbSyncTask = new GeodatabaseSyncTask(onlineCacheInfo.getCacheurl(), null);\n     gdbSyncTask.fetchFeatureServiceInfo(new CallbackListener&lt;FeatureServiceInfo&gt;() {\n                 @Override\n                 public void onError(Throwable arg0) {\n                     Log.e(TAG, &quot;Error fetching FeatureServiceInfo&quot;);\n                 }\n\n                 @Override\n                 public void onCallback(FeatureServiceInfo fsInfo) {\n                     if (fsInfo.isSyncEnabled()) {\n                        //回调获取所需要的下载的图层信息\n                         createGeodatabase(onlineCacheInfo.getIds(),geometry,i);\n                     }\n                 }\n             });\n\n }\n //创建下载\n private void createGeodatabase(int[] ids, final Geometry geometry, final int i) {\n     SpatialReference sp=mOneMapView.getSpatialReference();\n     GenerateGeodatabaseParameters params = new GenerateGeodatabaseParameters(ids, geometry,sp,true, SyncModel.GEODATABASE);\n\n     CallbackListener&lt;String&gt; gdbResponseCallback = new CallbackListener&lt;String&gt;() {\n         @Override\n         public void onError(final Throwable e) {\n             Log.e(TAG, &quot;Error creating geodatabase&quot;);\n             Toast.makeText(mActivity, &quot;数据下载失败!&quot;, Toast.LENGTH_LONG).show();\n             pDialog.dismiss();\n         }\n\n         @Override\n         public void onCallback(String path) {\n             updateFeatureLayer(path);\n             if(i&lt;onlineCacheInfoList.size()&amp;&amp;onlineCacheInfoList.get(i+1).getCacheurl().trim().length()&gt;0){\n                 downloadData(onlineCacheInfoList.get(i+1),geometry,i+1);\n             }else {\n                 pDialog.dismiss();\n                 Toast.makeText(mActivity, &quot;数据下载完成!&quot;, Toast.LENGTH_LONG).show();\n             }\n         }\n     };\n     localGdbFilePath = &quot;对应在本地存储的存储路径以及存储名称&quot;;\n     submitTask(params, localGdbFilePath, statusCallback,\n             gdbResponseCallback);\n }\n private void submitTask(GenerateGeodatabaseParameters params,\n                         String file, GeodatabaseStatusCallback statusCallback,\n                         CallbackListener&lt;String&gt; gdbResponseCallback) {\n     // submit task\n     gdbSyncTask.generateGeodatabase(params, file, false, statusCallback,\n             gdbResponseCallback);\n }\n</code></pre></li>\n<li><p>将下载完成的数据再地图上展示</p>\n</li>\n</ol>\n<pre><code>//加载数据\nprivate void updateFeatureLayer(String featureLayerPath) {\n        // create a new geodatabase\n        Geodatabase localGdb = null;\n        try {\n            localGdb = new Geodatabase(featureLayerPath);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n\n        if (localGdb != null) {\n            for (GeodatabaseFeatureTable gdbFeatureTable : localGdb\n                    .getGeodatabaseTables()) {\n                if (gdbFeatureTable.hasGeometry()){\n                    mOneMapView.addLayer(new FeatureLayer(gdbFeatureTable));\n                }\n            }\n        }\n    }\n</code></pre><p>#5. 结语<br>在线缓存的应用，减少了手动制作离线数据的步骤，大大提高了地图制作的效率，只需发布对应的地图服务就能实现离线数据的在线下载。另外也同时保证了数据的时效性，如果对应地图服务有新的数据更改，那我们可以重新下载新的在线数据，不需要再去手动打包地图文件。</p>\n<ul>\n<li>最后感谢您的阅读，有机会一起探讨！</li>\n</ul>"},{"title":"移动一张图专题分析","_content":"\n\n# 移动一张图专题分析\n\n-----\n##简介\n[专题模块为整个项目中的重要组成部分，也是不可或缺之一。用户可通过专题信息查看其主要层级结构和内部构造划分。对主要层级可进行收藏展示，便于直观查看。可手动点击某一层级结构打开对应图层，查看详细信息。]\n > 列表主要分为两种结构，一种为树状结构、一种为层级结构。以相同的数据模型展示不同的列表结构，便于用户选择。\n\n<!-- more -->\n\n##逻辑\n列表项包括三角号小图标、收藏按钮和点击开关的按钮。根据不同情境分别设置相应的展示状态。\n\n> * 当为树状结构时：首先初始化专题列表，通过Id展示最新列表。当点击Item项时，我们会记录专题的id,通过id找到子集列表数据，查看子集的type类型是否为“catalog”,如果是该类型，则会继续打开。直到我们点击Item项为“group”类型时，这时图层状态则不显示下一级别。 当我们点击开关状态时，获取子结点数据，将当前状态设置为打开，设置专题是否可见，根据id判断找到父级与子级，并更新整个专题的数据。当开关状态点击到“group”级别时，下一级别则是“layer”级别，图层状态则不显示下一级别。直接在图层上加载layer级别的数据。关闭时如果点击group级别的数据，则会直接关闭当前对应级别数据，父级状态为半开状态，如果关闭“catalog级则会将子级数据共同关闭，直到点击状态为“catalog”级别，对应“parentLayerId”=-1时，这时所有子级数据将全部关闭。\n> * 当为层级结构时：当我们点击开关状态时，记录当前id,并通过id找到对应子级的信息，清空当前数据，将最新数据更新到列表上。关闭时当\"parentLayerId!=-1\"时,列表下方有一个按钮提示返回上一级，当点击按钮时会找到上一级别数据，将当前级别数据清空，并将父级数据展示到列表上，更新适配器。\n\n### [Windows平台/AndroidStudio开发环境](https://www.cnblogs.com/vikezhu/p/4606230.html)\n##重要代码实现\n------\n#### 1. 通过ID获取列表，projectId刚开始传入-1.显示根目录列表：\n\n```Java\npublic void replaceAndShowListById(Context context, String projectId, boolean isOnlyShow) {\n        try {\n            List<ThemeInfo> themeInfoList=TopicLayerManager.getSubTopicList(context, projectId);\n        if (null != themeInfoList) {\n            if (null != showList) {\n                 showList.clear();\n                }\n            }\n            listViewSetAdapter(themeInfoList);\nif (!isOnlyShow && null != themeInfoList && themeInfoList.size() > 0) {\n                TotalApplication.getListIdInstance().clear();\n                TotalApplication.getListIdInstance().add(projectId);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\npublic synchronized void listViewSetAdapter(List<ThemeInfo> dmpList) {\n    if (null != dmpList && dmpList.size() > 0) {\n            if (null == projectAdapter) {\n                if (null != this.themeListView) {\n                    this.showList = dmpList;\n                 projectAdapter = new TopicAdapter(this.context, this.showList, handler, isGradedData);\n                    this.themeListView.setAdapter(projectAdapter);\n                }\n            } else {\n                this.showList = dmpList;\n                projectAdapter.setThemeInfoList(this.showList);\n            }\n        }\n    }\n\n\n```\n#### 2. 列表Item的点击事件：\n\n```Java\n    public synchronized void clickItemResponse(Context context, int position) throws Exception {\n        if (null != showList) {\n            ThemeInfo node = showList.get(position);\n            if (JudgeNullUtil.ObjIsNull(node)) {\n                return;\n            }\n            List<ThemeInfo> dmpList = new ArrayList<>();\n            String projectId = node.getId();\n            String type = node.getType();\n            if (projectId != null && projectId.length() > 0 && Constants.TYPE_CATLOG.equals(type)) {\n                dmpList = TopicLayerManager.getSubTopicList(context, projectId);\n            }\n\n            if (null != dmpList && dmpList.size() > 0) {\n                if (isGradedData) {\n                    if (projectId != null && projectId.length() > 0) {\n                        if (!node.isLeaf()) {\n                            node.setExpand(!node.isExpand());\n                            if (node.isExpand()) {\n                                for (ThemeInfo cNode : dmpList) {\n                                    cNode.setLevel(node.getLevel() + 1);\n                                }\n                                showList.addAll(position + 1, dmpList);\n                                listViewSetAdapter(showList);\n                            } else {\n                                List<ThemeInfo> rmList = new ArrayList<>();\n                                TopicUtil.getAllChildren(node, rmList, showList, false);\n                                showList.removeAll(rmList);\n                                listViewSetAdapter(showList);\n                            }\n                            TotalApplication.getListIdInstance().add(projectId);\n                        }\n                    }\n                } else {\n                    if (projectId != null && projectId.length() > 0) {\n                        showList = dmpList;\n                        listViewSetAdapter(showList);\n                        TotalApplication.getListIdInstance().add(projectId);\n                    }\n                }\n            }\n        }\n    }\n\n\n```\n#### 3. 开关按钮的点击事件：\n\n```Java\n public static void projectSwitch(Context context, Handler handler, List<ThemeInfo> themeInfoList, ThemeInfo info, TopicAdapter.ViewHolder finalHolder, boolean isGradedData) {\n        List<ThemeInfo> parents = new ArrayList<>();\n        TopicUtil.getAllParent(info, parents, themeInfoList, false);\n\n        List<ThemeInfo> childrens = new ArrayList<>();\n        TopicUtil.getAllChildren(info, childrens, themeInfoList, false);\n        String openStatus = info.getOpenStatus();\n        if (!openStatus.equals(Constants.TOPIC_STATUS_OFF)) {\n            finalHolder.isOpen.setImageResource(R.mipmap.topic_off);\n            info.setOpenStatus(Constants.TOPIC_STATUS_OFF);\n            TopicUtil.closeCurrentNode(info, themeInfoList, false);\n        } else {\n            finalHolder.isOpen.setImageResource(R.mipmap.topic_on);\n            info.setOpenStatus(Constants.TOPIC_STATUS_ON);\n            for (ThemeInfo node : childrens) {\n                node.setOpenStatus(Constants.TOPIC_STATUS_ON);\n            }\n            for (ThemeInfo node : parents) {\n                node.setOpenStatus(Constants.TOPIC_STATUS_ON);\n            }\n        }\n        if (JudgeNullUtil.ObjIsNull(info)) {\n            return;\n        }\n        TopicUtil.topicSwitchVisible(context, info, handler, isGradedData);\n    }\n\n``` \n\n#### 4.通过图层id显示专题图层：\n```Java\n /**\n     * 通过图层id显示专题图层。\n     *\n     * @param context      上下文\n     * @param visibleInfos 当前需要显示的图层\n     */\n    public static void setLayerVisible(Context context, List<ThemeInfo> visibleInfos, String currentStatus) throws Exception {\n        if (JudgeNullUtil.ObjIsNull(visibleInfos)) {\n            return;\n        }\n        boolean isOpenLayer = false;\n        if (!currentStatus.equals(Constants.TOPIC_STATUS_OFF)) {\n            isOpenLayer = true;\n        }\n        if(App.isOnLineData){\n            onlineVisibleLayer(context, visibleInfos, isOpenLayer);\n        }else{\n            offlineVisibleLayer(visibleInfos,isOpenLayer);\n        }\n    }\n\n``` \n\n#### 5.更新专题数据：\n```Java\n /**\n  * 更新专题某一层级数据或整个专题数据源\n  */\n    public static void updateThemeList(Context context, List<ThemeInfo> themeList) throws Exception {\n        App appCtx = (App) context.getApplicationContext();\n        appCtx.getDataSource().setTheme(themeList);\n    }\n /**\n     * 更新子级目录专题数据\n     */\n    public static List<ThemeInfo> updateSubData(ThemeInfo subThemeInfo, List<ThemeInfo> themeList) throws Exception {\n        if (subThemeInfo == null) {\n            return themeList;\n        }\n        String currentId = subThemeInfo.getId();\n        if (currentId == null || JudgeNullUtil.ObjIsNull(themeList)) {\n            return themeList;\n        }\n        List<String> subLayerIds = getSubLayerIds(currentId, themeList);\n        if (JudgeNullUtil.ObjIsNull(subLayerIds)) {\n            return themeList;\n        }\n        assert subLayerIds != null;\n        for (int i = 0; i < subLayerIds.size(); i++) {\n            String subId = subLayerIds.get(i);\n            subThemeInfo.setId(subId);\n            String type = getThemeType(subThemeInfo, themeList);\n            updateCurrentData(subThemeInfo, themeList);\n            if (type == null) {\n                continue;\n            }\n            if (type.equals(Constants.TYPE_CATLOG)) {\n                updateSubData(subThemeInfo, themeList);\n            }\n        }\n        return themeList;\n    }\n\n``` \n#### 6. 更新layer数据：\n```Java\n/**\n  * 设置layer显示状态\n  * @param layer专题图层\n  * @param visibleIds 图层id\n  */\npublic static void updateLayerVisible(Layer layer, int[] visibleIds, boolean isOpenLayer) throws Exception {\n        if (layer == null) {\n            return;\n        }\n        if (layer instanceof ArcGISDynamicMapServiceLayer) {\n            ArcGISDynamicMapServiceLayer dynamicLayer = (ArcGISDynamicMapServiceLayer) layer;\n            refreshDynamicLayer(visibleIds, dynamicLayer, isOpenLayer);\n        } else {\n            layer.setVisible(isOpenLayer);\n        }\n    }\n/**\n     * 根据visibleIds 更新DymicLayer\n     * @param visibleIds   layer Ids\n     * @param dynamicLayer 当前需要刷新的图层\n     */\n    private static void refreshDynamicLayer(int[] visibleIds, ArcGISDynamicMapServiceLayer dynamicLayer, boolean isOpenLayer) throws Exception {\n        if (dynamicLayer == null) {\n            return;\n        }\n        ArcGISLayerInfo[] arcGISLayerInfos = dynamicLayer.getAllLayers();\n        if (visibleIds.length > arcGISLayerInfos.length) {\n            return;\n        }\n        ArcGISLayerInfo layerInfo;\n        for (int index : visibleIds) {\n            if (index < 0) {\n                continue;\n            }\n            layerInfo = arcGISLayerInfos[index];\n            if (layerInfo == null) {\n                continue;\n            }\n            boolean isVisible = layerInfo.isVisible();\n            ArcGISLayerInfo layerParentInfo = layerInfo.getParentLayer();\n\n            if (layerParentInfo != null) {\n                boolean parentVisible = layerParentInfo.isVisible();\n                if (isOpenLayer) {\n                    if (!parentVisible) {\n                        layerParentInfo.setVisible(true);\n                    }\n                } else {\n                    if (parentVisible) {\n                        layerParentInfo.setVisible(false);\n                    }\n                }\n            }\n            if (isOpenLayer) {\n                if (!isVisible) {\n                    layerInfo.setVisible(true);\n                }\n            } else {\n                if (isVisible) {\n                    layerInfo.setVisible(false);\n                }\n            }\n        }\n        if (!dynamicLayer.isVisible()) {\n            dynamicLayer.setVisible(true);\n        }\n        dynamicLayer.refresh();\n    }\n\n``` \n---\n\n## 结语\n专题模块的开发提高了项目的灵活性和通透性，大大缩短了用户点击搜索的时间，保证了多层级结构加载时层与层之间的联系不冲突，确保它们之间稳定性。查询时可通过坐标点查询多个图层所对应信息，大大缩短了查询效率，确保项目的顺利进行。为后期新功能迭代打下坚实基础，提高用户体验。\n","source":"_posts/MOBILE/移动一张图专题分析.md","raw":"---\ntitle: 移动一张图专题分析\ntags: 移动\ncategories: mobile\n---\n\n\n# 移动一张图专题分析\n\n-----\n##简介\n[专题模块为整个项目中的重要组成部分，也是不可或缺之一。用户可通过专题信息查看其主要层级结构和内部构造划分。对主要层级可进行收藏展示，便于直观查看。可手动点击某一层级结构打开对应图层，查看详细信息。]\n > 列表主要分为两种结构，一种为树状结构、一种为层级结构。以相同的数据模型展示不同的列表结构，便于用户选择。\n\n<!-- more -->\n\n##逻辑\n列表项包括三角号小图标、收藏按钮和点击开关的按钮。根据不同情境分别设置相应的展示状态。\n\n> * 当为树状结构时：首先初始化专题列表，通过Id展示最新列表。当点击Item项时，我们会记录专题的id,通过id找到子集列表数据，查看子集的type类型是否为“catalog”,如果是该类型，则会继续打开。直到我们点击Item项为“group”类型时，这时图层状态则不显示下一级别。 当我们点击开关状态时，获取子结点数据，将当前状态设置为打开，设置专题是否可见，根据id判断找到父级与子级，并更新整个专题的数据。当开关状态点击到“group”级别时，下一级别则是“layer”级别，图层状态则不显示下一级别。直接在图层上加载layer级别的数据。关闭时如果点击group级别的数据，则会直接关闭当前对应级别数据，父级状态为半开状态，如果关闭“catalog级则会将子级数据共同关闭，直到点击状态为“catalog”级别，对应“parentLayerId”=-1时，这时所有子级数据将全部关闭。\n> * 当为层级结构时：当我们点击开关状态时，记录当前id,并通过id找到对应子级的信息，清空当前数据，将最新数据更新到列表上。关闭时当\"parentLayerId!=-1\"时,列表下方有一个按钮提示返回上一级，当点击按钮时会找到上一级别数据，将当前级别数据清空，并将父级数据展示到列表上，更新适配器。\n\n### [Windows平台/AndroidStudio开发环境](https://www.cnblogs.com/vikezhu/p/4606230.html)\n##重要代码实现\n------\n#### 1. 通过ID获取列表，projectId刚开始传入-1.显示根目录列表：\n\n```Java\npublic void replaceAndShowListById(Context context, String projectId, boolean isOnlyShow) {\n        try {\n            List<ThemeInfo> themeInfoList=TopicLayerManager.getSubTopicList(context, projectId);\n        if (null != themeInfoList) {\n            if (null != showList) {\n                 showList.clear();\n                }\n            }\n            listViewSetAdapter(themeInfoList);\nif (!isOnlyShow && null != themeInfoList && themeInfoList.size() > 0) {\n                TotalApplication.getListIdInstance().clear();\n                TotalApplication.getListIdInstance().add(projectId);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\npublic synchronized void listViewSetAdapter(List<ThemeInfo> dmpList) {\n    if (null != dmpList && dmpList.size() > 0) {\n            if (null == projectAdapter) {\n                if (null != this.themeListView) {\n                    this.showList = dmpList;\n                 projectAdapter = new TopicAdapter(this.context, this.showList, handler, isGradedData);\n                    this.themeListView.setAdapter(projectAdapter);\n                }\n            } else {\n                this.showList = dmpList;\n                projectAdapter.setThemeInfoList(this.showList);\n            }\n        }\n    }\n\n\n```\n#### 2. 列表Item的点击事件：\n\n```Java\n    public synchronized void clickItemResponse(Context context, int position) throws Exception {\n        if (null != showList) {\n            ThemeInfo node = showList.get(position);\n            if (JudgeNullUtil.ObjIsNull(node)) {\n                return;\n            }\n            List<ThemeInfo> dmpList = new ArrayList<>();\n            String projectId = node.getId();\n            String type = node.getType();\n            if (projectId != null && projectId.length() > 0 && Constants.TYPE_CATLOG.equals(type)) {\n                dmpList = TopicLayerManager.getSubTopicList(context, projectId);\n            }\n\n            if (null != dmpList && dmpList.size() > 0) {\n                if (isGradedData) {\n                    if (projectId != null && projectId.length() > 0) {\n                        if (!node.isLeaf()) {\n                            node.setExpand(!node.isExpand());\n                            if (node.isExpand()) {\n                                for (ThemeInfo cNode : dmpList) {\n                                    cNode.setLevel(node.getLevel() + 1);\n                                }\n                                showList.addAll(position + 1, dmpList);\n                                listViewSetAdapter(showList);\n                            } else {\n                                List<ThemeInfo> rmList = new ArrayList<>();\n                                TopicUtil.getAllChildren(node, rmList, showList, false);\n                                showList.removeAll(rmList);\n                                listViewSetAdapter(showList);\n                            }\n                            TotalApplication.getListIdInstance().add(projectId);\n                        }\n                    }\n                } else {\n                    if (projectId != null && projectId.length() > 0) {\n                        showList = dmpList;\n                        listViewSetAdapter(showList);\n                        TotalApplication.getListIdInstance().add(projectId);\n                    }\n                }\n            }\n        }\n    }\n\n\n```\n#### 3. 开关按钮的点击事件：\n\n```Java\n public static void projectSwitch(Context context, Handler handler, List<ThemeInfo> themeInfoList, ThemeInfo info, TopicAdapter.ViewHolder finalHolder, boolean isGradedData) {\n        List<ThemeInfo> parents = new ArrayList<>();\n        TopicUtil.getAllParent(info, parents, themeInfoList, false);\n\n        List<ThemeInfo> childrens = new ArrayList<>();\n        TopicUtil.getAllChildren(info, childrens, themeInfoList, false);\n        String openStatus = info.getOpenStatus();\n        if (!openStatus.equals(Constants.TOPIC_STATUS_OFF)) {\n            finalHolder.isOpen.setImageResource(R.mipmap.topic_off);\n            info.setOpenStatus(Constants.TOPIC_STATUS_OFF);\n            TopicUtil.closeCurrentNode(info, themeInfoList, false);\n        } else {\n            finalHolder.isOpen.setImageResource(R.mipmap.topic_on);\n            info.setOpenStatus(Constants.TOPIC_STATUS_ON);\n            for (ThemeInfo node : childrens) {\n                node.setOpenStatus(Constants.TOPIC_STATUS_ON);\n            }\n            for (ThemeInfo node : parents) {\n                node.setOpenStatus(Constants.TOPIC_STATUS_ON);\n            }\n        }\n        if (JudgeNullUtil.ObjIsNull(info)) {\n            return;\n        }\n        TopicUtil.topicSwitchVisible(context, info, handler, isGradedData);\n    }\n\n``` \n\n#### 4.通过图层id显示专题图层：\n```Java\n /**\n     * 通过图层id显示专题图层。\n     *\n     * @param context      上下文\n     * @param visibleInfos 当前需要显示的图层\n     */\n    public static void setLayerVisible(Context context, List<ThemeInfo> visibleInfos, String currentStatus) throws Exception {\n        if (JudgeNullUtil.ObjIsNull(visibleInfos)) {\n            return;\n        }\n        boolean isOpenLayer = false;\n        if (!currentStatus.equals(Constants.TOPIC_STATUS_OFF)) {\n            isOpenLayer = true;\n        }\n        if(App.isOnLineData){\n            onlineVisibleLayer(context, visibleInfos, isOpenLayer);\n        }else{\n            offlineVisibleLayer(visibleInfos,isOpenLayer);\n        }\n    }\n\n``` \n\n#### 5.更新专题数据：\n```Java\n /**\n  * 更新专题某一层级数据或整个专题数据源\n  */\n    public static void updateThemeList(Context context, List<ThemeInfo> themeList) throws Exception {\n        App appCtx = (App) context.getApplicationContext();\n        appCtx.getDataSource().setTheme(themeList);\n    }\n /**\n     * 更新子级目录专题数据\n     */\n    public static List<ThemeInfo> updateSubData(ThemeInfo subThemeInfo, List<ThemeInfo> themeList) throws Exception {\n        if (subThemeInfo == null) {\n            return themeList;\n        }\n        String currentId = subThemeInfo.getId();\n        if (currentId == null || JudgeNullUtil.ObjIsNull(themeList)) {\n            return themeList;\n        }\n        List<String> subLayerIds = getSubLayerIds(currentId, themeList);\n        if (JudgeNullUtil.ObjIsNull(subLayerIds)) {\n            return themeList;\n        }\n        assert subLayerIds != null;\n        for (int i = 0; i < subLayerIds.size(); i++) {\n            String subId = subLayerIds.get(i);\n            subThemeInfo.setId(subId);\n            String type = getThemeType(subThemeInfo, themeList);\n            updateCurrentData(subThemeInfo, themeList);\n            if (type == null) {\n                continue;\n            }\n            if (type.equals(Constants.TYPE_CATLOG)) {\n                updateSubData(subThemeInfo, themeList);\n            }\n        }\n        return themeList;\n    }\n\n``` \n#### 6. 更新layer数据：\n```Java\n/**\n  * 设置layer显示状态\n  * @param layer专题图层\n  * @param visibleIds 图层id\n  */\npublic static void updateLayerVisible(Layer layer, int[] visibleIds, boolean isOpenLayer) throws Exception {\n        if (layer == null) {\n            return;\n        }\n        if (layer instanceof ArcGISDynamicMapServiceLayer) {\n            ArcGISDynamicMapServiceLayer dynamicLayer = (ArcGISDynamicMapServiceLayer) layer;\n            refreshDynamicLayer(visibleIds, dynamicLayer, isOpenLayer);\n        } else {\n            layer.setVisible(isOpenLayer);\n        }\n    }\n/**\n     * 根据visibleIds 更新DymicLayer\n     * @param visibleIds   layer Ids\n     * @param dynamicLayer 当前需要刷新的图层\n     */\n    private static void refreshDynamicLayer(int[] visibleIds, ArcGISDynamicMapServiceLayer dynamicLayer, boolean isOpenLayer) throws Exception {\n        if (dynamicLayer == null) {\n            return;\n        }\n        ArcGISLayerInfo[] arcGISLayerInfos = dynamicLayer.getAllLayers();\n        if (visibleIds.length > arcGISLayerInfos.length) {\n            return;\n        }\n        ArcGISLayerInfo layerInfo;\n        for (int index : visibleIds) {\n            if (index < 0) {\n                continue;\n            }\n            layerInfo = arcGISLayerInfos[index];\n            if (layerInfo == null) {\n                continue;\n            }\n            boolean isVisible = layerInfo.isVisible();\n            ArcGISLayerInfo layerParentInfo = layerInfo.getParentLayer();\n\n            if (layerParentInfo != null) {\n                boolean parentVisible = layerParentInfo.isVisible();\n                if (isOpenLayer) {\n                    if (!parentVisible) {\n                        layerParentInfo.setVisible(true);\n                    }\n                } else {\n                    if (parentVisible) {\n                        layerParentInfo.setVisible(false);\n                    }\n                }\n            }\n            if (isOpenLayer) {\n                if (!isVisible) {\n                    layerInfo.setVisible(true);\n                }\n            } else {\n                if (isVisible) {\n                    layerInfo.setVisible(false);\n                }\n            }\n        }\n        if (!dynamicLayer.isVisible()) {\n            dynamicLayer.setVisible(true);\n        }\n        dynamicLayer.refresh();\n    }\n\n``` \n---\n\n## 结语\n专题模块的开发提高了项目的灵活性和通透性，大大缩短了用户点击搜索的时间，保证了多层级结构加载时层与层之间的联系不冲突，确保它们之间稳定性。查询时可通过坐标点查询多个图层所对应信息，大大缩短了查询效率，确保项目的顺利进行。为后期新功能迭代打下坚实基础，提高用户体验。\n","slug":"MOBILE/移动一张图专题分析","published":1,"date":"2018-08-31T09:53:09.810Z","updated":"2018-08-31T09:55:30.177Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlhtwxeh000kxcl5imw4csg6","content":"<h1 id=\"移动一张图专题分析\"><a href=\"#移动一张图专题分析\" class=\"headerlink\" title=\"移动一张图专题分析\"></a>移动一张图专题分析</h1><hr>\n<p>##简介<br>[专题模块为整个项目中的重要组成部分，也是不可或缺之一。用户可通过专题信息查看其主要层级结构和内部构造划分。对主要层级可进行收藏展示，便于直观查看。可手动点击某一层级结构打开对应图层，查看详细信息。]</p>\n<blockquote>\n<p>列表主要分为两种结构，一种为树状结构、一种为层级结构。以相同的数据模型展示不同的列表结构，便于用户选择。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>##逻辑<br>列表项包括三角号小图标、收藏按钮和点击开关的按钮。根据不同情境分别设置相应的展示状态。</p>\n<blockquote>\n<ul>\n<li>当为树状结构时：首先初始化专题列表，通过Id展示最新列表。当点击Item项时，我们会记录专题的id,通过id找到子集列表数据，查看子集的type类型是否为“catalog”,如果是该类型，则会继续打开。直到我们点击Item项为“group”类型时，这时图层状态则不显示下一级别。 当我们点击开关状态时，获取子结点数据，将当前状态设置为打开，设置专题是否可见，根据id判断找到父级与子级，并更新整个专题的数据。当开关状态点击到“group”级别时，下一级别则是“layer”级别，图层状态则不显示下一级别。直接在图层上加载layer级别的数据。关闭时如果点击group级别的数据，则会直接关闭当前对应级别数据，父级状态为半开状态，如果关闭“catalog级则会将子级数据共同关闭，直到点击状态为“catalog”级别，对应“parentLayerId”=-1时，这时所有子级数据将全部关闭。</li>\n<li>当为层级结构时：当我们点击开关状态时，记录当前id,并通过id找到对应子级的信息，清空当前数据，将最新数据更新到列表上。关闭时当”parentLayerId!=-1”时,列表下方有一个按钮提示返回上一级，当点击按钮时会找到上一级别数据，将当前级别数据清空，并将父级数据展示到列表上，更新适配器。</li>\n</ul>\n</blockquote>\n<h3 id=\"Windows平台-AndroidStudio开发环境\"><a href=\"#Windows平台-AndroidStudio开发环境\" class=\"headerlink\" title=\"Windows平台/AndroidStudio开发环境\"></a><a href=\"https://www.cnblogs.com/vikezhu/p/4606230.html\" target=\"_blank\" rel=\"noopener\">Windows平台/AndroidStudio开发环境</a></h3><h2 id=\"重要代码实现\"><a href=\"#重要代码实现\" class=\"headerlink\" title=\"##重要代码实现\"></a>##重要代码实现</h2><h4 id=\"1-通过ID获取列表，projectId刚开始传入-1-显示根目录列表：\"><a href=\"#1-通过ID获取列表，projectId刚开始传入-1-显示根目录列表：\" class=\"headerlink\" title=\"1. 通过ID获取列表，projectId刚开始传入-1.显示根目录列表：\"></a>1. 通过ID获取列表，projectId刚开始传入-1.显示根目录列表：</h4><pre><code class=\"Java\">public void replaceAndShowListById(Context context, String projectId, boolean isOnlyShow) {\n        try {\n            List&lt;ThemeInfo&gt; themeInfoList=TopicLayerManager.getSubTopicList(context, projectId);\n        if (null != themeInfoList) {\n            if (null != showList) {\n                 showList.clear();\n                }\n            }\n            listViewSetAdapter(themeInfoList);\nif (!isOnlyShow &amp;&amp; null != themeInfoList &amp;&amp; themeInfoList.size() &gt; 0) {\n                TotalApplication.getListIdInstance().clear();\n                TotalApplication.getListIdInstance().add(projectId);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\npublic synchronized void listViewSetAdapter(List&lt;ThemeInfo&gt; dmpList) {\n    if (null != dmpList &amp;&amp; dmpList.size() &gt; 0) {\n            if (null == projectAdapter) {\n                if (null != this.themeListView) {\n                    this.showList = dmpList;\n                 projectAdapter = new TopicAdapter(this.context, this.showList, handler, isGradedData);\n                    this.themeListView.setAdapter(projectAdapter);\n                }\n            } else {\n                this.showList = dmpList;\n                projectAdapter.setThemeInfoList(this.showList);\n            }\n        }\n    }\n\n\n</code></pre>\n<h4 id=\"2-列表Item的点击事件：\"><a href=\"#2-列表Item的点击事件：\" class=\"headerlink\" title=\"2. 列表Item的点击事件：\"></a>2. 列表Item的点击事件：</h4><pre><code class=\"Java\">    public synchronized void clickItemResponse(Context context, int position) throws Exception {\n        if (null != showList) {\n            ThemeInfo node = showList.get(position);\n            if (JudgeNullUtil.ObjIsNull(node)) {\n                return;\n            }\n            List&lt;ThemeInfo&gt; dmpList = new ArrayList&lt;&gt;();\n            String projectId = node.getId();\n            String type = node.getType();\n            if (projectId != null &amp;&amp; projectId.length() &gt; 0 &amp;&amp; Constants.TYPE_CATLOG.equals(type)) {\n                dmpList = TopicLayerManager.getSubTopicList(context, projectId);\n            }\n\n            if (null != dmpList &amp;&amp; dmpList.size() &gt; 0) {\n                if (isGradedData) {\n                    if (projectId != null &amp;&amp; projectId.length() &gt; 0) {\n                        if (!node.isLeaf()) {\n                            node.setExpand(!node.isExpand());\n                            if (node.isExpand()) {\n                                for (ThemeInfo cNode : dmpList) {\n                                    cNode.setLevel(node.getLevel() + 1);\n                                }\n                                showList.addAll(position + 1, dmpList);\n                                listViewSetAdapter(showList);\n                            } else {\n                                List&lt;ThemeInfo&gt; rmList = new ArrayList&lt;&gt;();\n                                TopicUtil.getAllChildren(node, rmList, showList, false);\n                                showList.removeAll(rmList);\n                                listViewSetAdapter(showList);\n                            }\n                            TotalApplication.getListIdInstance().add(projectId);\n                        }\n                    }\n                } else {\n                    if (projectId != null &amp;&amp; projectId.length() &gt; 0) {\n                        showList = dmpList;\n                        listViewSetAdapter(showList);\n                        TotalApplication.getListIdInstance().add(projectId);\n                    }\n                }\n            }\n        }\n    }\n\n\n</code></pre>\n<h4 id=\"3-开关按钮的点击事件：\"><a href=\"#3-开关按钮的点击事件：\" class=\"headerlink\" title=\"3. 开关按钮的点击事件：\"></a>3. 开关按钮的点击事件：</h4><pre><code class=\"Java\"> public static void projectSwitch(Context context, Handler handler, List&lt;ThemeInfo&gt; themeInfoList, ThemeInfo info, TopicAdapter.ViewHolder finalHolder, boolean isGradedData) {\n        List&lt;ThemeInfo&gt; parents = new ArrayList&lt;&gt;();\n        TopicUtil.getAllParent(info, parents, themeInfoList, false);\n\n        List&lt;ThemeInfo&gt; childrens = new ArrayList&lt;&gt;();\n        TopicUtil.getAllChildren(info, childrens, themeInfoList, false);\n        String openStatus = info.getOpenStatus();\n        if (!openStatus.equals(Constants.TOPIC_STATUS_OFF)) {\n            finalHolder.isOpen.setImageResource(R.mipmap.topic_off);\n            info.setOpenStatus(Constants.TOPIC_STATUS_OFF);\n            TopicUtil.closeCurrentNode(info, themeInfoList, false);\n        } else {\n            finalHolder.isOpen.setImageResource(R.mipmap.topic_on);\n            info.setOpenStatus(Constants.TOPIC_STATUS_ON);\n            for (ThemeInfo node : childrens) {\n                node.setOpenStatus(Constants.TOPIC_STATUS_ON);\n            }\n            for (ThemeInfo node : parents) {\n                node.setOpenStatus(Constants.TOPIC_STATUS_ON);\n            }\n        }\n        if (JudgeNullUtil.ObjIsNull(info)) {\n            return;\n        }\n        TopicUtil.topicSwitchVisible(context, info, handler, isGradedData);\n    }\n\n</code></pre>\n<h4 id=\"4-通过图层id显示专题图层：\"><a href=\"#4-通过图层id显示专题图层：\" class=\"headerlink\" title=\"4.通过图层id显示专题图层：\"></a>4.通过图层id显示专题图层：</h4><pre><code class=\"Java\"> /**\n     * 通过图层id显示专题图层。\n     *\n     * @param context      上下文\n     * @param visibleInfos 当前需要显示的图层\n     */\n    public static void setLayerVisible(Context context, List&lt;ThemeInfo&gt; visibleInfos, String currentStatus) throws Exception {\n        if (JudgeNullUtil.ObjIsNull(visibleInfos)) {\n            return;\n        }\n        boolean isOpenLayer = false;\n        if (!currentStatus.equals(Constants.TOPIC_STATUS_OFF)) {\n            isOpenLayer = true;\n        }\n        if(App.isOnLineData){\n            onlineVisibleLayer(context, visibleInfos, isOpenLayer);\n        }else{\n            offlineVisibleLayer(visibleInfos,isOpenLayer);\n        }\n    }\n\n</code></pre>\n<h4 id=\"5-更新专题数据：\"><a href=\"#5-更新专题数据：\" class=\"headerlink\" title=\"5.更新专题数据：\"></a>5.更新专题数据：</h4><pre><code class=\"Java\"> /**\n  * 更新专题某一层级数据或整个专题数据源\n  */\n    public static void updateThemeList(Context context, List&lt;ThemeInfo&gt; themeList) throws Exception {\n        App appCtx = (App) context.getApplicationContext();\n        appCtx.getDataSource().setTheme(themeList);\n    }\n /**\n     * 更新子级目录专题数据\n     */\n    public static List&lt;ThemeInfo&gt; updateSubData(ThemeInfo subThemeInfo, List&lt;ThemeInfo&gt; themeList) throws Exception {\n        if (subThemeInfo == null) {\n            return themeList;\n        }\n        String currentId = subThemeInfo.getId();\n        if (currentId == null || JudgeNullUtil.ObjIsNull(themeList)) {\n            return themeList;\n        }\n        List&lt;String&gt; subLayerIds = getSubLayerIds(currentId, themeList);\n        if (JudgeNullUtil.ObjIsNull(subLayerIds)) {\n            return themeList;\n        }\n        assert subLayerIds != null;\n        for (int i = 0; i &lt; subLayerIds.size(); i++) {\n            String subId = subLayerIds.get(i);\n            subThemeInfo.setId(subId);\n            String type = getThemeType(subThemeInfo, themeList);\n            updateCurrentData(subThemeInfo, themeList);\n            if (type == null) {\n                continue;\n            }\n            if (type.equals(Constants.TYPE_CATLOG)) {\n                updateSubData(subThemeInfo, themeList);\n            }\n        }\n        return themeList;\n    }\n\n</code></pre>\n<h4 id=\"6-更新layer数据：\"><a href=\"#6-更新layer数据：\" class=\"headerlink\" title=\"6. 更新layer数据：\"></a>6. 更新layer数据：</h4><pre><code class=\"Java\">/**\n  * 设置layer显示状态\n  * @param layer专题图层\n  * @param visibleIds 图层id\n  */\npublic static void updateLayerVisible(Layer layer, int[] visibleIds, boolean isOpenLayer) throws Exception {\n        if (layer == null) {\n            return;\n        }\n        if (layer instanceof ArcGISDynamicMapServiceLayer) {\n            ArcGISDynamicMapServiceLayer dynamicLayer = (ArcGISDynamicMapServiceLayer) layer;\n            refreshDynamicLayer(visibleIds, dynamicLayer, isOpenLayer);\n        } else {\n            layer.setVisible(isOpenLayer);\n        }\n    }\n/**\n     * 根据visibleIds 更新DymicLayer\n     * @param visibleIds   layer Ids\n     * @param dynamicLayer 当前需要刷新的图层\n     */\n    private static void refreshDynamicLayer(int[] visibleIds, ArcGISDynamicMapServiceLayer dynamicLayer, boolean isOpenLayer) throws Exception {\n        if (dynamicLayer == null) {\n            return;\n        }\n        ArcGISLayerInfo[] arcGISLayerInfos = dynamicLayer.getAllLayers();\n        if (visibleIds.length &gt; arcGISLayerInfos.length) {\n            return;\n        }\n        ArcGISLayerInfo layerInfo;\n        for (int index : visibleIds) {\n            if (index &lt; 0) {\n                continue;\n            }\n            layerInfo = arcGISLayerInfos[index];\n            if (layerInfo == null) {\n                continue;\n            }\n            boolean isVisible = layerInfo.isVisible();\n            ArcGISLayerInfo layerParentInfo = layerInfo.getParentLayer();\n\n            if (layerParentInfo != null) {\n                boolean parentVisible = layerParentInfo.isVisible();\n                if (isOpenLayer) {\n                    if (!parentVisible) {\n                        layerParentInfo.setVisible(true);\n                    }\n                } else {\n                    if (parentVisible) {\n                        layerParentInfo.setVisible(false);\n                    }\n                }\n            }\n            if (isOpenLayer) {\n                if (!isVisible) {\n                    layerInfo.setVisible(true);\n                }\n            } else {\n                if (isVisible) {\n                    layerInfo.setVisible(false);\n                }\n            }\n        }\n        if (!dynamicLayer.isVisible()) {\n            dynamicLayer.setVisible(true);\n        }\n        dynamicLayer.refresh();\n    }\n\n</code></pre>\n<hr>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>专题模块的开发提高了项目的灵活性和通透性，大大缩短了用户点击搜索的时间，保证了多层级结构加载时层与层之间的联系不冲突，确保它们之间稳定性。查询时可通过坐标点查询多个图层所对应信息，大大缩短了查询效率，确保项目的顺利进行。为后期新功能迭代打下坚实基础，提高用户体验。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"移动一张图专题分析\"><a href=\"#移动一张图专题分析\" class=\"headerlink\" title=\"移动一张图专题分析\"></a>移动一张图专题分析</h1><hr>\n<p>##简介<br>[专题模块为整个项目中的重要组成部分，也是不可或缺之一。用户可通过专题信息查看其主要层级结构和内部构造划分。对主要层级可进行收藏展示，便于直观查看。可手动点击某一层级结构打开对应图层，查看详细信息。]</p>\n<blockquote>\n<p>列表主要分为两种结构，一种为树状结构、一种为层级结构。以相同的数据模型展示不同的列表结构，便于用户选择。</p>\n</blockquote>","more":"<p>##逻辑<br>列表项包括三角号小图标、收藏按钮和点击开关的按钮。根据不同情境分别设置相应的展示状态。</p>\n<blockquote>\n<ul>\n<li>当为树状结构时：首先初始化专题列表，通过Id展示最新列表。当点击Item项时，我们会记录专题的id,通过id找到子集列表数据，查看子集的type类型是否为“catalog”,如果是该类型，则会继续打开。直到我们点击Item项为“group”类型时，这时图层状态则不显示下一级别。 当我们点击开关状态时，获取子结点数据，将当前状态设置为打开，设置专题是否可见，根据id判断找到父级与子级，并更新整个专题的数据。当开关状态点击到“group”级别时，下一级别则是“layer”级别，图层状态则不显示下一级别。直接在图层上加载layer级别的数据。关闭时如果点击group级别的数据，则会直接关闭当前对应级别数据，父级状态为半开状态，如果关闭“catalog级则会将子级数据共同关闭，直到点击状态为“catalog”级别，对应“parentLayerId”=-1时，这时所有子级数据将全部关闭。</li>\n<li>当为层级结构时：当我们点击开关状态时，记录当前id,并通过id找到对应子级的信息，清空当前数据，将最新数据更新到列表上。关闭时当”parentLayerId!=-1”时,列表下方有一个按钮提示返回上一级，当点击按钮时会找到上一级别数据，将当前级别数据清空，并将父级数据展示到列表上，更新适配器。</li>\n</ul>\n</blockquote>\n<h3 id=\"Windows平台-AndroidStudio开发环境\"><a href=\"#Windows平台-AndroidStudio开发环境\" class=\"headerlink\" title=\"Windows平台/AndroidStudio开发环境\"></a><a href=\"https://www.cnblogs.com/vikezhu/p/4606230.html\" target=\"_blank\" rel=\"noopener\">Windows平台/AndroidStudio开发环境</a></h3><h2 id=\"重要代码实现\"><a href=\"#重要代码实现\" class=\"headerlink\" title=\"##重要代码实现\"></a>##重要代码实现</h2><h4 id=\"1-通过ID获取列表，projectId刚开始传入-1-显示根目录列表：\"><a href=\"#1-通过ID获取列表，projectId刚开始传入-1-显示根目录列表：\" class=\"headerlink\" title=\"1. 通过ID获取列表，projectId刚开始传入-1.显示根目录列表：\"></a>1. 通过ID获取列表，projectId刚开始传入-1.显示根目录列表：</h4><pre><code class=\"Java\">public void replaceAndShowListById(Context context, String projectId, boolean isOnlyShow) {\n        try {\n            List&lt;ThemeInfo&gt; themeInfoList=TopicLayerManager.getSubTopicList(context, projectId);\n        if (null != themeInfoList) {\n            if (null != showList) {\n                 showList.clear();\n                }\n            }\n            listViewSetAdapter(themeInfoList);\nif (!isOnlyShow &amp;&amp; null != themeInfoList &amp;&amp; themeInfoList.size() &gt; 0) {\n                TotalApplication.getListIdInstance().clear();\n                TotalApplication.getListIdInstance().add(projectId);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\npublic synchronized void listViewSetAdapter(List&lt;ThemeInfo&gt; dmpList) {\n    if (null != dmpList &amp;&amp; dmpList.size() &gt; 0) {\n            if (null == projectAdapter) {\n                if (null != this.themeListView) {\n                    this.showList = dmpList;\n                 projectAdapter = new TopicAdapter(this.context, this.showList, handler, isGradedData);\n                    this.themeListView.setAdapter(projectAdapter);\n                }\n            } else {\n                this.showList = dmpList;\n                projectAdapter.setThemeInfoList(this.showList);\n            }\n        }\n    }\n\n\n</code></pre>\n<h4 id=\"2-列表Item的点击事件：\"><a href=\"#2-列表Item的点击事件：\" class=\"headerlink\" title=\"2. 列表Item的点击事件：\"></a>2. 列表Item的点击事件：</h4><pre><code class=\"Java\">    public synchronized void clickItemResponse(Context context, int position) throws Exception {\n        if (null != showList) {\n            ThemeInfo node = showList.get(position);\n            if (JudgeNullUtil.ObjIsNull(node)) {\n                return;\n            }\n            List&lt;ThemeInfo&gt; dmpList = new ArrayList&lt;&gt;();\n            String projectId = node.getId();\n            String type = node.getType();\n            if (projectId != null &amp;&amp; projectId.length() &gt; 0 &amp;&amp; Constants.TYPE_CATLOG.equals(type)) {\n                dmpList = TopicLayerManager.getSubTopicList(context, projectId);\n            }\n\n            if (null != dmpList &amp;&amp; dmpList.size() &gt; 0) {\n                if (isGradedData) {\n                    if (projectId != null &amp;&amp; projectId.length() &gt; 0) {\n                        if (!node.isLeaf()) {\n                            node.setExpand(!node.isExpand());\n                            if (node.isExpand()) {\n                                for (ThemeInfo cNode : dmpList) {\n                                    cNode.setLevel(node.getLevel() + 1);\n                                }\n                                showList.addAll(position + 1, dmpList);\n                                listViewSetAdapter(showList);\n                            } else {\n                                List&lt;ThemeInfo&gt; rmList = new ArrayList&lt;&gt;();\n                                TopicUtil.getAllChildren(node, rmList, showList, false);\n                                showList.removeAll(rmList);\n                                listViewSetAdapter(showList);\n                            }\n                            TotalApplication.getListIdInstance().add(projectId);\n                        }\n                    }\n                } else {\n                    if (projectId != null &amp;&amp; projectId.length() &gt; 0) {\n                        showList = dmpList;\n                        listViewSetAdapter(showList);\n                        TotalApplication.getListIdInstance().add(projectId);\n                    }\n                }\n            }\n        }\n    }\n\n\n</code></pre>\n<h4 id=\"3-开关按钮的点击事件：\"><a href=\"#3-开关按钮的点击事件：\" class=\"headerlink\" title=\"3. 开关按钮的点击事件：\"></a>3. 开关按钮的点击事件：</h4><pre><code class=\"Java\"> public static void projectSwitch(Context context, Handler handler, List&lt;ThemeInfo&gt; themeInfoList, ThemeInfo info, TopicAdapter.ViewHolder finalHolder, boolean isGradedData) {\n        List&lt;ThemeInfo&gt; parents = new ArrayList&lt;&gt;();\n        TopicUtil.getAllParent(info, parents, themeInfoList, false);\n\n        List&lt;ThemeInfo&gt; childrens = new ArrayList&lt;&gt;();\n        TopicUtil.getAllChildren(info, childrens, themeInfoList, false);\n        String openStatus = info.getOpenStatus();\n        if (!openStatus.equals(Constants.TOPIC_STATUS_OFF)) {\n            finalHolder.isOpen.setImageResource(R.mipmap.topic_off);\n            info.setOpenStatus(Constants.TOPIC_STATUS_OFF);\n            TopicUtil.closeCurrentNode(info, themeInfoList, false);\n        } else {\n            finalHolder.isOpen.setImageResource(R.mipmap.topic_on);\n            info.setOpenStatus(Constants.TOPIC_STATUS_ON);\n            for (ThemeInfo node : childrens) {\n                node.setOpenStatus(Constants.TOPIC_STATUS_ON);\n            }\n            for (ThemeInfo node : parents) {\n                node.setOpenStatus(Constants.TOPIC_STATUS_ON);\n            }\n        }\n        if (JudgeNullUtil.ObjIsNull(info)) {\n            return;\n        }\n        TopicUtil.topicSwitchVisible(context, info, handler, isGradedData);\n    }\n\n</code></pre>\n<h4 id=\"4-通过图层id显示专题图层：\"><a href=\"#4-通过图层id显示专题图层：\" class=\"headerlink\" title=\"4.通过图层id显示专题图层：\"></a>4.通过图层id显示专题图层：</h4><pre><code class=\"Java\"> /**\n     * 通过图层id显示专题图层。\n     *\n     * @param context      上下文\n     * @param visibleInfos 当前需要显示的图层\n     */\n    public static void setLayerVisible(Context context, List&lt;ThemeInfo&gt; visibleInfos, String currentStatus) throws Exception {\n        if (JudgeNullUtil.ObjIsNull(visibleInfos)) {\n            return;\n        }\n        boolean isOpenLayer = false;\n        if (!currentStatus.equals(Constants.TOPIC_STATUS_OFF)) {\n            isOpenLayer = true;\n        }\n        if(App.isOnLineData){\n            onlineVisibleLayer(context, visibleInfos, isOpenLayer);\n        }else{\n            offlineVisibleLayer(visibleInfos,isOpenLayer);\n        }\n    }\n\n</code></pre>\n<h4 id=\"5-更新专题数据：\"><a href=\"#5-更新专题数据：\" class=\"headerlink\" title=\"5.更新专题数据：\"></a>5.更新专题数据：</h4><pre><code class=\"Java\"> /**\n  * 更新专题某一层级数据或整个专题数据源\n  */\n    public static void updateThemeList(Context context, List&lt;ThemeInfo&gt; themeList) throws Exception {\n        App appCtx = (App) context.getApplicationContext();\n        appCtx.getDataSource().setTheme(themeList);\n    }\n /**\n     * 更新子级目录专题数据\n     */\n    public static List&lt;ThemeInfo&gt; updateSubData(ThemeInfo subThemeInfo, List&lt;ThemeInfo&gt; themeList) throws Exception {\n        if (subThemeInfo == null) {\n            return themeList;\n        }\n        String currentId = subThemeInfo.getId();\n        if (currentId == null || JudgeNullUtil.ObjIsNull(themeList)) {\n            return themeList;\n        }\n        List&lt;String&gt; subLayerIds = getSubLayerIds(currentId, themeList);\n        if (JudgeNullUtil.ObjIsNull(subLayerIds)) {\n            return themeList;\n        }\n        assert subLayerIds != null;\n        for (int i = 0; i &lt; subLayerIds.size(); i++) {\n            String subId = subLayerIds.get(i);\n            subThemeInfo.setId(subId);\n            String type = getThemeType(subThemeInfo, themeList);\n            updateCurrentData(subThemeInfo, themeList);\n            if (type == null) {\n                continue;\n            }\n            if (type.equals(Constants.TYPE_CATLOG)) {\n                updateSubData(subThemeInfo, themeList);\n            }\n        }\n        return themeList;\n    }\n\n</code></pre>\n<h4 id=\"6-更新layer数据：\"><a href=\"#6-更新layer数据：\" class=\"headerlink\" title=\"6. 更新layer数据：\"></a>6. 更新layer数据：</h4><pre><code class=\"Java\">/**\n  * 设置layer显示状态\n  * @param layer专题图层\n  * @param visibleIds 图层id\n  */\npublic static void updateLayerVisible(Layer layer, int[] visibleIds, boolean isOpenLayer) throws Exception {\n        if (layer == null) {\n            return;\n        }\n        if (layer instanceof ArcGISDynamicMapServiceLayer) {\n            ArcGISDynamicMapServiceLayer dynamicLayer = (ArcGISDynamicMapServiceLayer) layer;\n            refreshDynamicLayer(visibleIds, dynamicLayer, isOpenLayer);\n        } else {\n            layer.setVisible(isOpenLayer);\n        }\n    }\n/**\n     * 根据visibleIds 更新DymicLayer\n     * @param visibleIds   layer Ids\n     * @param dynamicLayer 当前需要刷新的图层\n     */\n    private static void refreshDynamicLayer(int[] visibleIds, ArcGISDynamicMapServiceLayer dynamicLayer, boolean isOpenLayer) throws Exception {\n        if (dynamicLayer == null) {\n            return;\n        }\n        ArcGISLayerInfo[] arcGISLayerInfos = dynamicLayer.getAllLayers();\n        if (visibleIds.length &gt; arcGISLayerInfos.length) {\n            return;\n        }\n        ArcGISLayerInfo layerInfo;\n        for (int index : visibleIds) {\n            if (index &lt; 0) {\n                continue;\n            }\n            layerInfo = arcGISLayerInfos[index];\n            if (layerInfo == null) {\n                continue;\n            }\n            boolean isVisible = layerInfo.isVisible();\n            ArcGISLayerInfo layerParentInfo = layerInfo.getParentLayer();\n\n            if (layerParentInfo != null) {\n                boolean parentVisible = layerParentInfo.isVisible();\n                if (isOpenLayer) {\n                    if (!parentVisible) {\n                        layerParentInfo.setVisible(true);\n                    }\n                } else {\n                    if (parentVisible) {\n                        layerParentInfo.setVisible(false);\n                    }\n                }\n            }\n            if (isOpenLayer) {\n                if (!isVisible) {\n                    layerInfo.setVisible(true);\n                }\n            } else {\n                if (isVisible) {\n                    layerInfo.setVisible(false);\n                }\n            }\n        }\n        if (!dynamicLayer.isVisible()) {\n            dynamicLayer.setVisible(true);\n        }\n        dynamicLayer.refresh();\n    }\n\n</code></pre>\n<hr>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>专题模块的开发提高了项目的灵活性和通透性，大大缩短了用户点击搜索的时间，保证了多层级结构加载时层与层之间的联系不冲突，确保它们之间稳定性。查询时可通过坐标点查询多个图层所对应信息，大大缩短了查询效率，确保项目的顺利进行。为后期新功能迭代打下坚实基础，提高用户体验。</p>"},{"title":"Chrome-Devtool","date":"2018-08-14T01:08:33.000Z","_content":"\n# 基于Chrome DevTools的Web应用程序的性能分析\n\n<!-- more -->\n\n=======\n## 前端页面渲染——原理：\n**定义：**  即是web用户在访问一个页面时所要花费的时间总和。即一个完全意义上的用户响应时间，相对于服务器的响应时间而言还会包括更多的内容和影响因素。那么一个web页面的完整请求包括了哪些部分的时间总和就是web前端性能分析和优化所需要了解的基础知识，先了解一下用户从浏览器访问一个url后到页面完全展示所有内容的整个过程吧。    \n    \n**页面请求的过程：**\n1. 浏览器的url请求  \n2. 递归寻找DNS服务器 \n3. 连接目标IP并建立TCP连接   \n4. 向目标服务器发送http请求  \n5. web服务器接收请求后处理   \n6. web服务器返回相应的结果【无效、重定向、正确页面等】   \n7. 浏览器接收返回的http内容 \n\n**页面解析的过程：**    \n\n1.\tDom Tree：浏览器将html解析成一个dom树，dom树的创建时一个深遍历的过程。\n2.\tCss Rule Tree：将css样式全部解析成Css Rule Tree的规则树。\n3.\tRender Tree：将Dom Tree和Css Rule Tree结合进行Render Tree的构建，Render Tree不同于Dom Tree，它将一些没有必要渲染的dom节点进行了相应的处理，例如：header标签，display为none的标签元素等。\n4.\tlayout：有了Render Tree我们就可以对每个节点在屏幕中的位置进行计算处理。\n5.\tpaiting: 最后通过位置和样式进行相应的节点进行绘制展示在前端页面上。\n\n**影响前端流畅相应的因素（回流与重绘）**    \n减少Render Tree的回流和重绘，主要需要处理的是**回流**问题。     \n**定义：**  \n**回流：** Render Tree中的元素因为尺寸，布局，隐藏等改变而需要重新构建，这就叫做回流（reflow）。\n\n**重绘**：当Render Tree的一部分元素需要更新元素，而这些元素只是外观，风格不影响布局，则叫做重绘。 \n\n**注：** 回流必定带来重绘，而重绘不一定会回流，回流带来页面渲染的工作量打，过多的回流容易造成页面的卡顿。\n\n**浏览器的优化策略：**  \n一般浏览器都会进行回流的优化处理，因为回流的代价比较大，所以如果每一个操作都需要进行回流处理，那么浏览器很容易承受不住，于是浏览器自身就进行了优化处理，将回流和重绘操作放置在一个队列中，在到达一定时间或者一定数量则进行**批量**的处理，这样将多次的回流和重绘操作减少成为一次的操作。\n\n**前端注意：**  \n一些操作可能提前强制浏览器对**队列**进行flush，例如在向浏览器请求一些style信息时就可能造成队列flush。\n1.\t请求offsetTop、offsetLeft、offsetWidth、offsetHeight时\n2.\t请求scrollTop、scrollLeft、scrollWidth、scrollHeight\n3.\t请求clientTop、clientLeft、clentWidth、clientHeight\n4.\t请求getComputedStyle()计算样式时 \n\n因为请求一些属性时，浏览器为了给精确的值，队列中的一些操作可能会影响到这些值，那么即使获取元素的布局和样式信息根最近发生或者改变的布局信息无关，浏览器都会强行刷新渲染队列。\n\n**减少回流的策略：** 减少回流和重绘其实就是减少对Render Tree的操作，减少对一些style信息的请求，尽量利用浏览器的优化策略。\n1.\t直接改变className，如果动态改变样式则使用cssText（考虑没有优化浏览器）\n    ```\n       // 不好的写法\n       var left = 1;\n       var top = 1;\n       el.style.left = left + 'px';\n       el.style.top = top + 'px';\n       // 比较好的写法\n       el.className = 'class1';\n    ```\n2.\t让操作元素进行“离线处理”，处理完一起更新    \n    a) 使用DocumentFragment进行缓存操作,引发一次回流和重绘；  \n    ```\n    // 不好的写法\n    var p = document.createElement('p');\n    var t = document.createTextNode('text1');\n    p.appendChild(t);\n    document.appendChild(p); // 引起一次回流\n    p = document.createElement('p');\n    t = document.createTextNode('text2');\n    p.appendChild(t);\n    document.body.appendChild(p); // 又引起一次回流\n    // 比较好的写法\n    var farg = document.creatDocumentFragment();\n    var p = document.creatElement('p');\n    var t = document.creatTextNode('text1');\n    p.appendChild(t);\n    farg.appendChild(p);\n    p = document.creatElement('p');\n    t = document.creatTextNode('text2');\n    p.appendChild(t);\n    farg.appendChild(p);\n    document.body.appendChild(frag); // 这样只会引起一次回流\n    ```\n    b) 使用display:none技术，只引发两次回流和重绘；  \n    ```\n    var container = document.getElementById('div1');\n    container.style.display = 'none'; // 引起一次回流\n    for (var i = 0; i < 10; i++) {\n        var p = document.createElement('p');\n        var t = document.creatTextNode('text' + i);\n        container.appendChild(p);\n    }\n    container.style.display = 'block'; // 引起另外一次回流\n    ```\n    c) 使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘； \n    ```\n    //建立克隆镜像\n    var oldNode = document.getElementById('target'),\n    clone = oldNode.cloneNode(true);   //深复制\n    //   处理克隆对象的操作....\n    //完成后\n    oldNode.parentNode.replaceChild(clone,oldNode);\n    ```\n    \n3.\t不要经常访问会flush队列的属性，如果确定要访问，则多利用缓存\n    ```\n    // 不好的方式\n    for(循环) {\n        el.style.left = el.offsetLeft + 5 + 'px';\n        el.style.top = el.offsetTop + 5 + 'px';\n    }\n \n    // 好的方式\n    var left = el.offsetLeft,\n    top = el.offsetTop,\n    s = el.style; \n    for (循环) { \n        left += 10; \n        top += 10; \n        s.left = left + 'px'; \n        s.top = top + 'px'; \n    }\n    ```\n4.\t让元素脱离动画流，减少回流的Render Tree的规模\n\n\n## Performanance的使用\n**Chrome Performance：** 主要是用于页面性能分析，可进行页面状态、事件、运行、内存查看，通过操作页面查看性能情况，进行分析定位。  \nDemo测试： [https://googlechrome.github.io/devtools-samples/jank/](https://googlechrome.github.io/devtools-samples/jank/)\n\n1、先对移动方块进行添加，添加至页面进行卡顿，因为每台机器的性能不同，添加至一定数目之后才会造成卡顿\n![image](png1.png)      \n\n2、打开开发者工具进行performance的记录得到分析数据的展示情况。  \n![image](png2.png)      \n\n1) 数据展示主要的花费事件在于Rendering  \n![image](png3.png)      \n\n2) fps显示红色提醒，卡顿，缩放至细节查看    \n![image](png4.png)  \n![image](png5.png)  \n\n3) 点击有红色三角的Recalculate Style的调用栈。       \n    发现有提示可能发生回流情况，点击reveal查看详细信息。    \n    ![image](png6.png)      \n    \n    进入代码查看在app.js的70行代码发生了回流情况。      \n    ![image](png7.png)      \n    \n    发现在其中多次访问了offsetTop的属性，造成了回流问题。       \n    ![image](png8.png)      \n\t\n3、在采用另外一种优化性能方式查看代码（获取样式top缓存处理不多次访问），发现页面流畅了很多。        \n![image](png9.png)  \n\n## Memory的使用\n**Chrome Memory：** 主要是用于深度性能分析，提供记录场景运行、记录堆快照、记录堆分配等三个功能实现对渲染性能和内存泄漏的分析定位。\n\n**快照的方式**\nDemo测试： [https://handsome-hang.github.io/test/chrome/](https://handsome-hang.github.io/test/chrome/)\n目前采用比较多的方式是是使用快照对比来完成，如图：  \n    \n1、首先在初始化页面进行一次快照处理记录初始化状态。（基本参照）     \n![image](memory_png1.png)  \n\n2、然后进行点击添加按钮进行widget的创建添加。   \n![image](memory_png2.png)  \n\n3、接着进行删除操作对widget进行了移除处理，进行一次快照获取。   \n![image](memory_png3.png)   \n\n4、然后反复先前操作进行快照记录处理。       \n![image](memory_png4.png)   \n\n可以发现内存在一次次操作后得到的快照内存大小不断的在增长，这个时候就可以判断出应该是有内存泄漏没有被回收。  \n![image](memory_png6.png)   \n\n5、将获取的快照进行对比处理。   \n![image](memory_png5.png)   \n\n6、对引用类型（以Detached DOM 为例子）进行分析查看， #Delta是否有不断增加，如果有则是有异常内存泄漏。        \n![image](memory_png7.png)       \n\n7、查看详细增长内容有属性被哪些地方引用而导致没有办法回收，发现widget的一些信息没有被回收而一直存在。     \n\n![image](memory_png8.png)       \n8、通过删除操作找到对应的代码，来查看widget被移除操作中间发生了什么而导致widget内容没有被回收，发现index.html代码中有问题。 \n```\n// 问题所在\ndomConstruct.destroy(window.container1.domNode); // 只是移除了dom节点，并没有对widget整个对象进行处理导致有引用存在\n\n// 将widget进行整个摧毁处理调用destroy方法\nwindow.container.destroy(); //  进行widget的摧毁处理\n```\n9、之后再次进行来看内存是否能够被及时的处理，发现内存增长停止了，并且Detached DOM增长没有了，内存被及时的回收防止了内存的泄漏。     \n\n![image](memory_png9.png)   \n\nMemory还有提供另外两个分析内存的工具。      \n**Collect JavaScript CPU Profile：** 记录一段场景cpu的分配使用情况。   \n\n![image](memory_png10.png)       \n对其中对内存影响较大的，并且有提示的方法进行相应的注意和相应的处理  \n\n![image](memory_png11.png)       \n**Record Heap Allocations：** 一段记录堆分配内存进行处理    \n\n![image](memory_png12.png)      \n堆突出的蓝条，如果没有释放掉要进行特别注意并且分析其中的情况详情，如果没有释放则需要跟踪代码进行处理        \n\n![image](memory_png13.png)   \n\n#### 内存泄漏的原因：   \n（1）监听在window/document/body等handler事件没有解绑\n\n\n（2）模块形成的闭包内部变量使用完后没有将引入变量设为null\n\n\n（3）使用第三方库创建，没有调用正确的销毁函数\n\n\n（4）dom的移除若子节点存在引用则无法回收\n\n\n（5）widget使用事件的订阅，在摧毁时没有移除\n\n## 总结语\n在**Performance**中已经可以完成大多数的性能检测定位。而在其中**Memory**进行详细分析处理内存泄漏问题处理，使用工具处理问题是一部分解决方案，但是根源问题还是在于**编码的规范**问题，如果已经成熟的系统，在内存性能检测上是很麻烦的事情，所以内存性能检测是一个**不断持续**的过程。    \n\n内容中如果出现什么有错误的地方请及时的提醒，以便进行及时的修正。\n\n","source":"_posts/TOOLS/Chrome-Devtool.md","raw":"---\ntitle: Chrome-Devtool\ndate: 2018-08-14 09:08:33\ntags: chrome devtool 性能分析 内存泄露\ncategories: tools\n---\n\n# 基于Chrome DevTools的Web应用程序的性能分析\n\n<!-- more -->\n\n=======\n## 前端页面渲染——原理：\n**定义：**  即是web用户在访问一个页面时所要花费的时间总和。即一个完全意义上的用户响应时间，相对于服务器的响应时间而言还会包括更多的内容和影响因素。那么一个web页面的完整请求包括了哪些部分的时间总和就是web前端性能分析和优化所需要了解的基础知识，先了解一下用户从浏览器访问一个url后到页面完全展示所有内容的整个过程吧。    \n    \n**页面请求的过程：**\n1. 浏览器的url请求  \n2. 递归寻找DNS服务器 \n3. 连接目标IP并建立TCP连接   \n4. 向目标服务器发送http请求  \n5. web服务器接收请求后处理   \n6. web服务器返回相应的结果【无效、重定向、正确页面等】   \n7. 浏览器接收返回的http内容 \n\n**页面解析的过程：**    \n\n1.\tDom Tree：浏览器将html解析成一个dom树，dom树的创建时一个深遍历的过程。\n2.\tCss Rule Tree：将css样式全部解析成Css Rule Tree的规则树。\n3.\tRender Tree：将Dom Tree和Css Rule Tree结合进行Render Tree的构建，Render Tree不同于Dom Tree，它将一些没有必要渲染的dom节点进行了相应的处理，例如：header标签，display为none的标签元素等。\n4.\tlayout：有了Render Tree我们就可以对每个节点在屏幕中的位置进行计算处理。\n5.\tpaiting: 最后通过位置和样式进行相应的节点进行绘制展示在前端页面上。\n\n**影响前端流畅相应的因素（回流与重绘）**    \n减少Render Tree的回流和重绘，主要需要处理的是**回流**问题。     \n**定义：**  \n**回流：** Render Tree中的元素因为尺寸，布局，隐藏等改变而需要重新构建，这就叫做回流（reflow）。\n\n**重绘**：当Render Tree的一部分元素需要更新元素，而这些元素只是外观，风格不影响布局，则叫做重绘。 \n\n**注：** 回流必定带来重绘，而重绘不一定会回流，回流带来页面渲染的工作量打，过多的回流容易造成页面的卡顿。\n\n**浏览器的优化策略：**  \n一般浏览器都会进行回流的优化处理，因为回流的代价比较大，所以如果每一个操作都需要进行回流处理，那么浏览器很容易承受不住，于是浏览器自身就进行了优化处理，将回流和重绘操作放置在一个队列中，在到达一定时间或者一定数量则进行**批量**的处理，这样将多次的回流和重绘操作减少成为一次的操作。\n\n**前端注意：**  \n一些操作可能提前强制浏览器对**队列**进行flush，例如在向浏览器请求一些style信息时就可能造成队列flush。\n1.\t请求offsetTop、offsetLeft、offsetWidth、offsetHeight时\n2.\t请求scrollTop、scrollLeft、scrollWidth、scrollHeight\n3.\t请求clientTop、clientLeft、clentWidth、clientHeight\n4.\t请求getComputedStyle()计算样式时 \n\n因为请求一些属性时，浏览器为了给精确的值，队列中的一些操作可能会影响到这些值，那么即使获取元素的布局和样式信息根最近发生或者改变的布局信息无关，浏览器都会强行刷新渲染队列。\n\n**减少回流的策略：** 减少回流和重绘其实就是减少对Render Tree的操作，减少对一些style信息的请求，尽量利用浏览器的优化策略。\n1.\t直接改变className，如果动态改变样式则使用cssText（考虑没有优化浏览器）\n    ```\n       // 不好的写法\n       var left = 1;\n       var top = 1;\n       el.style.left = left + 'px';\n       el.style.top = top + 'px';\n       // 比较好的写法\n       el.className = 'class1';\n    ```\n2.\t让操作元素进行“离线处理”，处理完一起更新    \n    a) 使用DocumentFragment进行缓存操作,引发一次回流和重绘；  \n    ```\n    // 不好的写法\n    var p = document.createElement('p');\n    var t = document.createTextNode('text1');\n    p.appendChild(t);\n    document.appendChild(p); // 引起一次回流\n    p = document.createElement('p');\n    t = document.createTextNode('text2');\n    p.appendChild(t);\n    document.body.appendChild(p); // 又引起一次回流\n    // 比较好的写法\n    var farg = document.creatDocumentFragment();\n    var p = document.creatElement('p');\n    var t = document.creatTextNode('text1');\n    p.appendChild(t);\n    farg.appendChild(p);\n    p = document.creatElement('p');\n    t = document.creatTextNode('text2');\n    p.appendChild(t);\n    farg.appendChild(p);\n    document.body.appendChild(frag); // 这样只会引起一次回流\n    ```\n    b) 使用display:none技术，只引发两次回流和重绘；  \n    ```\n    var container = document.getElementById('div1');\n    container.style.display = 'none'; // 引起一次回流\n    for (var i = 0; i < 10; i++) {\n        var p = document.createElement('p');\n        var t = document.creatTextNode('text' + i);\n        container.appendChild(p);\n    }\n    container.style.display = 'block'; // 引起另外一次回流\n    ```\n    c) 使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘； \n    ```\n    //建立克隆镜像\n    var oldNode = document.getElementById('target'),\n    clone = oldNode.cloneNode(true);   //深复制\n    //   处理克隆对象的操作....\n    //完成后\n    oldNode.parentNode.replaceChild(clone,oldNode);\n    ```\n    \n3.\t不要经常访问会flush队列的属性，如果确定要访问，则多利用缓存\n    ```\n    // 不好的方式\n    for(循环) {\n        el.style.left = el.offsetLeft + 5 + 'px';\n        el.style.top = el.offsetTop + 5 + 'px';\n    }\n \n    // 好的方式\n    var left = el.offsetLeft,\n    top = el.offsetTop,\n    s = el.style; \n    for (循环) { \n        left += 10; \n        top += 10; \n        s.left = left + 'px'; \n        s.top = top + 'px'; \n    }\n    ```\n4.\t让元素脱离动画流，减少回流的Render Tree的规模\n\n\n## Performanance的使用\n**Chrome Performance：** 主要是用于页面性能分析，可进行页面状态、事件、运行、内存查看，通过操作页面查看性能情况，进行分析定位。  \nDemo测试： [https://googlechrome.github.io/devtools-samples/jank/](https://googlechrome.github.io/devtools-samples/jank/)\n\n1、先对移动方块进行添加，添加至页面进行卡顿，因为每台机器的性能不同，添加至一定数目之后才会造成卡顿\n![image](png1.png)      \n\n2、打开开发者工具进行performance的记录得到分析数据的展示情况。  \n![image](png2.png)      \n\n1) 数据展示主要的花费事件在于Rendering  \n![image](png3.png)      \n\n2) fps显示红色提醒，卡顿，缩放至细节查看    \n![image](png4.png)  \n![image](png5.png)  \n\n3) 点击有红色三角的Recalculate Style的调用栈。       \n    发现有提示可能发生回流情况，点击reveal查看详细信息。    \n    ![image](png6.png)      \n    \n    进入代码查看在app.js的70行代码发生了回流情况。      \n    ![image](png7.png)      \n    \n    发现在其中多次访问了offsetTop的属性，造成了回流问题。       \n    ![image](png8.png)      \n\t\n3、在采用另外一种优化性能方式查看代码（获取样式top缓存处理不多次访问），发现页面流畅了很多。        \n![image](png9.png)  \n\n## Memory的使用\n**Chrome Memory：** 主要是用于深度性能分析，提供记录场景运行、记录堆快照、记录堆分配等三个功能实现对渲染性能和内存泄漏的分析定位。\n\n**快照的方式**\nDemo测试： [https://handsome-hang.github.io/test/chrome/](https://handsome-hang.github.io/test/chrome/)\n目前采用比较多的方式是是使用快照对比来完成，如图：  \n    \n1、首先在初始化页面进行一次快照处理记录初始化状态。（基本参照）     \n![image](memory_png1.png)  \n\n2、然后进行点击添加按钮进行widget的创建添加。   \n![image](memory_png2.png)  \n\n3、接着进行删除操作对widget进行了移除处理，进行一次快照获取。   \n![image](memory_png3.png)   \n\n4、然后反复先前操作进行快照记录处理。       \n![image](memory_png4.png)   \n\n可以发现内存在一次次操作后得到的快照内存大小不断的在增长，这个时候就可以判断出应该是有内存泄漏没有被回收。  \n![image](memory_png6.png)   \n\n5、将获取的快照进行对比处理。   \n![image](memory_png5.png)   \n\n6、对引用类型（以Detached DOM 为例子）进行分析查看， #Delta是否有不断增加，如果有则是有异常内存泄漏。        \n![image](memory_png7.png)       \n\n7、查看详细增长内容有属性被哪些地方引用而导致没有办法回收，发现widget的一些信息没有被回收而一直存在。     \n\n![image](memory_png8.png)       \n8、通过删除操作找到对应的代码，来查看widget被移除操作中间发生了什么而导致widget内容没有被回收，发现index.html代码中有问题。 \n```\n// 问题所在\ndomConstruct.destroy(window.container1.domNode); // 只是移除了dom节点，并没有对widget整个对象进行处理导致有引用存在\n\n// 将widget进行整个摧毁处理调用destroy方法\nwindow.container.destroy(); //  进行widget的摧毁处理\n```\n9、之后再次进行来看内存是否能够被及时的处理，发现内存增长停止了，并且Detached DOM增长没有了，内存被及时的回收防止了内存的泄漏。     \n\n![image](memory_png9.png)   \n\nMemory还有提供另外两个分析内存的工具。      \n**Collect JavaScript CPU Profile：** 记录一段场景cpu的分配使用情况。   \n\n![image](memory_png10.png)       \n对其中对内存影响较大的，并且有提示的方法进行相应的注意和相应的处理  \n\n![image](memory_png11.png)       \n**Record Heap Allocations：** 一段记录堆分配内存进行处理    \n\n![image](memory_png12.png)      \n堆突出的蓝条，如果没有释放掉要进行特别注意并且分析其中的情况详情，如果没有释放则需要跟踪代码进行处理        \n\n![image](memory_png13.png)   \n\n#### 内存泄漏的原因：   \n（1）监听在window/document/body等handler事件没有解绑\n\n\n（2）模块形成的闭包内部变量使用完后没有将引入变量设为null\n\n\n（3）使用第三方库创建，没有调用正确的销毁函数\n\n\n（4）dom的移除若子节点存在引用则无法回收\n\n\n（5）widget使用事件的订阅，在摧毁时没有移除\n\n## 总结语\n在**Performance**中已经可以完成大多数的性能检测定位。而在其中**Memory**进行详细分析处理内存泄漏问题处理，使用工具处理问题是一部分解决方案，但是根源问题还是在于**编码的规范**问题，如果已经成熟的系统，在内存性能检测上是很麻烦的事情，所以内存性能检测是一个**不断持续**的过程。    \n\n内容中如果出现什么有错误的地方请及时的提醒，以便进行及时的修正。\n\n","slug":"TOOLS/Chrome-Devtool","published":1,"updated":"2018-08-14T01:53:34.531Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlhtwxej000lxcl5vyhxhqdb","content":"<h1 id=\"基于Chrome-DevTools的Web应用程序的性能分析\"><a href=\"#基于Chrome-DevTools的Web应用程序的性能分析\" class=\"headerlink\" title=\"基于Chrome DevTools的Web应用程序的性能分析\"></a>基于Chrome DevTools的Web应用程序的性能分析</h1><a id=\"more\"></a>\n<p>=======</p>\n<h2 id=\"前端页面渲染——原理：\"><a href=\"#前端页面渲染——原理：\" class=\"headerlink\" title=\"前端页面渲染——原理：\"></a>前端页面渲染——原理：</h2><p><strong>定义：</strong>  即是web用户在访问一个页面时所要花费的时间总和。即一个完全意义上的用户响应时间，相对于服务器的响应时间而言还会包括更多的内容和影响因素。那么一个web页面的完整请求包括了哪些部分的时间总和就是web前端性能分析和优化所需要了解的基础知识，先了解一下用户从浏览器访问一个url后到页面完全展示所有内容的整个过程吧。    </p>\n<p><strong>页面请求的过程：</strong></p>\n<ol>\n<li>浏览器的url请求  </li>\n<li>递归寻找DNS服务器 </li>\n<li>连接目标IP并建立TCP连接   </li>\n<li>向目标服务器发送http请求  </li>\n<li>web服务器接收请求后处理   </li>\n<li>web服务器返回相应的结果【无效、重定向、正确页面等】   </li>\n<li>浏览器接收返回的http内容 </li>\n</ol>\n<p><strong>页面解析的过程：</strong>    </p>\n<ol>\n<li>Dom Tree：浏览器将html解析成一个dom树，dom树的创建时一个深遍历的过程。</li>\n<li>Css Rule Tree：将css样式全部解析成Css Rule Tree的规则树。</li>\n<li>Render Tree：将Dom Tree和Css Rule Tree结合进行Render Tree的构建，Render Tree不同于Dom Tree，它将一些没有必要渲染的dom节点进行了相应的处理，例如：header标签，display为none的标签元素等。</li>\n<li>layout：有了Render Tree我们就可以对每个节点在屏幕中的位置进行计算处理。</li>\n<li>paiting: 最后通过位置和样式进行相应的节点进行绘制展示在前端页面上。</li>\n</ol>\n<p><strong>影响前端流畅相应的因素（回流与重绘）</strong><br>减少Render Tree的回流和重绘，主要需要处理的是<strong>回流</strong>问题。<br><strong>定义：</strong><br><strong>回流：</strong> Render Tree中的元素因为尺寸，布局，隐藏等改变而需要重新构建，这就叫做回流（reflow）。</p>\n<p><strong>重绘</strong>：当Render Tree的一部分元素需要更新元素，而这些元素只是外观，风格不影响布局，则叫做重绘。 </p>\n<p><strong>注：</strong> 回流必定带来重绘，而重绘不一定会回流，回流带来页面渲染的工作量打，过多的回流容易造成页面的卡顿。</p>\n<p><strong>浏览器的优化策略：</strong><br>一般浏览器都会进行回流的优化处理，因为回流的代价比较大，所以如果每一个操作都需要进行回流处理，那么浏览器很容易承受不住，于是浏览器自身就进行了优化处理，将回流和重绘操作放置在一个队列中，在到达一定时间或者一定数量则进行<strong>批量</strong>的处理，这样将多次的回流和重绘操作减少成为一次的操作。</p>\n<p><strong>前端注意：</strong><br>一些操作可能提前强制浏览器对<strong>队列</strong>进行flush，例如在向浏览器请求一些style信息时就可能造成队列flush。</p>\n<ol>\n<li>请求offsetTop、offsetLeft、offsetWidth、offsetHeight时</li>\n<li>请求scrollTop、scrollLeft、scrollWidth、scrollHeight</li>\n<li>请求clientTop、clientLeft、clentWidth、clientHeight</li>\n<li>请求getComputedStyle()计算样式时 </li>\n</ol>\n<p>因为请求一些属性时，浏览器为了给精确的值，队列中的一些操作可能会影响到这些值，那么即使获取元素的布局和样式信息根最近发生或者改变的布局信息无关，浏览器都会强行刷新渲染队列。</p>\n<p><strong>减少回流的策略：</strong> 减少回流和重绘其实就是减少对Render Tree的操作，减少对一些style信息的请求，尽量利用浏览器的优化策略。</p>\n<ol>\n<li>直接改变className，如果动态改变样式则使用cssText（考虑没有优化浏览器）<pre><code> // 不好的写法\n var left = 1;\n var top = 1;\n el.style.left = left + &#39;px&#39;;\n el.style.top = top + &#39;px&#39;;\n // 比较好的写法\n el.className = &#39;class1&#39;;\n</code></pre></li>\n<li><p>让操作元素进行“离线处理”，处理完一起更新<br>a) 使用DocumentFragment进行缓存操作,引发一次回流和重绘；  </p>\n<pre><code>// 不好的写法\nvar p = document.createElement(&#39;p&#39;);\nvar t = document.createTextNode(&#39;text1&#39;);\np.appendChild(t);\ndocument.appendChild(p); // 引起一次回流\np = document.createElement(&#39;p&#39;);\nt = document.createTextNode(&#39;text2&#39;);\np.appendChild(t);\ndocument.body.appendChild(p); // 又引起一次回流\n// 比较好的写法\nvar farg = document.creatDocumentFragment();\nvar p = document.creatElement(&#39;p&#39;);\nvar t = document.creatTextNode(&#39;text1&#39;);\np.appendChild(t);\nfarg.appendChild(p);\np = document.creatElement(&#39;p&#39;);\nt = document.creatTextNode(&#39;text2&#39;);\np.appendChild(t);\nfarg.appendChild(p);\ndocument.body.appendChild(frag); // 这样只会引起一次回流\n</code></pre><p>b) 使用display:none技术，只引发两次回流和重绘；  </p>\n<pre><code>var container = document.getElementById(&#39;div1&#39;);\ncontainer.style.display = &#39;none&#39;; // 引起一次回流\nfor (var i = 0; i &lt; 10; i++) {\n  var p = document.createElement(&#39;p&#39;);\n  var t = document.creatTextNode(&#39;text&#39; + i);\n  container.appendChild(p);\n}\ncontainer.style.display = &#39;block&#39;; // 引起另外一次回流\n</code></pre><p>c) 使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘； </p>\n<pre><code>//建立克隆镜像\nvar oldNode = document.getElementById(&#39;target&#39;),\nclone = oldNode.cloneNode(true);   //深复制\n//   处理克隆对象的操作....\n//完成后\noldNode.parentNode.replaceChild(clone,oldNode);\n</code></pre></li>\n<li><p>不要经常访问会flush队列的属性，如果确定要访问，则多利用缓存</p>\n<pre><code>// 不好的方式\nfor(循环) {\n  el.style.left = el.offsetLeft + 5 + &#39;px&#39;;\n  el.style.top = el.offsetTop + 5 + &#39;px&#39;;\n}\n\n// 好的方式\nvar left = el.offsetLeft,\ntop = el.offsetTop,\ns = el.style; \nfor (循环) { \n  left += 10; \n  top += 10; \n  s.left = left + &#39;px&#39;; \n  s.top = top + &#39;px&#39;; \n}\n</code></pre></li>\n<li>让元素脱离动画流，减少回流的Render Tree的规模</li>\n</ol>\n<h2 id=\"Performanance的使用\"><a href=\"#Performanance的使用\" class=\"headerlink\" title=\"Performanance的使用\"></a>Performanance的使用</h2><p><strong>Chrome Performance：</strong> 主要是用于页面性能分析，可进行页面状态、事件、运行、内存查看，通过操作页面查看性能情况，进行分析定位。<br>Demo测试： <a href=\"https://googlechrome.github.io/devtools-samples/jank/\" target=\"_blank\" rel=\"noopener\">https://googlechrome.github.io/devtools-samples/jank/</a></p>\n<p>1、先对移动方块进行添加，添加至页面进行卡顿，因为每台机器的性能不同，添加至一定数目之后才会造成卡顿<br><img src=\"png1.png\" alt=\"image\">      </p>\n<p>2、打开开发者工具进行performance的记录得到分析数据的展示情况。<br><img src=\"png2.png\" alt=\"image\">      </p>\n<p>1) 数据展示主要的花费事件在于Rendering<br><img src=\"png3.png\" alt=\"image\">      </p>\n<p>2) fps显示红色提醒，卡顿，缩放至细节查看<br><img src=\"png4.png\" alt=\"image\"><br><img src=\"png5.png\" alt=\"image\">  </p>\n<p>3) 点击有红色三角的Recalculate Style的调用栈。<br>    发现有提示可能发生回流情况，点击reveal查看详细信息。<br>    <img src=\"png6.png\" alt=\"image\">      </p>\n<pre><code>进入代码查看在app.js的70行代码发生了回流情况。      \n![image](png7.png)      \n\n发现在其中多次访问了offsetTop的属性，造成了回流问题。       \n![image](png8.png)      \n</code></pre><p>3、在采用另外一种优化性能方式查看代码（获取样式top缓存处理不多次访问），发现页面流畅了很多。<br><img src=\"png9.png\" alt=\"image\">  </p>\n<h2 id=\"Memory的使用\"><a href=\"#Memory的使用\" class=\"headerlink\" title=\"Memory的使用\"></a>Memory的使用</h2><p><strong>Chrome Memory：</strong> 主要是用于深度性能分析，提供记录场景运行、记录堆快照、记录堆分配等三个功能实现对渲染性能和内存泄漏的分析定位。</p>\n<p><strong>快照的方式</strong><br>Demo测试： <a href=\"https://handsome-hang.github.io/test/chrome/\" target=\"_blank\" rel=\"noopener\">https://handsome-hang.github.io/test/chrome/</a><br>目前采用比较多的方式是是使用快照对比来完成，如图：  </p>\n<p>1、首先在初始化页面进行一次快照处理记录初始化状态。（基本参照）<br><img src=\"memory_png1.png\" alt=\"image\">  </p>\n<p>2、然后进行点击添加按钮进行widget的创建添加。<br><img src=\"memory_png2.png\" alt=\"image\">  </p>\n<p>3、接着进行删除操作对widget进行了移除处理，进行一次快照获取。<br><img src=\"memory_png3.png\" alt=\"image\">   </p>\n<p>4、然后反复先前操作进行快照记录处理。<br><img src=\"memory_png4.png\" alt=\"image\">   </p>\n<p>可以发现内存在一次次操作后得到的快照内存大小不断的在增长，这个时候就可以判断出应该是有内存泄漏没有被回收。<br><img src=\"memory_png6.png\" alt=\"image\">   </p>\n<p>5、将获取的快照进行对比处理。<br><img src=\"memory_png5.png\" alt=\"image\">   </p>\n<p>6、对引用类型（以Detached DOM 为例子）进行分析查看， #Delta是否有不断增加，如果有则是有异常内存泄漏。<br><img src=\"memory_png7.png\" alt=\"image\">       </p>\n<p>7、查看详细增长内容有属性被哪些地方引用而导致没有办法回收，发现widget的一些信息没有被回收而一直存在。     </p>\n<p><img src=\"memory_png8.png\" alt=\"image\"><br>8、通过删除操作找到对应的代码，来查看widget被移除操作中间发生了什么而导致widget内容没有被回收，发现index.html代码中有问题。 </p>\n<pre><code>// 问题所在\ndomConstruct.destroy(window.container1.domNode); // 只是移除了dom节点，并没有对widget整个对象进行处理导致有引用存在\n\n// 将widget进行整个摧毁处理调用destroy方法\nwindow.container.destroy(); //  进行widget的摧毁处理\n</code></pre><p>9、之后再次进行来看内存是否能够被及时的处理，发现内存增长停止了，并且Detached DOM增长没有了，内存被及时的回收防止了内存的泄漏。     </p>\n<p><img src=\"memory_png9.png\" alt=\"image\">   </p>\n<p>Memory还有提供另外两个分析内存的工具。<br><strong>Collect JavaScript CPU Profile：</strong> 记录一段场景cpu的分配使用情况。   </p>\n<p><img src=\"memory_png10.png\" alt=\"image\"><br>对其中对内存影响较大的，并且有提示的方法进行相应的注意和相应的处理  </p>\n<p><img src=\"memory_png11.png\" alt=\"image\"><br><strong>Record Heap Allocations：</strong> 一段记录堆分配内存进行处理    </p>\n<p><img src=\"memory_png12.png\" alt=\"image\"><br>堆突出的蓝条，如果没有释放掉要进行特别注意并且分析其中的情况详情，如果没有释放则需要跟踪代码进行处理        </p>\n<p><img src=\"memory_png13.png\" alt=\"image\">   </p>\n<h4 id=\"内存泄漏的原因：\"><a href=\"#内存泄漏的原因：\" class=\"headerlink\" title=\"内存泄漏的原因：\"></a>内存泄漏的原因：</h4><p>（1）监听在window/document/body等handler事件没有解绑</p>\n<p>（2）模块形成的闭包内部变量使用完后没有将引入变量设为null</p>\n<p>（3）使用第三方库创建，没有调用正确的销毁函数</p>\n<p>（4）dom的移除若子节点存在引用则无法回收</p>\n<p>（5）widget使用事件的订阅，在摧毁时没有移除</p>\n<h2 id=\"总结语\"><a href=\"#总结语\" class=\"headerlink\" title=\"总结语\"></a>总结语</h2><p>在<strong>Performance</strong>中已经可以完成大多数的性能检测定位。而在其中<strong>Memory</strong>进行详细分析处理内存泄漏问题处理，使用工具处理问题是一部分解决方案，但是根源问题还是在于<strong>编码的规范</strong>问题，如果已经成熟的系统，在内存性能检测上是很麻烦的事情，所以内存性能检测是一个<strong>不断持续</strong>的过程。    </p>\n<p>内容中如果出现什么有错误的地方请及时的提醒，以便进行及时的修正。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"基于Chrome-DevTools的Web应用程序的性能分析\"><a href=\"#基于Chrome-DevTools的Web应用程序的性能分析\" class=\"headerlink\" title=\"基于Chrome DevTools的Web应用程序的性能分析\"></a>基于Chrome DevTools的Web应用程序的性能分析</h1>","more":"<p>=======</p>\n<h2 id=\"前端页面渲染——原理：\"><a href=\"#前端页面渲染——原理：\" class=\"headerlink\" title=\"前端页面渲染——原理：\"></a>前端页面渲染——原理：</h2><p><strong>定义：</strong>  即是web用户在访问一个页面时所要花费的时间总和。即一个完全意义上的用户响应时间，相对于服务器的响应时间而言还会包括更多的内容和影响因素。那么一个web页面的完整请求包括了哪些部分的时间总和就是web前端性能分析和优化所需要了解的基础知识，先了解一下用户从浏览器访问一个url后到页面完全展示所有内容的整个过程吧。    </p>\n<p><strong>页面请求的过程：</strong></p>\n<ol>\n<li>浏览器的url请求  </li>\n<li>递归寻找DNS服务器 </li>\n<li>连接目标IP并建立TCP连接   </li>\n<li>向目标服务器发送http请求  </li>\n<li>web服务器接收请求后处理   </li>\n<li>web服务器返回相应的结果【无效、重定向、正确页面等】   </li>\n<li>浏览器接收返回的http内容 </li>\n</ol>\n<p><strong>页面解析的过程：</strong>    </p>\n<ol>\n<li>Dom Tree：浏览器将html解析成一个dom树，dom树的创建时一个深遍历的过程。</li>\n<li>Css Rule Tree：将css样式全部解析成Css Rule Tree的规则树。</li>\n<li>Render Tree：将Dom Tree和Css Rule Tree结合进行Render Tree的构建，Render Tree不同于Dom Tree，它将一些没有必要渲染的dom节点进行了相应的处理，例如：header标签，display为none的标签元素等。</li>\n<li>layout：有了Render Tree我们就可以对每个节点在屏幕中的位置进行计算处理。</li>\n<li>paiting: 最后通过位置和样式进行相应的节点进行绘制展示在前端页面上。</li>\n</ol>\n<p><strong>影响前端流畅相应的因素（回流与重绘）</strong><br>减少Render Tree的回流和重绘，主要需要处理的是<strong>回流</strong>问题。<br><strong>定义：</strong><br><strong>回流：</strong> Render Tree中的元素因为尺寸，布局，隐藏等改变而需要重新构建，这就叫做回流（reflow）。</p>\n<p><strong>重绘</strong>：当Render Tree的一部分元素需要更新元素，而这些元素只是外观，风格不影响布局，则叫做重绘。 </p>\n<p><strong>注：</strong> 回流必定带来重绘，而重绘不一定会回流，回流带来页面渲染的工作量打，过多的回流容易造成页面的卡顿。</p>\n<p><strong>浏览器的优化策略：</strong><br>一般浏览器都会进行回流的优化处理，因为回流的代价比较大，所以如果每一个操作都需要进行回流处理，那么浏览器很容易承受不住，于是浏览器自身就进行了优化处理，将回流和重绘操作放置在一个队列中，在到达一定时间或者一定数量则进行<strong>批量</strong>的处理，这样将多次的回流和重绘操作减少成为一次的操作。</p>\n<p><strong>前端注意：</strong><br>一些操作可能提前强制浏览器对<strong>队列</strong>进行flush，例如在向浏览器请求一些style信息时就可能造成队列flush。</p>\n<ol>\n<li>请求offsetTop、offsetLeft、offsetWidth、offsetHeight时</li>\n<li>请求scrollTop、scrollLeft、scrollWidth、scrollHeight</li>\n<li>请求clientTop、clientLeft、clentWidth、clientHeight</li>\n<li>请求getComputedStyle()计算样式时 </li>\n</ol>\n<p>因为请求一些属性时，浏览器为了给精确的值，队列中的一些操作可能会影响到这些值，那么即使获取元素的布局和样式信息根最近发生或者改变的布局信息无关，浏览器都会强行刷新渲染队列。</p>\n<p><strong>减少回流的策略：</strong> 减少回流和重绘其实就是减少对Render Tree的操作，减少对一些style信息的请求，尽量利用浏览器的优化策略。</p>\n<ol>\n<li>直接改变className，如果动态改变样式则使用cssText（考虑没有优化浏览器）<pre><code> // 不好的写法\n var left = 1;\n var top = 1;\n el.style.left = left + &#39;px&#39;;\n el.style.top = top + &#39;px&#39;;\n // 比较好的写法\n el.className = &#39;class1&#39;;\n</code></pre></li>\n<li><p>让操作元素进行“离线处理”，处理完一起更新<br>a) 使用DocumentFragment进行缓存操作,引发一次回流和重绘；  </p>\n<pre><code>// 不好的写法\nvar p = document.createElement(&#39;p&#39;);\nvar t = document.createTextNode(&#39;text1&#39;);\np.appendChild(t);\ndocument.appendChild(p); // 引起一次回流\np = document.createElement(&#39;p&#39;);\nt = document.createTextNode(&#39;text2&#39;);\np.appendChild(t);\ndocument.body.appendChild(p); // 又引起一次回流\n// 比较好的写法\nvar farg = document.creatDocumentFragment();\nvar p = document.creatElement(&#39;p&#39;);\nvar t = document.creatTextNode(&#39;text1&#39;);\np.appendChild(t);\nfarg.appendChild(p);\np = document.creatElement(&#39;p&#39;);\nt = document.creatTextNode(&#39;text2&#39;);\np.appendChild(t);\nfarg.appendChild(p);\ndocument.body.appendChild(frag); // 这样只会引起一次回流\n</code></pre><p>b) 使用display:none技术，只引发两次回流和重绘；  </p>\n<pre><code>var container = document.getElementById(&#39;div1&#39;);\ncontainer.style.display = &#39;none&#39;; // 引起一次回流\nfor (var i = 0; i &lt; 10; i++) {\n  var p = document.createElement(&#39;p&#39;);\n  var t = document.creatTextNode(&#39;text&#39; + i);\n  container.appendChild(p);\n}\ncontainer.style.display = &#39;block&#39;; // 引起另外一次回流\n</code></pre><p>c) 使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘； </p>\n<pre><code>//建立克隆镜像\nvar oldNode = document.getElementById(&#39;target&#39;),\nclone = oldNode.cloneNode(true);   //深复制\n//   处理克隆对象的操作....\n//完成后\noldNode.parentNode.replaceChild(clone,oldNode);\n</code></pre></li>\n<li><p>不要经常访问会flush队列的属性，如果确定要访问，则多利用缓存</p>\n<pre><code>// 不好的方式\nfor(循环) {\n  el.style.left = el.offsetLeft + 5 + &#39;px&#39;;\n  el.style.top = el.offsetTop + 5 + &#39;px&#39;;\n}\n\n// 好的方式\nvar left = el.offsetLeft,\ntop = el.offsetTop,\ns = el.style; \nfor (循环) { \n  left += 10; \n  top += 10; \n  s.left = left + &#39;px&#39;; \n  s.top = top + &#39;px&#39;; \n}\n</code></pre></li>\n<li>让元素脱离动画流，减少回流的Render Tree的规模</li>\n</ol>\n<h2 id=\"Performanance的使用\"><a href=\"#Performanance的使用\" class=\"headerlink\" title=\"Performanance的使用\"></a>Performanance的使用</h2><p><strong>Chrome Performance：</strong> 主要是用于页面性能分析，可进行页面状态、事件、运行、内存查看，通过操作页面查看性能情况，进行分析定位。<br>Demo测试： <a href=\"https://googlechrome.github.io/devtools-samples/jank/\" target=\"_blank\" rel=\"noopener\">https://googlechrome.github.io/devtools-samples/jank/</a></p>\n<p>1、先对移动方块进行添加，添加至页面进行卡顿，因为每台机器的性能不同，添加至一定数目之后才会造成卡顿<br><img src=\"png1.png\" alt=\"image\">      </p>\n<p>2、打开开发者工具进行performance的记录得到分析数据的展示情况。<br><img src=\"png2.png\" alt=\"image\">      </p>\n<p>1) 数据展示主要的花费事件在于Rendering<br><img src=\"png3.png\" alt=\"image\">      </p>\n<p>2) fps显示红色提醒，卡顿，缩放至细节查看<br><img src=\"png4.png\" alt=\"image\"><br><img src=\"png5.png\" alt=\"image\">  </p>\n<p>3) 点击有红色三角的Recalculate Style的调用栈。<br>    发现有提示可能发生回流情况，点击reveal查看详细信息。<br>    <img src=\"png6.png\" alt=\"image\">      </p>\n<pre><code>进入代码查看在app.js的70行代码发生了回流情况。      \n![image](png7.png)      \n\n发现在其中多次访问了offsetTop的属性，造成了回流问题。       \n![image](png8.png)      \n</code></pre><p>3、在采用另外一种优化性能方式查看代码（获取样式top缓存处理不多次访问），发现页面流畅了很多。<br><img src=\"png9.png\" alt=\"image\">  </p>\n<h2 id=\"Memory的使用\"><a href=\"#Memory的使用\" class=\"headerlink\" title=\"Memory的使用\"></a>Memory的使用</h2><p><strong>Chrome Memory：</strong> 主要是用于深度性能分析，提供记录场景运行、记录堆快照、记录堆分配等三个功能实现对渲染性能和内存泄漏的分析定位。</p>\n<p><strong>快照的方式</strong><br>Demo测试： <a href=\"https://handsome-hang.github.io/test/chrome/\" target=\"_blank\" rel=\"noopener\">https://handsome-hang.github.io/test/chrome/</a><br>目前采用比较多的方式是是使用快照对比来完成，如图：  </p>\n<p>1、首先在初始化页面进行一次快照处理记录初始化状态。（基本参照）<br><img src=\"memory_png1.png\" alt=\"image\">  </p>\n<p>2、然后进行点击添加按钮进行widget的创建添加。<br><img src=\"memory_png2.png\" alt=\"image\">  </p>\n<p>3、接着进行删除操作对widget进行了移除处理，进行一次快照获取。<br><img src=\"memory_png3.png\" alt=\"image\">   </p>\n<p>4、然后反复先前操作进行快照记录处理。<br><img src=\"memory_png4.png\" alt=\"image\">   </p>\n<p>可以发现内存在一次次操作后得到的快照内存大小不断的在增长，这个时候就可以判断出应该是有内存泄漏没有被回收。<br><img src=\"memory_png6.png\" alt=\"image\">   </p>\n<p>5、将获取的快照进行对比处理。<br><img src=\"memory_png5.png\" alt=\"image\">   </p>\n<p>6、对引用类型（以Detached DOM 为例子）进行分析查看， #Delta是否有不断增加，如果有则是有异常内存泄漏。<br><img src=\"memory_png7.png\" alt=\"image\">       </p>\n<p>7、查看详细增长内容有属性被哪些地方引用而导致没有办法回收，发现widget的一些信息没有被回收而一直存在。     </p>\n<p><img src=\"memory_png8.png\" alt=\"image\"><br>8、通过删除操作找到对应的代码，来查看widget被移除操作中间发生了什么而导致widget内容没有被回收，发现index.html代码中有问题。 </p>\n<pre><code>// 问题所在\ndomConstruct.destroy(window.container1.domNode); // 只是移除了dom节点，并没有对widget整个对象进行处理导致有引用存在\n\n// 将widget进行整个摧毁处理调用destroy方法\nwindow.container.destroy(); //  进行widget的摧毁处理\n</code></pre><p>9、之后再次进行来看内存是否能够被及时的处理，发现内存增长停止了，并且Detached DOM增长没有了，内存被及时的回收防止了内存的泄漏。     </p>\n<p><img src=\"memory_png9.png\" alt=\"image\">   </p>\n<p>Memory还有提供另外两个分析内存的工具。<br><strong>Collect JavaScript CPU Profile：</strong> 记录一段场景cpu的分配使用情况。   </p>\n<p><img src=\"memory_png10.png\" alt=\"image\"><br>对其中对内存影响较大的，并且有提示的方法进行相应的注意和相应的处理  </p>\n<p><img src=\"memory_png11.png\" alt=\"image\"><br><strong>Record Heap Allocations：</strong> 一段记录堆分配内存进行处理    </p>\n<p><img src=\"memory_png12.png\" alt=\"image\"><br>堆突出的蓝条，如果没有释放掉要进行特别注意并且分析其中的情况详情，如果没有释放则需要跟踪代码进行处理        </p>\n<p><img src=\"memory_png13.png\" alt=\"image\">   </p>\n<h4 id=\"内存泄漏的原因：\"><a href=\"#内存泄漏的原因：\" class=\"headerlink\" title=\"内存泄漏的原因：\"></a>内存泄漏的原因：</h4><p>（1）监听在window/document/body等handler事件没有解绑</p>\n<p>（2）模块形成的闭包内部变量使用完后没有将引入变量设为null</p>\n<p>（3）使用第三方库创建，没有调用正确的销毁函数</p>\n<p>（4）dom的移除若子节点存在引用则无法回收</p>\n<p>（5）widget使用事件的订阅，在摧毁时没有移除</p>\n<h2 id=\"总结语\"><a href=\"#总结语\" class=\"headerlink\" title=\"总结语\"></a>总结语</h2><p>在<strong>Performance</strong>中已经可以完成大多数的性能检测定位。而在其中<strong>Memory</strong>进行详细分析处理内存泄漏问题处理，使用工具处理问题是一部分解决方案，但是根源问题还是在于<strong>编码的规范</strong>问题，如果已经成熟的系统，在内存性能检测上是很麻烦的事情，所以内存性能检测是一个<strong>不断持续</strong>的过程。    </p>\n<p>内容中如果出现什么有错误的地方请及时的提醒，以便进行及时的修正。</p>"},{"title":"WebPack4入门","date":"2018-07-10T02:20:05.000Z","_content":"\n[Webpack4及模块绑定入门手册](https://www.sitepoint.com/beginners-guide-webpack-module-bundling/)\n\n本文在我们的书《现代JavaScript工具和技能》中有所介绍。 让我们一起熟悉支持现代JavaScript开发的基本工具。\n\n<!-- more -->\n\nWebpack4 文档中说到：\n\n>Webpack是一个module bundler。 它的主要目的是捆绑JavaScript文件以便在浏览器中使用，但它也能够转换，捆绑或打包任何资源。\n\nWebpack已成为现代Web开发最重要的工具之一。 它主要是JavaScript的module bundler，但它可以用来转换所有前端资源，如HTML，CSS，甚至图像。 它可以让您更好地控制应用程序正在进行的HTTP请求的数量，并允许您使用其他类型的这些资源（例如，Pug，Sass和ES8）。 Webpack还允许您轻松地从npm使用包。\n\n本文面向那些刚接触Webpack的人，将介绍初始设置和配置，模块，加载器（loaders），插件，代码拆分和热模块更换。 如果您发现视频教程很有帮助，我强烈推荐Glen Maddern的**Webpack from First Principles** 作为起点，了解Webpack的特殊之处。 它现在有点旧了，但原则仍然相同，这是一个很好的介绍。\n\n要在家中进行操作，您需要安装Node.js. 您也可以从我们的GitHub仓库下载演示应用程序。\n\n##  开始  ##\n\n让我们用npm初始化一个新项目并安装webpack和webpack-cli：\n\n\tmkdir webpack-demo && cd webpack-demo\n\tnpm init -y\n\tnpm install --save-dev webpack webpack-cli\n\n接下来我们将创建下面文件结构和内容：\n\n\twebpack-demo\n\t|- package.json\n\t|- webpack.config.js\n\t|- /src\n\t |- index.js\n\t|- /dist\n\t |- index.html\n\ndist/index.html\n\n\t<!doctype html>\n\t<html>\n\t  <head>\n\t    <title>Hello Webpack</title>\n\t  </head>\n\t  <body>\n\t    <script src=\"bundle.js\"></script>\n\t  </body>\n\t</html>\n\nsrc/index.js\n\n\tconst root = document.createElement(\"div\")\n\troot.innerHTML = `<p>Hello Webpack.</p>`\n\tdocument.body.appendChild(root)\n\nwebpack.config.js\n\n\tconst path = require('path')\n\t\n\tmodule.exports = {\n\t  entry: './src/index.js',\n\t  output: {\n\t    filename: 'bundle.js',\n\t    path: path.resolve(__dirname, 'dist')\n\t  }\n\t}\n\n这告诉Webpack在我们的入口点**src / index.js**中编译代码并在**/dist/bundle.js**中输出一个bundle。 我们来添加一个用于运行Webpack的npm脚本。\n\npackage.json\n\n\t {\n\t    ...\n\t    \"scripts\": {\n\t     \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n\t     \"develop\": \"webpack --mode development --watch\",\n\t     \"build\": \"webpack --mode production\"\n\t    },\n\t    ...\n\t  }\n\n使用npm run develop命令，我们可以创建我们的第一个包！\n\n\tAsset      Size      Chunks           Chunk Names\n\tbundle.js  2.92 KiB  main  [emitted]  main\n\n您现在应该可以在浏览器中加载dist / index.html并看到“Hello Webpack”。\n\n打开**dist / bundle.js**以查看Webpack的功能。 顶部是Webpack的模块引导代码，底部是我们的模块。 你可能对此还没有很深刻的印象，但是如果你已经走到这一步，你现在可以开始使用ES模块，而Webpack将能够生成一个适用于所有浏览器的生产包。\n\n使用Ctrl + C重新编译并运行npm run build以在生产模式下编译我们的bundle。\n\t\n\tAsset      Size       Chunks           Chunk Names\n\tbundle.js  647 bytes  main  [emitted]  main\n\n请注意，捆绑包大小已从2.92 KiB降至647字节。\n\n再看一下**dist / bundle.js**，你会看到一堆丑陋的代码。 我们的软件包已经用UglifyJS缩小了：代码将运行完全相同，但它是以尽可能小的文件大小完成的。\n\n* - **模式开发**优化了构建速度和调试\n* - **模式生产**优化了运行时的执行速度和输出文件大小。\n\n## 模块 ##\n\n使用ES模块，您可以将大型程序拆分为许多小型自包含程序。\n\n创造性地，Webpack知道如何使用导入和导出语句来使用ES模块。 举个例子，让我们现在通过安装lodash-es并添加第二个模块来尝试这个：\n\n\tnpm install --save-dev lodash-es\n\nsrc/index.js\n\t\n\timport { groupBy } from \"lodash-es\"\n\timport people from \"./people\"\n\t\n\tconst managerGroups = groupBy(people, \"manager\")\n\t\n\tconst root = document.createElement(\"div\")\n\troot.innerHTML = `<pre>${JSON.stringify(managerGroups, null, 2)}</pre>`\n\tdocument.body.appendChild(root)\n\nsrc/people.js\n\n\tconst people = [\n\t  {\n\t    manager: \"Jen\",\n\t    name: \"Bob\"\n\t  },\n\t  {\n\t    manager: \"Jen\",\n\t    name: \"Sue\"\n\t  },\n\t  {\n\t    manager: \"Bob\",\n\t    name: \"Shirley\"\n\t  }\n\t]\n\t\n\texport default people\n\n运行**npm run develop**启动Webpack并刷新**index.html**。 您应该看到按管理器分组的一组人员打印到屏幕上。\n\n注意：导入一个像***'es-lodash'***这样没有相对路径的模块，是从npm安装到 node_modules的模块。 你自己的模块总是需要一个像***'./people'***这样的相对路径，因此你可以区分它们。\n\n请注意，在控制台中我们的捆绑包大小已增加到**1.41 MiB**！ 这值得关注，但在这种情况下，没有理由担心。 使用**npm run build**在生产模式下编译，lodash-es中的所有未使用的lodash模块都将从bundle中删除。 删除未使用的导入的过程称为tree-shaking，并且是Webpack免费获得的。\n\n\t> npm run develop\n\t\n\tAsset      Size      Chunks                  Chunk Names\n\tbundle.js  1.41 MiB  main  [emitted]  [big]  main\n\n\n\t> npm run build\n\t\n\tAsset      Size      Chunks        Chunk Names\n\tbundle.js  16.7 KiB  0  [emitted]  main\n\n## 装载 ##\n\n加载程序允许您在导入文件时运行预处理程序。 这允许您将静态资源捆绑到JavaScript之外，但让我们看看在首先加载**.js**模块时可以做些什么。\n\n让我们通过下一代JavaScript转换器Babel运行所有**.js**文件来保持代码的现代化：\n\t\n\tnpm install --save-dev \"babel-loader@^8.0.0-beta\" @babel/core @babel/preset-env\n\nwebpack.config.js\n\n\tconst path = require('path')\n\t\n\t  module.exports = {\n\t    entry: './src/index.js',\n\t    output: {\n\t      filename: 'bundle.js',\n\t      path: path.resolve(__dirname, 'dist')\n\t    },\n\t   module: {\n\t     rules: [\n\t       {\n\t         test: /\\.js$/,\n\t         exclude: /(node_modules|bower_components)/,\n\t         use: {\n\t           loader: 'babel-loader',\n\t         }\n\t       }\n\t     ]\n\t   }\n\t  }\n\n.babelrc\n\n\t{\n\t  \"presets\": [\n\t    [\"@babel/env\", {\n\t      \"modules\": false\n\t    }]\n\t  ],\n\t  \"plugins\": [\"syntax-dynamic-import\"]\n\t}\n\n此配置可防止Babel将导入和导出语句转换为ES5，并启用动态导入，这个我们将在后面的“代码拆分”一节中介绍。\n\n我们现在可以自由使用现代语言功能，它们将被编译为在所有浏览器中运行的ES5。\n\n## Sass ##\n\nLoaders可以链接在一起进行一系列变换。 从我们的JavaScript导入Sass可以较好地演示它是如何工作的：\n\t\n\tnpm install --save-dev style-loader css-loader sass-loader node-sass\n\nwebpack.config.js\n\n\t module.exports = {\n    ...\n    module: {\n      rules: [\n        ...\n\t       {\n\t         test: /\\.scss$/,\n\t         use: [{\n\t           loader: 'style-loader'\n\t         }, {\n\t           loader: 'css-loader'\n\t         }, {\n\t           loader: 'sass-loader'\n\t         }]\n\t       }\n\t      ]\n\t    }\n\t  }\n\n这些加载器以相反的顺序处理:\n\n* sass-loader将Sass转换为CSS。\n* css-loader将CSS解析为JavaScript并解析任何依赖项。\n* style-loader将我们的CSS输出到文档中的<style\\>标记中。\n\n您可以将这些视为函数调用。 一个加载器的输出作为输入提供给下一个：\n\n\tstyleLoader(cssLoader(sassLoader(\"source\")))\n\n让我们添加一个Sass源文件，import是一个模块。\n\nsrc/style.scss\n\n\t$bluegrey: #2b3a42;\n\t\n\tpre {\n\t  padding: 8px 16px;\n\t  background: $bluegrey;\n\t  color: #e1e6e9;\n\t  font-family: Menlo, Courier, monospace;\n\t  font-size: 13px;\n\t  line-height: 1.5;\n\t  text-shadow: 0 1px 0 rgba(23, 31, 35, 0.5);\n\t  border-radius: 3px;\n\t}\n\nsrc/index.js\n\n\timport { groupBy } from 'lodash-es'\n\timport people from './people'\n\t\n\timport './style.scss'\n\t\n\t  ...\n\n使用Ctrl + C和npm run develop重新启动构建。 在浏览器中刷新index.html，您应该看到一些样式。\n\n## JS中的样式表 ##\n\n我们刚从JavaScript中导入了一个Sass文件作为模块。\n\n打开dist / bundle.js并搜索“pre {”。 实际上，我们的Sass已被编译为一串CSS并在我们的包中保存为模块。 当我们将这个模块导入JavaScript时，style-loader将字符串输出到嵌入的<style\\>标记中。\n\n你为什么需要做这样的事？\n\n我不会在这里深入研究这个主题，但这里有几个理由需要考虑：\n\n* 您可能希望包含在项目中的JavaScript组件可能依赖于其他资源才能正常运行（HTML，CSS，图像，SVG）。 如果这些都可以捆绑在一起，则导入和使用起来要容易得多。\n* 消除Dead code：当代码不再导入JS组件时，也不再导入CSS。 生成的包只会包含执行某些操作的代码。\n* CSS模块：CSS的全局命名空间使得很难确信对CSS的更改不会产生任何副作用。 CSS模块通过设置CSS默认本地并显示您可以在JavaScript中引用的唯一类名来解决该问题。\n* 通过巧妙的方式捆绑/拆分代码来减少HTTP请求的数量。\n\n## 图片 ##\n我们将看到的最后一个加载器示例是使用文件加载器处理图像。\n\n在标准HTML文档中，当浏览器遇到img标记或具有background-image属性的元素时，将获取图像。 使用Webpack，您可以在小图像的情况下通过将图像源作为字符串存储在JavaScript中来优化它。 通过执行此操作，您可以预加载它们，浏览器不必在以后使用单独的请求获取它们：\n\n\tnpm install --save-dev file-loader\n\nwebpack.config.js\n\t\n\tmodule.exports = {\n\t    ...\n\t    module: {\n\t      rules: [\n\t        ...\n\t       {\n\t         test: /\\.(png|svg|jpg|gif)$/,\n\t         use: [\n\t           {\n\t             loader: 'file-loader'\n\t           }\n\t         ]\n\t       }\n\t      ]\n\t    }\n\t  }\n\n用以下命令下载一个测试图像：\n\n\t\tcurl https://raw.githubusercontent.com/sitepoint-editors/webpack-demo/master/src/code.png --output src/code.png\n\n使用Ctrl + C和npm run develop重新启动构建，您现在可以将图像作为模块导入！\n\nsrc/index.js\n\n\timport { groupBy } from 'lodash-es'\n\timport people from './people'\n\t\n\timport './style.scss'\n\timport './image-example'\n\t\n\t  ...\n\n\nsrc/image-example.js\n\n\timport codeURL from \"./code.png\"\n\t\n\tconst img = document.createElement(\"img\")\n\timg.src = codeURL\n\timg.style = \"background: #2B3A42; padding: 20px\"\n\timg.width = 32\n\tdocument.body.appendChild(img)\n\n这将包括一个图像，其中src属性包含图像本身的数据URI：\n\n\t<img src=\"data:image/png;base64,iVBO...\" style=\"background: #2B3A42; padding: 20px\" width=\"32\">\n\n我们的CSS中的背景图像也由文件加载器处理。\n\nsrc/style.scss\n\n\t$bluegrey: #2b3a42;\n\t\n\t  pre {\n\t    padding: 8px 16px;\n\t    background: $bluegrey;\n\t    background: $bluegrey url(\"code.png\") no-repeat center center / 32px 32px;\n\t    color: #e1e6e9;\n\t    font-family: Menlo, Courier, monospace;\n\t    font-size: 13px;\n\t    line-height: 1.5;\n\t    text-shadow: 0 1px 0 rgba(23, 31, 35, 0.5);\n\t    border-radius: 3px;\n\t  }\n\n在文档中查看更多Loaders示例：\n\n* [加载字体](https://webpack.js.org/guides/asset-management/#loading-fonts)\n* [加载数据](https://webpack.js.org/guides/asset-management/#loading-data)\n\n## 依赖图 Dependency Graph##\n\n您现在应该能够看到加载器如何帮助您在资源中构建依赖关系树。 这就是Webpack主页上的图像所展示的内容。\n\n![](https://dab1nmslvvntp.cloudfront.net/wp-content/uploads/2017/01/1484692838webpack-dependency-tree.png)\n\n尽管JavaScript是切入点，但Webpack明白您的其他资源类型（如HTML，CSS和SVG）各自具有自己的依赖关系，这应该被视为构建过程的一部分。\n\n## 代码拆分 ##\n\nWebpack文档中写到：\n\n>代码拆分是Webpack最引人注目的功能之一。 此功能允许您将代码拆分为各种捆绑包，然后可以按需或并行加载。 它可用于实现更小的捆绑并控制资源负载优先级，如果使用得当，可能会对加载时间产生重大影响。\n\n到目前为止，我们只看到了一个入口点 - **src / index.js** - 和一个输出包 - dist / bundle.js。 当您的应用程序增长时，您需要将其拆分，以便在开始时不会下载整个代码库。 一种好的方法是使用Code Splitting和Lazy Loading来按需获取内容，因为代码路径需要它们。\n\n我们通过添加一个“聊天”模块来证明这一点，该模块在有人与之交互时被提取和初始化。 我们将创建一个新的入口点并为其命名，我们还将使输出的文件名动态，因此每个块的不同。\n\nwebpack.config.js\n\n\t const path = require('path')\n\t\n\t  module.exports = {\n\t   entry: './src/index.js',\n\t   entry: {\n\t     app: './src/app.js'\n\t   },\n\t   output: {\n\t     filename: 'bundle.js',\n\t     filename: '[name].bundle.js',\n\t     path: path.resolve(__dirname, 'dist')\n\t    },\n\t    ...\n\t  }\n\nsrc/app.js\n\n\timport './app.scss'\n\t\n\tconst button = document.createElement(\"button\")\n\tbutton.textContent = 'Open chat'\n\tdocument.body.appendChild(button)\n\t\n\tbutton.onclick = () => {\n\t  import(/* webpackChunkName: \"chat\" */ \"./chat\").then(chat => {\n\t    chat.init()\n\t  })\n\t}\n\nsrc/chat.js\n\n\timport people from \"./people\"\n\t\n\texport function init() {\n\t  const root = document.createElement(\"div\")\n\t  root.innerHTML = `<p>There are ${people.length} people in the room.</p>`\n\t  document.body.appendChild(root)\n\t}\n\nsrc/app.scss\n\n\tbutton {\n\t  padding: 10px;\n\t  background: #24b47e;\n\t  border: 1px solid rgba(#000, .1);\n\t  border-width: 1px 1px 3px;\n\t  border-radius: 3px;\n\t  font: inherit;\n\t  color: #fff;\n\t  cursor: pointer;\n\t  text-shadow: 0 1px 0 rgba(#000, .3), 0 1px 1px rgba(#000, .2);\n\t}\n\n注意：尽管*/ * webpackChunkName * /* comment为包提供了名称，但此语法不是特定于Webpack的。 它是动态导入的建议语法，旨在直接在浏览器中支持。\n\n我们运行npm run build并查看它生成的内容：\n\n\tAsset           Size       Chunks        Chunk Names\n\tchat.bundle.js  377 bytes  0  [emitted]  chat\n\tapp.bundle.js   7.65 KiB   1  [emitted]  app\n\n由于我们的条目包已经更改，我们还需要更新它的路径。\n\ndist/index.html\n\n\t<!doctype html>\n\t  <html>\n\t    <head>\n\t      <title>Hello Webpack</title>\n\t    </head>\n\t    <body>\n\t    <script src=\"bundle.js\"></script>\n\t    <script src=\"app.bundle.js\"></script>\n\t    </body>\n\t  </html>\n\n我们从dist目录启动一个服务器，看看这个实际应用：\n\n\tcd dist\n\tnpx serve\n\n在浏览器中打开http://localhost:5000，看看会发生什么。 最初只获取bundle.js。 单击该按钮时，将导入并初始化聊天模块。\n![](https://dab1nmslvvntp.cloudfront.net/wp-content/uploads/2018/03/1521906882lazy-loading.png)\n\n只需很少的工作，我们就可以在我们的应用程序中添加动态代码拆分和延迟加载模块。 这是构建高性能Web应用程序的一个很好的起点。\n\n## 插件 ##\n\n当加载器对单个文件进行转换时，插件可以在更大的代码块上运行。\n\n现在我们正在打包代码，外部模块和静态资产，我们的包将会迅速增长。 插件可以帮助我们以巧妙的方式分割代码并优化生产。\n\n在不知情的情况下，我们实际上已经使用了许多默认的Webpack插件“模式”\n\n发展\n\n* 提供process.env.NODE_ENV，其值为“development”\n* NamedModulesPlugin\n\n生产\n\n* 提供process.env.NODE_ENV，其值为“production”\n* UglifyJsPlugin\n* ModuleConcatenationPlugin\n* NoEmitOnErrorsPlugin\n\n## 产品 ##\n\n在添加其他插件之前，我们首先拆分我们的配置，以便我们可以应用特定于每个环境的插件。\n\n将webpack.config.js重命名为webpack.common.js并添加用于开发和生产的配置文件。\n\n\t- |- webpack.config.js\n\t+ |- webpack.common.js\n\t+ |- webpack.dev.js\n\t+ |- webpack.prod.js\n\n我们将使用webpack-merge将我们的公共配置与特定于环境的配置相结合：\n\n\tnpm install --save-dev webpack-merge\n\nwebpack.dev.js\n\n\tconst merge = require('webpack-merge')\n\tconst common = require('./webpack.common.js')\n\t\n\tmodule.exports = merge(common, {\n\t  mode: 'development'\n\t})\n\nwebpack.prod.js\n\n\tconst merge = require('webpack-merge')\n\tconst common = require('./webpack.common.js')\n\t\n\tmodule.exports = merge(common, {\n\t  mode: 'production'\n\t})\n\npackage.json\n\n\t \"scripts\": {\n\t    \"develop\": \"webpack --watch --mode development\",\n\t    \"build\": \"webpack --mode production\"\n\t    \"develop\": \"webpack --watch --config webpack.dev.js\",\n\t    \"build\": \"webpack --config webpack.prod.js\"\n\t   },\n\n现在我们可以将特定于开发的插件添加到webpack.dev.js和webpack.prod.js中特定于生产的插件中。\n\n## 拆分CSS ##\n\n在使用ExtractTextWebpackPlugin捆绑生产时，最好将CSS与JavaScript分开。\n\n当前的.scss加载器非常适合开发，所以我们将把它们从webpack.common.js移到webpack.dev.js中，并将ExtractTextWebpackPlugin添加到webpack.prod.js中。\n\n\tnpm install --save-dev extract-text-webpack-plugin@4.0.0-beta.0\n\nwebpack.common.js\n\n\t ...\n\t  module.exports = {\n\t    ...\n\t    module: {\n\t      rules: [\n\t        ...\n\t-       {\n\t-         test: /\\.scss$/,\n\t-         use: [\n\t-           {\n\t-             loader: 'style-loader'\n\t-           }, {\n\t-             loader: 'css-loader'\n\t-           }, {\n\t-             loader: 'sass-loader'\n\t-           }\n\t-         ]\n\t-       },\n\t        ...\n\t      ]\n\t    }\n\t  }\n\nwebpack.dev.js\n\n\t  const merge = require('webpack-merge')\n\t+ const ExtractTextPlugin = require('extract-text-webpack-plugin')\n\t  const common = require('./webpack.common.js')\n\t\n\t  module.exports = merge(common, {\n\t    mode: 'production',\n\t    module: {\n\t     rules: [\n          {\n\t         test: /\\.scss$/,\n\t         use: ExtractTextPlugin.extract({\n\t           fallback: 'style-loader',\n\t           use: ['css-loader', 'sass-loader']\n\t         })\n\t       }\n\t     ]\n\t   },\n\t   plugins: [\n\t     new ExtractTextPlugin('style.css')\n\t   ]\n\t  })\n\n我们来比较两个构建脚本的输出：\n\n\t> npm run develop\n\t\n\tAsset           Size      Chunks           Chunk Names\n\tapp.bundle.js   28.5 KiB  app   [emitted]  app\n\tchat.bundle.js  1.4 KiB   chat  [emitted]  chat\n\n\t> npm run build\n\t\n\tAsset           Size       Chunks        Chunk Names\n\tchat.bundle.js  375 bytes  0  [emitted]  chat\n\tapp.bundle.js   1.82 KiB   1  [emitted]  app\n\tstyle.css       424 bytes  1  [emitted]  app\n\n现在CSS被从JavaScript包中提取出来用于生产，我们需要从我们的HTML <link\\>到它。\n\ndist/index.html\n\n\t<!DOCTYPE html>\n\t  <html>\n\t    <head>\n\t      <meta charset=\"UTF-8\">\n\t      <title>Code Splitting</title>\n\t      <link href=\"style.css\" rel=\"stylesheet\">\n\t    </head>\n\t    <body>\n\t      <script type=\"text/javascript\" src=\"app.bundle.js\"></script>\n\t    </body>\n\t  </html>\n\n这允许在浏览器中并行下载CSS和JavaScript，因此加载速度比单个捆绑包更快。 它还允许在JavaScript完成下载之前显示样式。\n\n## 生成HTML ##\n\n每当我们的输出发生变化时，我们必须不断更新index.html以引用新的文件路径。 这正是html-webpack-plugin自动为我们创建的。\n\n我们也可以在每次构建之前同时添加clean-webpack-plugin来清除/dist目录。\n\n\tnpm install --save-dev html-webpack-plugin clean-webpack-plugin\n\nwebpack.common.js\n\n\t const path = require('path')\n\t const CleanWebpackPlugin = require('clean-webpack-plugin');\n\t const HtmlWebpackPlugin = require('html-webpack-plugin');\n\t\n\t  module.exports = {\n\t    ...\n\t   plugins: [\n\t     new CleanWebpackPlugin(['dist']),\n\t     new HtmlWebpackPlugin({\n\t       title: 'My killer app'\n\t     })\n\t   ]\n\t  }\n\n现在每次我们建立时，dist都会被清除掉。 我们现在也会看到index.html输出，以及我们的入口包的正确路径。\n\n运行npm run develop会产生以下结果：\n\n\t<!DOCTYPE html>\n\t<html>\n\t  <head>\n\t    <meta charset=\"UTF-8\">\n\t    <title>My killer app</title>\n\t  </head>\n\t  <body>\n\t    <script type=\"text/javascript\" src=\"app.bundle.js\"></script>\n\t  </body>\n\t</html>\n\n而npm run build产生了这个：\n\n\t<!DOCTYPE html>\n\t<html>\n\t  <head>\n\t    <meta charset=\"UTF-8\">\n\t    <title>My killer app</title>\n\t    <link href=\"style.css\" rel=\"stylesheet\">\n\t  </head>\n\t  <body>\n\t    <script type=\"text/javascript\" src=\"app.bundle.js\"></script>\n\t  </body>\n\t</html>\n\n## 发展 ##\n\nwebpack-dev-server为您提供了一个简单的Web服务器，并为您提供实时重新加载，因此您无需手动刷新页面即可查看更改。\n\n\tnpm install --save-dev webpack-dev-server\n\npackage.json\n\n\t{\n\t    ...\n\t    \"scripts\": {\n\t     \"develop\": \"webpack --watch --config webpack.dev.js\",\n\t     \"develop\": \"webpack-dev-server --config webpack.dev.js\",\n\t    }\n\t    ...\n\t  }\n\n\t> npm run develop\n\t\n\t ｢wds｣: Project is running at http://localhost:8080/\n\t ｢wds｣: webpack output is served from /\n\n在浏览器中打开http://localhost:8080/并对其中一个JavaScript或CSS文件进行更改。 您应该看到它自动构建和刷新。\n\n## HotModuleReplacement ##\n\nHotModuleReplacement插件比Live Reloading更进一步，并在运行时交换模块而无需刷新。 正确配置后，这可以节省开发单页应用程序的大量时间。 如果页面中有很多状态，则可以对组件进行增量更改，只更换和更新已更改的模块。\n\nwebpack.dev.js\n\n\t  const webpack = require('webpack')\n\t  const merge = require('webpack-merge')\n\t  const common = require('./webpack.common.js')\n\t\n\t  module.exports = merge(common, {\n\t    mode: 'development',\n\t   devServer: {\n\t     hot: true\n\t   },\n\t   plugins: [\n\t     new webpack.HotModuleReplacementPlugin()\n\t   ],\n\t    ...\n\t  }\n\n现在我们需要从代码中接受更改的模块来重新初始化事物。\n\nsrc/app.js\n\n\t if (module.hot) {\n\t   module.hot.accept()\n\t }\n\t\n\t  ...\n\n注意：启用热模块替换时，module.hot设置为true以进行开发，false设置为生产，因此这些将从捆绑中剥离。\n\n重新启动构建，看看执行以下操作时会发生什么：\n\n* 单击打开聊天\n* 将新人添加到people.js模块\n* 再次单击“打开聊天”\n\n![](https://dab1nmslvvntp.cloudfront.net/wp-content/uploads/2018/03/1521906879hmr.png)\n\n这是发生了什么：\n\n1. 单击“打开聊天”时，将获取并初始化chat.js模块\n2. HMR检测perple.js何时被修改\n3. index.js中的module.hot.accept（）会导致替换此条目块加载的所有模块\n4. 再次单击“打开聊天”时，将使用更新模块中的代码运行chat.init（）。\n\n## CSS替换 ##\n\n让我们将按钮颜色更改为红色，看看会发生什么：\n\n\tsrc/app.scss\n\t\n\t  button {\n\t    ...\n\t   background: #24b47e;\n\t   background: red;\n\t    ...\n\t  }\n\n![](https://dab1nmslvvntp.cloudfront.net/wp-content/uploads/2018/03/1521906881hmr2.png)\n\n现在我们可以看到我们的样式的即时更新，而不会丢失任何状态。这是一个大大改善的开发人员体验！感觉就像未来。\n\n## HTTP/2 ##\n\n使用像Webpack这样的module bundler的主要好处之一是它可以帮助您控制资源的构建方式，然后在客户端上获取，从而帮助您提高性能。多年来，连接文件以减少需要在客户端上进行的请求数量被认为是最佳实践。这仍然有效，但HTTP/2现在允许在单个请求中传递多个文件，因此连接不再是银弹。您的应用程序实际上可能会受益于单独缓存许多小文件。然后，客户端可以获取单个已更改的模块，而不必再次获取具有大部分相同内容的整个包。\n\nWebpack的创建者Tobias Koppers撰写了一篇内容丰富的文章，解释了为什么捆绑仍然很重要，即使在HTTP/2时代也是如此。\n\n在Webpack和HTTP / 2上阅读更多相关信息。\n\n## 给你的话 ##\n\n我希望你已经发现Webpack的这个介绍很有帮助，并且能够开始使用它并产生很大的效果。可能需要一些时间来围绕Webpack的配置，加载器和插件，但了解这个工具如何工作将会有所回报。\n\nWebpack 4的文档目前正在进行中，但实际上很好地组合在一起。我强烈建议您阅读概念和指南以获取更多信息。以下是您可能感兴趣的一些其他主题：\n\n* [源地图开发](https://webpack.js.org/guides/development/#using-source-maps)\n* [生产的源地图](https://webpack.js.org/guides/production/#source-mapping)\n* [缓存破坏与散列文件名](https://webpack.js.org/guides/caching/)\n* [拆分供应商包](https://webpack.js.org/plugins/commons-chunk-plugin/#explicit-vendor-chunk)\n\nWebpack 4是您选择的module bundler吗？请在下面的评论中告诉我。\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/WEBPACK/Webpack4及模块绑定入门手册.md","raw":"---\ntitle: WebPack4入门\ndate: 2018-07-10 10:20:05\ntags: WebPack\ncategories: webpack\n---\n\n[Webpack4及模块绑定入门手册](https://www.sitepoint.com/beginners-guide-webpack-module-bundling/)\n\n本文在我们的书《现代JavaScript工具和技能》中有所介绍。 让我们一起熟悉支持现代JavaScript开发的基本工具。\n\n<!-- more -->\n\nWebpack4 文档中说到：\n\n>Webpack是一个module bundler。 它的主要目的是捆绑JavaScript文件以便在浏览器中使用，但它也能够转换，捆绑或打包任何资源。\n\nWebpack已成为现代Web开发最重要的工具之一。 它主要是JavaScript的module bundler，但它可以用来转换所有前端资源，如HTML，CSS，甚至图像。 它可以让您更好地控制应用程序正在进行的HTTP请求的数量，并允许您使用其他类型的这些资源（例如，Pug，Sass和ES8）。 Webpack还允许您轻松地从npm使用包。\n\n本文面向那些刚接触Webpack的人，将介绍初始设置和配置，模块，加载器（loaders），插件，代码拆分和热模块更换。 如果您发现视频教程很有帮助，我强烈推荐Glen Maddern的**Webpack from First Principles** 作为起点，了解Webpack的特殊之处。 它现在有点旧了，但原则仍然相同，这是一个很好的介绍。\n\n要在家中进行操作，您需要安装Node.js. 您也可以从我们的GitHub仓库下载演示应用程序。\n\n##  开始  ##\n\n让我们用npm初始化一个新项目并安装webpack和webpack-cli：\n\n\tmkdir webpack-demo && cd webpack-demo\n\tnpm init -y\n\tnpm install --save-dev webpack webpack-cli\n\n接下来我们将创建下面文件结构和内容：\n\n\twebpack-demo\n\t|- package.json\n\t|- webpack.config.js\n\t|- /src\n\t |- index.js\n\t|- /dist\n\t |- index.html\n\ndist/index.html\n\n\t<!doctype html>\n\t<html>\n\t  <head>\n\t    <title>Hello Webpack</title>\n\t  </head>\n\t  <body>\n\t    <script src=\"bundle.js\"></script>\n\t  </body>\n\t</html>\n\nsrc/index.js\n\n\tconst root = document.createElement(\"div\")\n\troot.innerHTML = `<p>Hello Webpack.</p>`\n\tdocument.body.appendChild(root)\n\nwebpack.config.js\n\n\tconst path = require('path')\n\t\n\tmodule.exports = {\n\t  entry: './src/index.js',\n\t  output: {\n\t    filename: 'bundle.js',\n\t    path: path.resolve(__dirname, 'dist')\n\t  }\n\t}\n\n这告诉Webpack在我们的入口点**src / index.js**中编译代码并在**/dist/bundle.js**中输出一个bundle。 我们来添加一个用于运行Webpack的npm脚本。\n\npackage.json\n\n\t {\n\t    ...\n\t    \"scripts\": {\n\t     \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n\t     \"develop\": \"webpack --mode development --watch\",\n\t     \"build\": \"webpack --mode production\"\n\t    },\n\t    ...\n\t  }\n\n使用npm run develop命令，我们可以创建我们的第一个包！\n\n\tAsset      Size      Chunks           Chunk Names\n\tbundle.js  2.92 KiB  main  [emitted]  main\n\n您现在应该可以在浏览器中加载dist / index.html并看到“Hello Webpack”。\n\n打开**dist / bundle.js**以查看Webpack的功能。 顶部是Webpack的模块引导代码，底部是我们的模块。 你可能对此还没有很深刻的印象，但是如果你已经走到这一步，你现在可以开始使用ES模块，而Webpack将能够生成一个适用于所有浏览器的生产包。\n\n使用Ctrl + C重新编译并运行npm run build以在生产模式下编译我们的bundle。\n\t\n\tAsset      Size       Chunks           Chunk Names\n\tbundle.js  647 bytes  main  [emitted]  main\n\n请注意，捆绑包大小已从2.92 KiB降至647字节。\n\n再看一下**dist / bundle.js**，你会看到一堆丑陋的代码。 我们的软件包已经用UglifyJS缩小了：代码将运行完全相同，但它是以尽可能小的文件大小完成的。\n\n* - **模式开发**优化了构建速度和调试\n* - **模式生产**优化了运行时的执行速度和输出文件大小。\n\n## 模块 ##\n\n使用ES模块，您可以将大型程序拆分为许多小型自包含程序。\n\n创造性地，Webpack知道如何使用导入和导出语句来使用ES模块。 举个例子，让我们现在通过安装lodash-es并添加第二个模块来尝试这个：\n\n\tnpm install --save-dev lodash-es\n\nsrc/index.js\n\t\n\timport { groupBy } from \"lodash-es\"\n\timport people from \"./people\"\n\t\n\tconst managerGroups = groupBy(people, \"manager\")\n\t\n\tconst root = document.createElement(\"div\")\n\troot.innerHTML = `<pre>${JSON.stringify(managerGroups, null, 2)}</pre>`\n\tdocument.body.appendChild(root)\n\nsrc/people.js\n\n\tconst people = [\n\t  {\n\t    manager: \"Jen\",\n\t    name: \"Bob\"\n\t  },\n\t  {\n\t    manager: \"Jen\",\n\t    name: \"Sue\"\n\t  },\n\t  {\n\t    manager: \"Bob\",\n\t    name: \"Shirley\"\n\t  }\n\t]\n\t\n\texport default people\n\n运行**npm run develop**启动Webpack并刷新**index.html**。 您应该看到按管理器分组的一组人员打印到屏幕上。\n\n注意：导入一个像***'es-lodash'***这样没有相对路径的模块，是从npm安装到 node_modules的模块。 你自己的模块总是需要一个像***'./people'***这样的相对路径，因此你可以区分它们。\n\n请注意，在控制台中我们的捆绑包大小已增加到**1.41 MiB**！ 这值得关注，但在这种情况下，没有理由担心。 使用**npm run build**在生产模式下编译，lodash-es中的所有未使用的lodash模块都将从bundle中删除。 删除未使用的导入的过程称为tree-shaking，并且是Webpack免费获得的。\n\n\t> npm run develop\n\t\n\tAsset      Size      Chunks                  Chunk Names\n\tbundle.js  1.41 MiB  main  [emitted]  [big]  main\n\n\n\t> npm run build\n\t\n\tAsset      Size      Chunks        Chunk Names\n\tbundle.js  16.7 KiB  0  [emitted]  main\n\n## 装载 ##\n\n加载程序允许您在导入文件时运行预处理程序。 这允许您将静态资源捆绑到JavaScript之外，但让我们看看在首先加载**.js**模块时可以做些什么。\n\n让我们通过下一代JavaScript转换器Babel运行所有**.js**文件来保持代码的现代化：\n\t\n\tnpm install --save-dev \"babel-loader@^8.0.0-beta\" @babel/core @babel/preset-env\n\nwebpack.config.js\n\n\tconst path = require('path')\n\t\n\t  module.exports = {\n\t    entry: './src/index.js',\n\t    output: {\n\t      filename: 'bundle.js',\n\t      path: path.resolve(__dirname, 'dist')\n\t    },\n\t   module: {\n\t     rules: [\n\t       {\n\t         test: /\\.js$/,\n\t         exclude: /(node_modules|bower_components)/,\n\t         use: {\n\t           loader: 'babel-loader',\n\t         }\n\t       }\n\t     ]\n\t   }\n\t  }\n\n.babelrc\n\n\t{\n\t  \"presets\": [\n\t    [\"@babel/env\", {\n\t      \"modules\": false\n\t    }]\n\t  ],\n\t  \"plugins\": [\"syntax-dynamic-import\"]\n\t}\n\n此配置可防止Babel将导入和导出语句转换为ES5，并启用动态导入，这个我们将在后面的“代码拆分”一节中介绍。\n\n我们现在可以自由使用现代语言功能，它们将被编译为在所有浏览器中运行的ES5。\n\n## Sass ##\n\nLoaders可以链接在一起进行一系列变换。 从我们的JavaScript导入Sass可以较好地演示它是如何工作的：\n\t\n\tnpm install --save-dev style-loader css-loader sass-loader node-sass\n\nwebpack.config.js\n\n\t module.exports = {\n    ...\n    module: {\n      rules: [\n        ...\n\t       {\n\t         test: /\\.scss$/,\n\t         use: [{\n\t           loader: 'style-loader'\n\t         }, {\n\t           loader: 'css-loader'\n\t         }, {\n\t           loader: 'sass-loader'\n\t         }]\n\t       }\n\t      ]\n\t    }\n\t  }\n\n这些加载器以相反的顺序处理:\n\n* sass-loader将Sass转换为CSS。\n* css-loader将CSS解析为JavaScript并解析任何依赖项。\n* style-loader将我们的CSS输出到文档中的<style\\>标记中。\n\n您可以将这些视为函数调用。 一个加载器的输出作为输入提供给下一个：\n\n\tstyleLoader(cssLoader(sassLoader(\"source\")))\n\n让我们添加一个Sass源文件，import是一个模块。\n\nsrc/style.scss\n\n\t$bluegrey: #2b3a42;\n\t\n\tpre {\n\t  padding: 8px 16px;\n\t  background: $bluegrey;\n\t  color: #e1e6e9;\n\t  font-family: Menlo, Courier, monospace;\n\t  font-size: 13px;\n\t  line-height: 1.5;\n\t  text-shadow: 0 1px 0 rgba(23, 31, 35, 0.5);\n\t  border-radius: 3px;\n\t}\n\nsrc/index.js\n\n\timport { groupBy } from 'lodash-es'\n\timport people from './people'\n\t\n\timport './style.scss'\n\t\n\t  ...\n\n使用Ctrl + C和npm run develop重新启动构建。 在浏览器中刷新index.html，您应该看到一些样式。\n\n## JS中的样式表 ##\n\n我们刚从JavaScript中导入了一个Sass文件作为模块。\n\n打开dist / bundle.js并搜索“pre {”。 实际上，我们的Sass已被编译为一串CSS并在我们的包中保存为模块。 当我们将这个模块导入JavaScript时，style-loader将字符串输出到嵌入的<style\\>标记中。\n\n你为什么需要做这样的事？\n\n我不会在这里深入研究这个主题，但这里有几个理由需要考虑：\n\n* 您可能希望包含在项目中的JavaScript组件可能依赖于其他资源才能正常运行（HTML，CSS，图像，SVG）。 如果这些都可以捆绑在一起，则导入和使用起来要容易得多。\n* 消除Dead code：当代码不再导入JS组件时，也不再导入CSS。 生成的包只会包含执行某些操作的代码。\n* CSS模块：CSS的全局命名空间使得很难确信对CSS的更改不会产生任何副作用。 CSS模块通过设置CSS默认本地并显示您可以在JavaScript中引用的唯一类名来解决该问题。\n* 通过巧妙的方式捆绑/拆分代码来减少HTTP请求的数量。\n\n## 图片 ##\n我们将看到的最后一个加载器示例是使用文件加载器处理图像。\n\n在标准HTML文档中，当浏览器遇到img标记或具有background-image属性的元素时，将获取图像。 使用Webpack，您可以在小图像的情况下通过将图像源作为字符串存储在JavaScript中来优化它。 通过执行此操作，您可以预加载它们，浏览器不必在以后使用单独的请求获取它们：\n\n\tnpm install --save-dev file-loader\n\nwebpack.config.js\n\t\n\tmodule.exports = {\n\t    ...\n\t    module: {\n\t      rules: [\n\t        ...\n\t       {\n\t         test: /\\.(png|svg|jpg|gif)$/,\n\t         use: [\n\t           {\n\t             loader: 'file-loader'\n\t           }\n\t         ]\n\t       }\n\t      ]\n\t    }\n\t  }\n\n用以下命令下载一个测试图像：\n\n\t\tcurl https://raw.githubusercontent.com/sitepoint-editors/webpack-demo/master/src/code.png --output src/code.png\n\n使用Ctrl + C和npm run develop重新启动构建，您现在可以将图像作为模块导入！\n\nsrc/index.js\n\n\timport { groupBy } from 'lodash-es'\n\timport people from './people'\n\t\n\timport './style.scss'\n\timport './image-example'\n\t\n\t  ...\n\n\nsrc/image-example.js\n\n\timport codeURL from \"./code.png\"\n\t\n\tconst img = document.createElement(\"img\")\n\timg.src = codeURL\n\timg.style = \"background: #2B3A42; padding: 20px\"\n\timg.width = 32\n\tdocument.body.appendChild(img)\n\n这将包括一个图像，其中src属性包含图像本身的数据URI：\n\n\t<img src=\"data:image/png;base64,iVBO...\" style=\"background: #2B3A42; padding: 20px\" width=\"32\">\n\n我们的CSS中的背景图像也由文件加载器处理。\n\nsrc/style.scss\n\n\t$bluegrey: #2b3a42;\n\t\n\t  pre {\n\t    padding: 8px 16px;\n\t    background: $bluegrey;\n\t    background: $bluegrey url(\"code.png\") no-repeat center center / 32px 32px;\n\t    color: #e1e6e9;\n\t    font-family: Menlo, Courier, monospace;\n\t    font-size: 13px;\n\t    line-height: 1.5;\n\t    text-shadow: 0 1px 0 rgba(23, 31, 35, 0.5);\n\t    border-radius: 3px;\n\t  }\n\n在文档中查看更多Loaders示例：\n\n* [加载字体](https://webpack.js.org/guides/asset-management/#loading-fonts)\n* [加载数据](https://webpack.js.org/guides/asset-management/#loading-data)\n\n## 依赖图 Dependency Graph##\n\n您现在应该能够看到加载器如何帮助您在资源中构建依赖关系树。 这就是Webpack主页上的图像所展示的内容。\n\n![](https://dab1nmslvvntp.cloudfront.net/wp-content/uploads/2017/01/1484692838webpack-dependency-tree.png)\n\n尽管JavaScript是切入点，但Webpack明白您的其他资源类型（如HTML，CSS和SVG）各自具有自己的依赖关系，这应该被视为构建过程的一部分。\n\n## 代码拆分 ##\n\nWebpack文档中写到：\n\n>代码拆分是Webpack最引人注目的功能之一。 此功能允许您将代码拆分为各种捆绑包，然后可以按需或并行加载。 它可用于实现更小的捆绑并控制资源负载优先级，如果使用得当，可能会对加载时间产生重大影响。\n\n到目前为止，我们只看到了一个入口点 - **src / index.js** - 和一个输出包 - dist / bundle.js。 当您的应用程序增长时，您需要将其拆分，以便在开始时不会下载整个代码库。 一种好的方法是使用Code Splitting和Lazy Loading来按需获取内容，因为代码路径需要它们。\n\n我们通过添加一个“聊天”模块来证明这一点，该模块在有人与之交互时被提取和初始化。 我们将创建一个新的入口点并为其命名，我们还将使输出的文件名动态，因此每个块的不同。\n\nwebpack.config.js\n\n\t const path = require('path')\n\t\n\t  module.exports = {\n\t   entry: './src/index.js',\n\t   entry: {\n\t     app: './src/app.js'\n\t   },\n\t   output: {\n\t     filename: 'bundle.js',\n\t     filename: '[name].bundle.js',\n\t     path: path.resolve(__dirname, 'dist')\n\t    },\n\t    ...\n\t  }\n\nsrc/app.js\n\n\timport './app.scss'\n\t\n\tconst button = document.createElement(\"button\")\n\tbutton.textContent = 'Open chat'\n\tdocument.body.appendChild(button)\n\t\n\tbutton.onclick = () => {\n\t  import(/* webpackChunkName: \"chat\" */ \"./chat\").then(chat => {\n\t    chat.init()\n\t  })\n\t}\n\nsrc/chat.js\n\n\timport people from \"./people\"\n\t\n\texport function init() {\n\t  const root = document.createElement(\"div\")\n\t  root.innerHTML = `<p>There are ${people.length} people in the room.</p>`\n\t  document.body.appendChild(root)\n\t}\n\nsrc/app.scss\n\n\tbutton {\n\t  padding: 10px;\n\t  background: #24b47e;\n\t  border: 1px solid rgba(#000, .1);\n\t  border-width: 1px 1px 3px;\n\t  border-radius: 3px;\n\t  font: inherit;\n\t  color: #fff;\n\t  cursor: pointer;\n\t  text-shadow: 0 1px 0 rgba(#000, .3), 0 1px 1px rgba(#000, .2);\n\t}\n\n注意：尽管*/ * webpackChunkName * /* comment为包提供了名称，但此语法不是特定于Webpack的。 它是动态导入的建议语法，旨在直接在浏览器中支持。\n\n我们运行npm run build并查看它生成的内容：\n\n\tAsset           Size       Chunks        Chunk Names\n\tchat.bundle.js  377 bytes  0  [emitted]  chat\n\tapp.bundle.js   7.65 KiB   1  [emitted]  app\n\n由于我们的条目包已经更改，我们还需要更新它的路径。\n\ndist/index.html\n\n\t<!doctype html>\n\t  <html>\n\t    <head>\n\t      <title>Hello Webpack</title>\n\t    </head>\n\t    <body>\n\t    <script src=\"bundle.js\"></script>\n\t    <script src=\"app.bundle.js\"></script>\n\t    </body>\n\t  </html>\n\n我们从dist目录启动一个服务器，看看这个实际应用：\n\n\tcd dist\n\tnpx serve\n\n在浏览器中打开http://localhost:5000，看看会发生什么。 最初只获取bundle.js。 单击该按钮时，将导入并初始化聊天模块。\n![](https://dab1nmslvvntp.cloudfront.net/wp-content/uploads/2018/03/1521906882lazy-loading.png)\n\n只需很少的工作，我们就可以在我们的应用程序中添加动态代码拆分和延迟加载模块。 这是构建高性能Web应用程序的一个很好的起点。\n\n## 插件 ##\n\n当加载器对单个文件进行转换时，插件可以在更大的代码块上运行。\n\n现在我们正在打包代码，外部模块和静态资产，我们的包将会迅速增长。 插件可以帮助我们以巧妙的方式分割代码并优化生产。\n\n在不知情的情况下，我们实际上已经使用了许多默认的Webpack插件“模式”\n\n发展\n\n* 提供process.env.NODE_ENV，其值为“development”\n* NamedModulesPlugin\n\n生产\n\n* 提供process.env.NODE_ENV，其值为“production”\n* UglifyJsPlugin\n* ModuleConcatenationPlugin\n* NoEmitOnErrorsPlugin\n\n## 产品 ##\n\n在添加其他插件之前，我们首先拆分我们的配置，以便我们可以应用特定于每个环境的插件。\n\n将webpack.config.js重命名为webpack.common.js并添加用于开发和生产的配置文件。\n\n\t- |- webpack.config.js\n\t+ |- webpack.common.js\n\t+ |- webpack.dev.js\n\t+ |- webpack.prod.js\n\n我们将使用webpack-merge将我们的公共配置与特定于环境的配置相结合：\n\n\tnpm install --save-dev webpack-merge\n\nwebpack.dev.js\n\n\tconst merge = require('webpack-merge')\n\tconst common = require('./webpack.common.js')\n\t\n\tmodule.exports = merge(common, {\n\t  mode: 'development'\n\t})\n\nwebpack.prod.js\n\n\tconst merge = require('webpack-merge')\n\tconst common = require('./webpack.common.js')\n\t\n\tmodule.exports = merge(common, {\n\t  mode: 'production'\n\t})\n\npackage.json\n\n\t \"scripts\": {\n\t    \"develop\": \"webpack --watch --mode development\",\n\t    \"build\": \"webpack --mode production\"\n\t    \"develop\": \"webpack --watch --config webpack.dev.js\",\n\t    \"build\": \"webpack --config webpack.prod.js\"\n\t   },\n\n现在我们可以将特定于开发的插件添加到webpack.dev.js和webpack.prod.js中特定于生产的插件中。\n\n## 拆分CSS ##\n\n在使用ExtractTextWebpackPlugin捆绑生产时，最好将CSS与JavaScript分开。\n\n当前的.scss加载器非常适合开发，所以我们将把它们从webpack.common.js移到webpack.dev.js中，并将ExtractTextWebpackPlugin添加到webpack.prod.js中。\n\n\tnpm install --save-dev extract-text-webpack-plugin@4.0.0-beta.0\n\nwebpack.common.js\n\n\t ...\n\t  module.exports = {\n\t    ...\n\t    module: {\n\t      rules: [\n\t        ...\n\t-       {\n\t-         test: /\\.scss$/,\n\t-         use: [\n\t-           {\n\t-             loader: 'style-loader'\n\t-           }, {\n\t-             loader: 'css-loader'\n\t-           }, {\n\t-             loader: 'sass-loader'\n\t-           }\n\t-         ]\n\t-       },\n\t        ...\n\t      ]\n\t    }\n\t  }\n\nwebpack.dev.js\n\n\t  const merge = require('webpack-merge')\n\t+ const ExtractTextPlugin = require('extract-text-webpack-plugin')\n\t  const common = require('./webpack.common.js')\n\t\n\t  module.exports = merge(common, {\n\t    mode: 'production',\n\t    module: {\n\t     rules: [\n          {\n\t         test: /\\.scss$/,\n\t         use: ExtractTextPlugin.extract({\n\t           fallback: 'style-loader',\n\t           use: ['css-loader', 'sass-loader']\n\t         })\n\t       }\n\t     ]\n\t   },\n\t   plugins: [\n\t     new ExtractTextPlugin('style.css')\n\t   ]\n\t  })\n\n我们来比较两个构建脚本的输出：\n\n\t> npm run develop\n\t\n\tAsset           Size      Chunks           Chunk Names\n\tapp.bundle.js   28.5 KiB  app   [emitted]  app\n\tchat.bundle.js  1.4 KiB   chat  [emitted]  chat\n\n\t> npm run build\n\t\n\tAsset           Size       Chunks        Chunk Names\n\tchat.bundle.js  375 bytes  0  [emitted]  chat\n\tapp.bundle.js   1.82 KiB   1  [emitted]  app\n\tstyle.css       424 bytes  1  [emitted]  app\n\n现在CSS被从JavaScript包中提取出来用于生产，我们需要从我们的HTML <link\\>到它。\n\ndist/index.html\n\n\t<!DOCTYPE html>\n\t  <html>\n\t    <head>\n\t      <meta charset=\"UTF-8\">\n\t      <title>Code Splitting</title>\n\t      <link href=\"style.css\" rel=\"stylesheet\">\n\t    </head>\n\t    <body>\n\t      <script type=\"text/javascript\" src=\"app.bundle.js\"></script>\n\t    </body>\n\t  </html>\n\n这允许在浏览器中并行下载CSS和JavaScript，因此加载速度比单个捆绑包更快。 它还允许在JavaScript完成下载之前显示样式。\n\n## 生成HTML ##\n\n每当我们的输出发生变化时，我们必须不断更新index.html以引用新的文件路径。 这正是html-webpack-plugin自动为我们创建的。\n\n我们也可以在每次构建之前同时添加clean-webpack-plugin来清除/dist目录。\n\n\tnpm install --save-dev html-webpack-plugin clean-webpack-plugin\n\nwebpack.common.js\n\n\t const path = require('path')\n\t const CleanWebpackPlugin = require('clean-webpack-plugin');\n\t const HtmlWebpackPlugin = require('html-webpack-plugin');\n\t\n\t  module.exports = {\n\t    ...\n\t   plugins: [\n\t     new CleanWebpackPlugin(['dist']),\n\t     new HtmlWebpackPlugin({\n\t       title: 'My killer app'\n\t     })\n\t   ]\n\t  }\n\n现在每次我们建立时，dist都会被清除掉。 我们现在也会看到index.html输出，以及我们的入口包的正确路径。\n\n运行npm run develop会产生以下结果：\n\n\t<!DOCTYPE html>\n\t<html>\n\t  <head>\n\t    <meta charset=\"UTF-8\">\n\t    <title>My killer app</title>\n\t  </head>\n\t  <body>\n\t    <script type=\"text/javascript\" src=\"app.bundle.js\"></script>\n\t  </body>\n\t</html>\n\n而npm run build产生了这个：\n\n\t<!DOCTYPE html>\n\t<html>\n\t  <head>\n\t    <meta charset=\"UTF-8\">\n\t    <title>My killer app</title>\n\t    <link href=\"style.css\" rel=\"stylesheet\">\n\t  </head>\n\t  <body>\n\t    <script type=\"text/javascript\" src=\"app.bundle.js\"></script>\n\t  </body>\n\t</html>\n\n## 发展 ##\n\nwebpack-dev-server为您提供了一个简单的Web服务器，并为您提供实时重新加载，因此您无需手动刷新页面即可查看更改。\n\n\tnpm install --save-dev webpack-dev-server\n\npackage.json\n\n\t{\n\t    ...\n\t    \"scripts\": {\n\t     \"develop\": \"webpack --watch --config webpack.dev.js\",\n\t     \"develop\": \"webpack-dev-server --config webpack.dev.js\",\n\t    }\n\t    ...\n\t  }\n\n\t> npm run develop\n\t\n\t ｢wds｣: Project is running at http://localhost:8080/\n\t ｢wds｣: webpack output is served from /\n\n在浏览器中打开http://localhost:8080/并对其中一个JavaScript或CSS文件进行更改。 您应该看到它自动构建和刷新。\n\n## HotModuleReplacement ##\n\nHotModuleReplacement插件比Live Reloading更进一步，并在运行时交换模块而无需刷新。 正确配置后，这可以节省开发单页应用程序的大量时间。 如果页面中有很多状态，则可以对组件进行增量更改，只更换和更新已更改的模块。\n\nwebpack.dev.js\n\n\t  const webpack = require('webpack')\n\t  const merge = require('webpack-merge')\n\t  const common = require('./webpack.common.js')\n\t\n\t  module.exports = merge(common, {\n\t    mode: 'development',\n\t   devServer: {\n\t     hot: true\n\t   },\n\t   plugins: [\n\t     new webpack.HotModuleReplacementPlugin()\n\t   ],\n\t    ...\n\t  }\n\n现在我们需要从代码中接受更改的模块来重新初始化事物。\n\nsrc/app.js\n\n\t if (module.hot) {\n\t   module.hot.accept()\n\t }\n\t\n\t  ...\n\n注意：启用热模块替换时，module.hot设置为true以进行开发，false设置为生产，因此这些将从捆绑中剥离。\n\n重新启动构建，看看执行以下操作时会发生什么：\n\n* 单击打开聊天\n* 将新人添加到people.js模块\n* 再次单击“打开聊天”\n\n![](https://dab1nmslvvntp.cloudfront.net/wp-content/uploads/2018/03/1521906879hmr.png)\n\n这是发生了什么：\n\n1. 单击“打开聊天”时，将获取并初始化chat.js模块\n2. HMR检测perple.js何时被修改\n3. index.js中的module.hot.accept（）会导致替换此条目块加载的所有模块\n4. 再次单击“打开聊天”时，将使用更新模块中的代码运行chat.init（）。\n\n## CSS替换 ##\n\n让我们将按钮颜色更改为红色，看看会发生什么：\n\n\tsrc/app.scss\n\t\n\t  button {\n\t    ...\n\t   background: #24b47e;\n\t   background: red;\n\t    ...\n\t  }\n\n![](https://dab1nmslvvntp.cloudfront.net/wp-content/uploads/2018/03/1521906881hmr2.png)\n\n现在我们可以看到我们的样式的即时更新，而不会丢失任何状态。这是一个大大改善的开发人员体验！感觉就像未来。\n\n## HTTP/2 ##\n\n使用像Webpack这样的module bundler的主要好处之一是它可以帮助您控制资源的构建方式，然后在客户端上获取，从而帮助您提高性能。多年来，连接文件以减少需要在客户端上进行的请求数量被认为是最佳实践。这仍然有效，但HTTP/2现在允许在单个请求中传递多个文件，因此连接不再是银弹。您的应用程序实际上可能会受益于单独缓存许多小文件。然后，客户端可以获取单个已更改的模块，而不必再次获取具有大部分相同内容的整个包。\n\nWebpack的创建者Tobias Koppers撰写了一篇内容丰富的文章，解释了为什么捆绑仍然很重要，即使在HTTP/2时代也是如此。\n\n在Webpack和HTTP / 2上阅读更多相关信息。\n\n## 给你的话 ##\n\n我希望你已经发现Webpack的这个介绍很有帮助，并且能够开始使用它并产生很大的效果。可能需要一些时间来围绕Webpack的配置，加载器和插件，但了解这个工具如何工作将会有所回报。\n\nWebpack 4的文档目前正在进行中，但实际上很好地组合在一起。我强烈建议您阅读概念和指南以获取更多信息。以下是您可能感兴趣的一些其他主题：\n\n* [源地图开发](https://webpack.js.org/guides/development/#using-source-maps)\n* [生产的源地图](https://webpack.js.org/guides/production/#source-mapping)\n* [缓存破坏与散列文件名](https://webpack.js.org/guides/caching/)\n* [拆分供应商包](https://webpack.js.org/plugins/commons-chunk-plugin/#explicit-vendor-chunk)\n\nWebpack 4是您选择的module bundler吗？请在下面的评论中告诉我。\n\n\n\n\n\n\n\n\n\n\n","slug":"WEBPACK/Webpack4及模块绑定入门手册","published":1,"updated":"2018-07-10T02:18:58.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlhtwxex0010xcl51vlvui3j","content":"<p><a href=\"https://www.sitepoint.com/beginners-guide-webpack-module-bundling/\" target=\"_blank\" rel=\"noopener\">Webpack4及模块绑定入门手册</a></p>\n<p>本文在我们的书《现代JavaScript工具和技能》中有所介绍。 让我们一起熟悉支持现代JavaScript开发的基本工具。</p>\n<a id=\"more\"></a>\n<p>Webpack4 文档中说到：</p>\n<blockquote>\n<p>Webpack是一个module bundler。 它的主要目的是捆绑JavaScript文件以便在浏览器中使用，但它也能够转换，捆绑或打包任何资源。</p>\n</blockquote>\n<p>Webpack已成为现代Web开发最重要的工具之一。 它主要是JavaScript的module bundler，但它可以用来转换所有前端资源，如HTML，CSS，甚至图像。 它可以让您更好地控制应用程序正在进行的HTTP请求的数量，并允许您使用其他类型的这些资源（例如，Pug，Sass和ES8）。 Webpack还允许您轻松地从npm使用包。</p>\n<p>本文面向那些刚接触Webpack的人，将介绍初始设置和配置，模块，加载器（loaders），插件，代码拆分和热模块更换。 如果您发现视频教程很有帮助，我强烈推荐Glen Maddern的<strong>Webpack from First Principles</strong> 作为起点，了解Webpack的特殊之处。 它现在有点旧了，但原则仍然相同，这是一个很好的介绍。</p>\n<p>要在家中进行操作，您需要安装Node.js. 您也可以从我们的GitHub仓库下载演示应用程序。</p>\n<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><p>让我们用npm初始化一个新项目并安装webpack和webpack-cli：</p>\n<pre><code>mkdir webpack-demo &amp;&amp; cd webpack-demo\nnpm init -y\nnpm install --save-dev webpack webpack-cli\n</code></pre><p>接下来我们将创建下面文件结构和内容：</p>\n<pre><code>webpack-demo\n|- package.json\n|- webpack.config.js\n|- /src\n |- index.js\n|- /dist\n |- index.html\n</code></pre><p>dist/index.html</p>\n<pre><code>&lt;!doctype html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;Hello Webpack&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>src/index.js</p>\n<pre><code>const root = document.createElement(&quot;div&quot;)\nroot.innerHTML = `&lt;p&gt;Hello Webpack.&lt;/p&gt;`\ndocument.body.appendChild(root)\n</code></pre><p>webpack.config.js</p>\n<pre><code>const path = require(&#39;path&#39;)\n\nmodule.exports = {\n  entry: &#39;./src/index.js&#39;,\n  output: {\n    filename: &#39;bundle.js&#39;,\n    path: path.resolve(__dirname, &#39;dist&#39;)\n  }\n}\n</code></pre><p>这告诉Webpack在我们的入口点<strong>src / index.js</strong>中编译代码并在<strong>/dist/bundle.js</strong>中输出一个bundle。 我们来添加一个用于运行Webpack的npm脚本。</p>\n<p>package.json</p>\n<pre><code> {\n    ...\n    &quot;scripts&quot;: {\n     &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,\n     &quot;develop&quot;: &quot;webpack --mode development --watch&quot;,\n     &quot;build&quot;: &quot;webpack --mode production&quot;\n    },\n    ...\n  }\n</code></pre><p>使用npm run develop命令，我们可以创建我们的第一个包！</p>\n<pre><code>Asset      Size      Chunks           Chunk Names\nbundle.js  2.92 KiB  main  [emitted]  main\n</code></pre><p>您现在应该可以在浏览器中加载dist / index.html并看到“Hello Webpack”。</p>\n<p>打开<strong>dist / bundle.js</strong>以查看Webpack的功能。 顶部是Webpack的模块引导代码，底部是我们的模块。 你可能对此还没有很深刻的印象，但是如果你已经走到这一步，你现在可以开始使用ES模块，而Webpack将能够生成一个适用于所有浏览器的生产包。</p>\n<p>使用Ctrl + C重新编译并运行npm run build以在生产模式下编译我们的bundle。</p>\n<pre><code>Asset      Size       Chunks           Chunk Names\nbundle.js  647 bytes  main  [emitted]  main\n</code></pre><p>请注意，捆绑包大小已从2.92 KiB降至647字节。</p>\n<p>再看一下<strong>dist / bundle.js</strong>，你会看到一堆丑陋的代码。 我们的软件包已经用UglifyJS缩小了：代码将运行完全相同，但它是以尽可能小的文件大小完成的。</p>\n<ul>\n<li><ul>\n<li><strong>模式开发</strong>优化了构建速度和调试</li>\n</ul>\n</li>\n<li><ul>\n<li><strong>模式生产</strong>优化了运行时的执行速度和输出文件大小。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h2><p>使用ES模块，您可以将大型程序拆分为许多小型自包含程序。</p>\n<p>创造性地，Webpack知道如何使用导入和导出语句来使用ES模块。 举个例子，让我们现在通过安装lodash-es并添加第二个模块来尝试这个：</p>\n<pre><code>npm install --save-dev lodash-es\n</code></pre><p>src/index.js</p>\n<pre><code>import { groupBy } from &quot;lodash-es&quot;\nimport people from &quot;./people&quot;\n\nconst managerGroups = groupBy(people, &quot;manager&quot;)\n\nconst root = document.createElement(&quot;div&quot;)\nroot.innerHTML = `&lt;pre&gt;${JSON.stringify(managerGroups, null, 2)}&lt;/pre&gt;`\ndocument.body.appendChild(root)\n</code></pre><p>src/people.js</p>\n<pre><code>const people = [\n  {\n    manager: &quot;Jen&quot;,\n    name: &quot;Bob&quot;\n  },\n  {\n    manager: &quot;Jen&quot;,\n    name: &quot;Sue&quot;\n  },\n  {\n    manager: &quot;Bob&quot;,\n    name: &quot;Shirley&quot;\n  }\n]\n\nexport default people\n</code></pre><p>运行<strong>npm run develop</strong>启动Webpack并刷新<strong>index.html</strong>。 您应该看到按管理器分组的一组人员打印到屏幕上。</p>\n<p>注意：导入一个像<strong><em>‘es-lodash’</em></strong>这样没有相对路径的模块，是从npm安装到 node_modules的模块。 你自己的模块总是需要一个像<strong><em>‘./people’</em></strong>这样的相对路径，因此你可以区分它们。</p>\n<p>请注意，在控制台中我们的捆绑包大小已增加到<strong>1.41 MiB</strong>！ 这值得关注，但在这种情况下，没有理由担心。 使用<strong>npm run build</strong>在生产模式下编译，lodash-es中的所有未使用的lodash模块都将从bundle中删除。 删除未使用的导入的过程称为tree-shaking，并且是Webpack免费获得的。</p>\n<pre><code>&gt; npm run develop\n\nAsset      Size      Chunks                  Chunk Names\nbundle.js  1.41 MiB  main  [emitted]  [big]  main\n\n\n&gt; npm run build\n\nAsset      Size      Chunks        Chunk Names\nbundle.js  16.7 KiB  0  [emitted]  main\n</code></pre><h2 id=\"装载\"><a href=\"#装载\" class=\"headerlink\" title=\"装载\"></a>装载</h2><p>加载程序允许您在导入文件时运行预处理程序。 这允许您将静态资源捆绑到JavaScript之外，但让我们看看在首先加载<strong>.js</strong>模块时可以做些什么。</p>\n<p>让我们通过下一代JavaScript转换器Babel运行所有<strong>.js</strong>文件来保持代码的现代化：</p>\n<pre><code>npm install --save-dev &quot;babel-loader@^8.0.0-beta&quot; @babel/core @babel/preset-env\n</code></pre><p>webpack.config.js</p>\n<pre><code>const path = require(&#39;path&#39;)\n\n  module.exports = {\n    entry: &#39;./src/index.js&#39;,\n    output: {\n      filename: &#39;bundle.js&#39;,\n      path: path.resolve(__dirname, &#39;dist&#39;)\n    },\n   module: {\n     rules: [\n       {\n         test: /\\.js$/,\n         exclude: /(node_modules|bower_components)/,\n         use: {\n           loader: &#39;babel-loader&#39;,\n         }\n       }\n     ]\n   }\n  }\n</code></pre><p>.babelrc</p>\n<pre><code>{\n  &quot;presets&quot;: [\n    [&quot;@babel/env&quot;, {\n      &quot;modules&quot;: false\n    }]\n  ],\n  &quot;plugins&quot;: [&quot;syntax-dynamic-import&quot;]\n}\n</code></pre><p>此配置可防止Babel将导入和导出语句转换为ES5，并启用动态导入，这个我们将在后面的“代码拆分”一节中介绍。</p>\n<p>我们现在可以自由使用现代语言功能，它们将被编译为在所有浏览器中运行的ES5。</p>\n<h2 id=\"Sass\"><a href=\"#Sass\" class=\"headerlink\" title=\"Sass\"></a>Sass</h2><p>Loaders可以链接在一起进行一系列变换。 从我们的JavaScript导入Sass可以较好地演示它是如何工作的：</p>\n<pre><code>npm install --save-dev style-loader css-loader sass-loader node-sass\n</code></pre><p>webpack.config.js</p>\n<pre><code> module.exports = {\n...\nmodule: {\n  rules: [\n    ...\n       {\n         test: /\\.scss$/,\n         use: [{\n           loader: &#39;style-loader&#39;\n         }, {\n           loader: &#39;css-loader&#39;\n         }, {\n           loader: &#39;sass-loader&#39;\n         }]\n       }\n      ]\n    }\n  }\n</code></pre><p>这些加载器以相反的顺序处理:</p>\n<ul>\n<li>sass-loader将Sass转换为CSS。</li>\n<li>css-loader将CSS解析为JavaScript并解析任何依赖项。</li>\n<li>style-loader将我们的CSS输出到文档中的&lt;style>标记中。</li>\n</ul>\n<p>您可以将这些视为函数调用。 一个加载器的输出作为输入提供给下一个：</p>\n<pre><code>styleLoader(cssLoader(sassLoader(&quot;source&quot;)))\n</code></pre><p>让我们添加一个Sass源文件，import是一个模块。</p>\n<p>src/style.scss</p>\n<pre><code>$bluegrey: #2b3a42;\n\npre {\n  padding: 8px 16px;\n  background: $bluegrey;\n  color: #e1e6e9;\n  font-family: Menlo, Courier, monospace;\n  font-size: 13px;\n  line-height: 1.5;\n  text-shadow: 0 1px 0 rgba(23, 31, 35, 0.5);\n  border-radius: 3px;\n}\n</code></pre><p>src/index.js</p>\n<pre><code>import { groupBy } from &#39;lodash-es&#39;\nimport people from &#39;./people&#39;\n\nimport &#39;./style.scss&#39;\n\n  ...\n</code></pre><p>使用Ctrl + C和npm run develop重新启动构建。 在浏览器中刷新index.html，您应该看到一些样式。</p>\n<h2 id=\"JS中的样式表\"><a href=\"#JS中的样式表\" class=\"headerlink\" title=\"JS中的样式表\"></a>JS中的样式表</h2><p>我们刚从JavaScript中导入了一个Sass文件作为模块。</p>\n<p>打开dist / bundle.js并搜索“pre {”。 实际上，我们的Sass已被编译为一串CSS并在我们的包中保存为模块。 当我们将这个模块导入JavaScript时，style-loader将字符串输出到嵌入的&lt;style>标记中。</p>\n<p>你为什么需要做这样的事？</p>\n<p>我不会在这里深入研究这个主题，但这里有几个理由需要考虑：</p>\n<ul>\n<li>您可能希望包含在项目中的JavaScript组件可能依赖于其他资源才能正常运行（HTML，CSS，图像，SVG）。 如果这些都可以捆绑在一起，则导入和使用起来要容易得多。</li>\n<li>消除Dead code：当代码不再导入JS组件时，也不再导入CSS。 生成的包只会包含执行某些操作的代码。</li>\n<li>CSS模块：CSS的全局命名空间使得很难确信对CSS的更改不会产生任何副作用。 CSS模块通过设置CSS默认本地并显示您可以在JavaScript中引用的唯一类名来解决该问题。</li>\n<li>通过巧妙的方式捆绑/拆分代码来减少HTTP请求的数量。</li>\n</ul>\n<h2 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h2><p>我们将看到的最后一个加载器示例是使用文件加载器处理图像。</p>\n<p>在标准HTML文档中，当浏览器遇到img标记或具有background-image属性的元素时，将获取图像。 使用Webpack，您可以在小图像的情况下通过将图像源作为字符串存储在JavaScript中来优化它。 通过执行此操作，您可以预加载它们，浏览器不必在以后使用单独的请求获取它们：</p>\n<pre><code>npm install --save-dev file-loader\n</code></pre><p>webpack.config.js</p>\n<pre><code>module.exports = {\n    ...\n    module: {\n      rules: [\n        ...\n       {\n         test: /\\.(png|svg|jpg|gif)$/,\n         use: [\n           {\n             loader: &#39;file-loader&#39;\n           }\n         ]\n       }\n      ]\n    }\n  }\n</code></pre><p>用以下命令下载一个测试图像：</p>\n<pre><code>    curl https://raw.githubusercontent.com/sitepoint-editors/webpack-demo/master/src/code.png --output src/code.png\n</code></pre><p>使用Ctrl + C和npm run develop重新启动构建，您现在可以将图像作为模块导入！</p>\n<p>src/index.js</p>\n<pre><code>import { groupBy } from &#39;lodash-es&#39;\nimport people from &#39;./people&#39;\n\nimport &#39;./style.scss&#39;\nimport &#39;./image-example&#39;\n\n  ...\n</code></pre><p>src/image-example.js</p>\n<pre><code>import codeURL from &quot;./code.png&quot;\n\nconst img = document.createElement(&quot;img&quot;)\nimg.src = codeURL\nimg.style = &quot;background: #2B3A42; padding: 20px&quot;\nimg.width = 32\ndocument.body.appendChild(img)\n</code></pre><p>这将包括一个图像，其中src属性包含图像本身的数据URI：</p>\n<pre><code>&lt;img src=&quot;data:image/png;base64,iVBO...&quot; style=&quot;background: #2B3A42; padding: 20px&quot; width=&quot;32&quot;&gt;\n</code></pre><p>我们的CSS中的背景图像也由文件加载器处理。</p>\n<p>src/style.scss</p>\n<pre><code>$bluegrey: #2b3a42;\n\n  pre {\n    padding: 8px 16px;\n    background: $bluegrey;\n    background: $bluegrey url(&quot;code.png&quot;) no-repeat center center / 32px 32px;\n    color: #e1e6e9;\n    font-family: Menlo, Courier, monospace;\n    font-size: 13px;\n    line-height: 1.5;\n    text-shadow: 0 1px 0 rgba(23, 31, 35, 0.5);\n    border-radius: 3px;\n  }\n</code></pre><p>在文档中查看更多Loaders示例：</p>\n<ul>\n<li><a href=\"https://webpack.js.org/guides/asset-management/#loading-fonts\" target=\"_blank\" rel=\"noopener\">加载字体</a></li>\n<li><a href=\"https://webpack.js.org/guides/asset-management/#loading-data\" target=\"_blank\" rel=\"noopener\">加载数据</a></li>\n</ul>\n<h2 id=\"依赖图-Dependency-Graph\"><a href=\"#依赖图-Dependency-Graph\" class=\"headerlink\" title=\"依赖图 Dependency Graph\"></a>依赖图 Dependency Graph</h2><p>您现在应该能够看到加载器如何帮助您在资源中构建依赖关系树。 这就是Webpack主页上的图像所展示的内容。</p>\n<p><img src=\"https://dab1nmslvvntp.cloudfront.net/wp-content/uploads/2017/01/1484692838webpack-dependency-tree.png\" alt=\"\"></p>\n<p>尽管JavaScript是切入点，但Webpack明白您的其他资源类型（如HTML，CSS和SVG）各自具有自己的依赖关系，这应该被视为构建过程的一部分。</p>\n<h2 id=\"代码拆分\"><a href=\"#代码拆分\" class=\"headerlink\" title=\"代码拆分\"></a>代码拆分</h2><p>Webpack文档中写到：</p>\n<blockquote>\n<p>代码拆分是Webpack最引人注目的功能之一。 此功能允许您将代码拆分为各种捆绑包，然后可以按需或并行加载。 它可用于实现更小的捆绑并控制资源负载优先级，如果使用得当，可能会对加载时间产生重大影响。</p>\n</blockquote>\n<p>到目前为止，我们只看到了一个入口点 - <strong>src / index.js</strong> - 和一个输出包 - dist / bundle.js。 当您的应用程序增长时，您需要将其拆分，以便在开始时不会下载整个代码库。 一种好的方法是使用Code Splitting和Lazy Loading来按需获取内容，因为代码路径需要它们。</p>\n<p>我们通过添加一个“聊天”模块来证明这一点，该模块在有人与之交互时被提取和初始化。 我们将创建一个新的入口点并为其命名，我们还将使输出的文件名动态，因此每个块的不同。</p>\n<p>webpack.config.js</p>\n<pre><code> const path = require(&#39;path&#39;)\n\n  module.exports = {\n   entry: &#39;./src/index.js&#39;,\n   entry: {\n     app: &#39;./src/app.js&#39;\n   },\n   output: {\n     filename: &#39;bundle.js&#39;,\n     filename: &#39;[name].bundle.js&#39;,\n     path: path.resolve(__dirname, &#39;dist&#39;)\n    },\n    ...\n  }\n</code></pre><p>src/app.js</p>\n<pre><code>import &#39;./app.scss&#39;\n\nconst button = document.createElement(&quot;button&quot;)\nbutton.textContent = &#39;Open chat&#39;\ndocument.body.appendChild(button)\n\nbutton.onclick = () =&gt; {\n  import(/* webpackChunkName: &quot;chat&quot; */ &quot;./chat&quot;).then(chat =&gt; {\n    chat.init()\n  })\n}\n</code></pre><p>src/chat.js</p>\n<pre><code>import people from &quot;./people&quot;\n\nexport function init() {\n  const root = document.createElement(&quot;div&quot;)\n  root.innerHTML = `&lt;p&gt;There are ${people.length} people in the room.&lt;/p&gt;`\n  document.body.appendChild(root)\n}\n</code></pre><p>src/app.scss</p>\n<pre><code>button {\n  padding: 10px;\n  background: #24b47e;\n  border: 1px solid rgba(#000, .1);\n  border-width: 1px 1px 3px;\n  border-radius: 3px;\n  font: inherit;\n  color: #fff;\n  cursor: pointer;\n  text-shadow: 0 1px 0 rgba(#000, .3), 0 1px 1px rgba(#000, .2);\n}\n</code></pre><p>注意：尽管<em>/ </em> webpackChunkName <em> /</em> comment为包提供了名称，但此语法不是特定于Webpack的。 它是动态导入的建议语法，旨在直接在浏览器中支持。</p>\n<p>我们运行npm run build并查看它生成的内容：</p>\n<pre><code>Asset           Size       Chunks        Chunk Names\nchat.bundle.js  377 bytes  0  [emitted]  chat\napp.bundle.js   7.65 KiB   1  [emitted]  app\n</code></pre><p>由于我们的条目包已经更改，我们还需要更新它的路径。</p>\n<p>dist/index.html</p>\n<pre><code>&lt;!doctype html&gt;\n  &lt;html&gt;\n    &lt;head&gt;\n      &lt;title&gt;Hello Webpack&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n    &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;app.bundle.js&quot;&gt;&lt;/script&gt;\n    &lt;/body&gt;\n  &lt;/html&gt;\n</code></pre><p>我们从dist目录启动一个服务器，看看这个实际应用：</p>\n<pre><code>cd dist\nnpx serve\n</code></pre><p>在浏览器中打开<a href=\"http://localhost:5000，看看会发生什么。\" target=\"_blank\" rel=\"noopener\">http://localhost:5000，看看会发生什么。</a> 最初只获取bundle.js。 单击该按钮时，将导入并初始化聊天模块。<br><img src=\"https://dab1nmslvvntp.cloudfront.net/wp-content/uploads/2018/03/1521906882lazy-loading.png\" alt=\"\"></p>\n<p>只需很少的工作，我们就可以在我们的应用程序中添加动态代码拆分和延迟加载模块。 这是构建高性能Web应用程序的一个很好的起点。</p>\n<h2 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h2><p>当加载器对单个文件进行转换时，插件可以在更大的代码块上运行。</p>\n<p>现在我们正在打包代码，外部模块和静态资产，我们的包将会迅速增长。 插件可以帮助我们以巧妙的方式分割代码并优化生产。</p>\n<p>在不知情的情况下，我们实际上已经使用了许多默认的Webpack插件“模式”</p>\n<p>发展</p>\n<ul>\n<li>提供process.env.NODE_ENV，其值为“development”</li>\n<li>NamedModulesPlugin</li>\n</ul>\n<p>生产</p>\n<ul>\n<li>提供process.env.NODE_ENV，其值为“production”</li>\n<li>UglifyJsPlugin</li>\n<li>ModuleConcatenationPlugin</li>\n<li>NoEmitOnErrorsPlugin</li>\n</ul>\n<h2 id=\"产品\"><a href=\"#产品\" class=\"headerlink\" title=\"产品\"></a>产品</h2><p>在添加其他插件之前，我们首先拆分我们的配置，以便我们可以应用特定于每个环境的插件。</p>\n<p>将webpack.config.js重命名为webpack.common.js并添加用于开发和生产的配置文件。</p>\n<pre><code>- |- webpack.config.js\n+ |- webpack.common.js\n+ |- webpack.dev.js\n+ |- webpack.prod.js\n</code></pre><p>我们将使用webpack-merge将我们的公共配置与特定于环境的配置相结合：</p>\n<pre><code>npm install --save-dev webpack-merge\n</code></pre><p>webpack.dev.js</p>\n<pre><code>const merge = require(&#39;webpack-merge&#39;)\nconst common = require(&#39;./webpack.common.js&#39;)\n\nmodule.exports = merge(common, {\n  mode: &#39;development&#39;\n})\n</code></pre><p>webpack.prod.js</p>\n<pre><code>const merge = require(&#39;webpack-merge&#39;)\nconst common = require(&#39;./webpack.common.js&#39;)\n\nmodule.exports = merge(common, {\n  mode: &#39;production&#39;\n})\n</code></pre><p>package.json</p>\n<pre><code> &quot;scripts&quot;: {\n    &quot;develop&quot;: &quot;webpack --watch --mode development&quot;,\n    &quot;build&quot;: &quot;webpack --mode production&quot;\n    &quot;develop&quot;: &quot;webpack --watch --config webpack.dev.js&quot;,\n    &quot;build&quot;: &quot;webpack --config webpack.prod.js&quot;\n   },\n</code></pre><p>现在我们可以将特定于开发的插件添加到webpack.dev.js和webpack.prod.js中特定于生产的插件中。</p>\n<h2 id=\"拆分CSS\"><a href=\"#拆分CSS\" class=\"headerlink\" title=\"拆分CSS\"></a>拆分CSS</h2><p>在使用ExtractTextWebpackPlugin捆绑生产时，最好将CSS与JavaScript分开。</p>\n<p>当前的.scss加载器非常适合开发，所以我们将把它们从webpack.common.js移到webpack.dev.js中，并将ExtractTextWebpackPlugin添加到webpack.prod.js中。</p>\n<pre><code>npm install --save-dev extract-text-webpack-plugin@4.0.0-beta.0\n</code></pre><p>webpack.common.js</p>\n<pre><code> ...\n  module.exports = {\n    ...\n    module: {\n      rules: [\n        ...\n-       {\n-         test: /\\.scss$/,\n-         use: [\n-           {\n-             loader: &#39;style-loader&#39;\n-           }, {\n-             loader: &#39;css-loader&#39;\n-           }, {\n-             loader: &#39;sass-loader&#39;\n-           }\n-         ]\n-       },\n        ...\n      ]\n    }\n  }\n</code></pre><p>webpack.dev.js</p>\n<pre><code>  const merge = require(&#39;webpack-merge&#39;)\n+ const ExtractTextPlugin = require(&#39;extract-text-webpack-plugin&#39;)\n  const common = require(&#39;./webpack.common.js&#39;)\n\n  module.exports = merge(common, {\n    mode: &#39;production&#39;,\n    module: {\n     rules: [\n      {\n         test: /\\.scss$/,\n         use: ExtractTextPlugin.extract({\n           fallback: &#39;style-loader&#39;,\n           use: [&#39;css-loader&#39;, &#39;sass-loader&#39;]\n         })\n       }\n     ]\n   },\n   plugins: [\n     new ExtractTextPlugin(&#39;style.css&#39;)\n   ]\n  })\n</code></pre><p>我们来比较两个构建脚本的输出：</p>\n<pre><code>&gt; npm run develop\n\nAsset           Size      Chunks           Chunk Names\napp.bundle.js   28.5 KiB  app   [emitted]  app\nchat.bundle.js  1.4 KiB   chat  [emitted]  chat\n\n&gt; npm run build\n\nAsset           Size       Chunks        Chunk Names\nchat.bundle.js  375 bytes  0  [emitted]  chat\napp.bundle.js   1.82 KiB   1  [emitted]  app\nstyle.css       424 bytes  1  [emitted]  app\n</code></pre><p>现在CSS被从JavaScript包中提取出来用于生产，我们需要从我们的HTML &lt;link>到它。</p>\n<p>dist/index.html</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n  &lt;html&gt;\n    &lt;head&gt;\n      &lt;meta charset=&quot;UTF-8&quot;&gt;\n      &lt;title&gt;Code Splitting&lt;/title&gt;\n      &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n      &lt;script type=&quot;text/javascript&quot; src=&quot;app.bundle.js&quot;&gt;&lt;/script&gt;\n    &lt;/body&gt;\n  &lt;/html&gt;\n</code></pre><p>这允许在浏览器中并行下载CSS和JavaScript，因此加载速度比单个捆绑包更快。 它还允许在JavaScript完成下载之前显示样式。</p>\n<h2 id=\"生成HTML\"><a href=\"#生成HTML\" class=\"headerlink\" title=\"生成HTML\"></a>生成HTML</h2><p>每当我们的输出发生变化时，我们必须不断更新index.html以引用新的文件路径。 这正是html-webpack-plugin自动为我们创建的。</p>\n<p>我们也可以在每次构建之前同时添加clean-webpack-plugin来清除/dist目录。</p>\n<pre><code>npm install --save-dev html-webpack-plugin clean-webpack-plugin\n</code></pre><p>webpack.common.js</p>\n<pre><code> const path = require(&#39;path&#39;)\n const CleanWebpackPlugin = require(&#39;clean-webpack-plugin&#39;);\n const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);\n\n  module.exports = {\n    ...\n   plugins: [\n     new CleanWebpackPlugin([&#39;dist&#39;]),\n     new HtmlWebpackPlugin({\n       title: &#39;My killer app&#39;\n     })\n   ]\n  }\n</code></pre><p>现在每次我们建立时，dist都会被清除掉。 我们现在也会看到index.html输出，以及我们的入口包的正确路径。</p>\n<p>运行npm run develop会产生以下结果：</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;My killer app&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;app.bundle.js&quot;&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>而npm run build产生了这个：</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;My killer app&lt;/title&gt;\n    &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;app.bundle.js&quot;&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><h2 id=\"发展\"><a href=\"#发展\" class=\"headerlink\" title=\"发展\"></a>发展</h2><p>webpack-dev-server为您提供了一个简单的Web服务器，并为您提供实时重新加载，因此您无需手动刷新页面即可查看更改。</p>\n<pre><code>npm install --save-dev webpack-dev-server\n</code></pre><p>package.json</p>\n<pre><code>{\n    ...\n    &quot;scripts&quot;: {\n     &quot;develop&quot;: &quot;webpack --watch --config webpack.dev.js&quot;,\n     &quot;develop&quot;: &quot;webpack-dev-server --config webpack.dev.js&quot;,\n    }\n    ...\n  }\n\n&gt; npm run develop\n\n ｢wds｣: Project is running at http://localhost:8080/\n ｢wds｣: webpack output is served from /\n</code></pre><p>在浏览器中打开<a href=\"http://localhost:8080/并对其中一个JavaScript或CSS文件进行更改。\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/并对其中一个JavaScript或CSS文件进行更改。</a> 您应该看到它自动构建和刷新。</p>\n<h2 id=\"HotModuleReplacement\"><a href=\"#HotModuleReplacement\" class=\"headerlink\" title=\"HotModuleReplacement\"></a>HotModuleReplacement</h2><p>HotModuleReplacement插件比Live Reloading更进一步，并在运行时交换模块而无需刷新。 正确配置后，这可以节省开发单页应用程序的大量时间。 如果页面中有很多状态，则可以对组件进行增量更改，只更换和更新已更改的模块。</p>\n<p>webpack.dev.js</p>\n<pre><code>  const webpack = require(&#39;webpack&#39;)\n  const merge = require(&#39;webpack-merge&#39;)\n  const common = require(&#39;./webpack.common.js&#39;)\n\n  module.exports = merge(common, {\n    mode: &#39;development&#39;,\n   devServer: {\n     hot: true\n   },\n   plugins: [\n     new webpack.HotModuleReplacementPlugin()\n   ],\n    ...\n  }\n</code></pre><p>现在我们需要从代码中接受更改的模块来重新初始化事物。</p>\n<p>src/app.js</p>\n<pre><code> if (module.hot) {\n   module.hot.accept()\n }\n\n  ...\n</code></pre><p>注意：启用热模块替换时，module.hot设置为true以进行开发，false设置为生产，因此这些将从捆绑中剥离。</p>\n<p>重新启动构建，看看执行以下操作时会发生什么：</p>\n<ul>\n<li>单击打开聊天</li>\n<li>将新人添加到people.js模块</li>\n<li>再次单击“打开聊天”</li>\n</ul>\n<p><img src=\"https://dab1nmslvvntp.cloudfront.net/wp-content/uploads/2018/03/1521906879hmr.png\" alt=\"\"></p>\n<p>这是发生了什么：</p>\n<ol>\n<li>单击“打开聊天”时，将获取并初始化chat.js模块</li>\n<li>HMR检测perple.js何时被修改</li>\n<li>index.js中的module.hot.accept（）会导致替换此条目块加载的所有模块</li>\n<li>再次单击“打开聊天”时，将使用更新模块中的代码运行chat.init（）。</li>\n</ol>\n<h2 id=\"CSS替换\"><a href=\"#CSS替换\" class=\"headerlink\" title=\"CSS替换\"></a>CSS替换</h2><p>让我们将按钮颜色更改为红色，看看会发生什么：</p>\n<pre><code>src/app.scss\n\n  button {\n    ...\n   background: #24b47e;\n   background: red;\n    ...\n  }\n</code></pre><p><img src=\"https://dab1nmslvvntp.cloudfront.net/wp-content/uploads/2018/03/1521906881hmr2.png\" alt=\"\"></p>\n<p>现在我们可以看到我们的样式的即时更新，而不会丢失任何状态。这是一个大大改善的开发人员体验！感觉就像未来。</p>\n<h2 id=\"HTTP-2\"><a href=\"#HTTP-2\" class=\"headerlink\" title=\"HTTP/2\"></a>HTTP/2</h2><p>使用像Webpack这样的module bundler的主要好处之一是它可以帮助您控制资源的构建方式，然后在客户端上获取，从而帮助您提高性能。多年来，连接文件以减少需要在客户端上进行的请求数量被认为是最佳实践。这仍然有效，但HTTP/2现在允许在单个请求中传递多个文件，因此连接不再是银弹。您的应用程序实际上可能会受益于单独缓存许多小文件。然后，客户端可以获取单个已更改的模块，而不必再次获取具有大部分相同内容的整个包。</p>\n<p>Webpack的创建者Tobias Koppers撰写了一篇内容丰富的文章，解释了为什么捆绑仍然很重要，即使在HTTP/2时代也是如此。</p>\n<p>在Webpack和HTTP / 2上阅读更多相关信息。</p>\n<h2 id=\"给你的话\"><a href=\"#给你的话\" class=\"headerlink\" title=\"给你的话\"></a>给你的话</h2><p>我希望你已经发现Webpack的这个介绍很有帮助，并且能够开始使用它并产生很大的效果。可能需要一些时间来围绕Webpack的配置，加载器和插件，但了解这个工具如何工作将会有所回报。</p>\n<p>Webpack 4的文档目前正在进行中，但实际上很好地组合在一起。我强烈建议您阅读概念和指南以获取更多信息。以下是您可能感兴趣的一些其他主题：</p>\n<ul>\n<li><a href=\"https://webpack.js.org/guides/development/#using-source-maps\" target=\"_blank\" rel=\"noopener\">源地图开发</a></li>\n<li><a href=\"https://webpack.js.org/guides/production/#source-mapping\" target=\"_blank\" rel=\"noopener\">生产的源地图</a></li>\n<li><a href=\"https://webpack.js.org/guides/caching/\" target=\"_blank\" rel=\"noopener\">缓存破坏与散列文件名</a></li>\n<li><a href=\"https://webpack.js.org/plugins/commons-chunk-plugin/#explicit-vendor-chunk\" target=\"_blank\" rel=\"noopener\">拆分供应商包</a></li>\n</ul>\n<p>Webpack 4是您选择的module bundler吗？请在下面的评论中告诉我。</p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://www.sitepoint.com/beginners-guide-webpack-module-bundling/\" target=\"_blank\" rel=\"noopener\">Webpack4及模块绑定入门手册</a></p>\n<p>本文在我们的书《现代JavaScript工具和技能》中有所介绍。 让我们一起熟悉支持现代JavaScript开发的基本工具。</p>","more":"<p>Webpack4 文档中说到：</p>\n<blockquote>\n<p>Webpack是一个module bundler。 它的主要目的是捆绑JavaScript文件以便在浏览器中使用，但它也能够转换，捆绑或打包任何资源。</p>\n</blockquote>\n<p>Webpack已成为现代Web开发最重要的工具之一。 它主要是JavaScript的module bundler，但它可以用来转换所有前端资源，如HTML，CSS，甚至图像。 它可以让您更好地控制应用程序正在进行的HTTP请求的数量，并允许您使用其他类型的这些资源（例如，Pug，Sass和ES8）。 Webpack还允许您轻松地从npm使用包。</p>\n<p>本文面向那些刚接触Webpack的人，将介绍初始设置和配置，模块，加载器（loaders），插件，代码拆分和热模块更换。 如果您发现视频教程很有帮助，我强烈推荐Glen Maddern的<strong>Webpack from First Principles</strong> 作为起点，了解Webpack的特殊之处。 它现在有点旧了，但原则仍然相同，这是一个很好的介绍。</p>\n<p>要在家中进行操作，您需要安装Node.js. 您也可以从我们的GitHub仓库下载演示应用程序。</p>\n<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><p>让我们用npm初始化一个新项目并安装webpack和webpack-cli：</p>\n<pre><code>mkdir webpack-demo &amp;&amp; cd webpack-demo\nnpm init -y\nnpm install --save-dev webpack webpack-cli\n</code></pre><p>接下来我们将创建下面文件结构和内容：</p>\n<pre><code>webpack-demo\n|- package.json\n|- webpack.config.js\n|- /src\n |- index.js\n|- /dist\n |- index.html\n</code></pre><p>dist/index.html</p>\n<pre><code>&lt;!doctype html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;Hello Webpack&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>src/index.js</p>\n<pre><code>const root = document.createElement(&quot;div&quot;)\nroot.innerHTML = `&lt;p&gt;Hello Webpack.&lt;/p&gt;`\ndocument.body.appendChild(root)\n</code></pre><p>webpack.config.js</p>\n<pre><code>const path = require(&#39;path&#39;)\n\nmodule.exports = {\n  entry: &#39;./src/index.js&#39;,\n  output: {\n    filename: &#39;bundle.js&#39;,\n    path: path.resolve(__dirname, &#39;dist&#39;)\n  }\n}\n</code></pre><p>这告诉Webpack在我们的入口点<strong>src / index.js</strong>中编译代码并在<strong>/dist/bundle.js</strong>中输出一个bundle。 我们来添加一个用于运行Webpack的npm脚本。</p>\n<p>package.json</p>\n<pre><code> {\n    ...\n    &quot;scripts&quot;: {\n     &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,\n     &quot;develop&quot;: &quot;webpack --mode development --watch&quot;,\n     &quot;build&quot;: &quot;webpack --mode production&quot;\n    },\n    ...\n  }\n</code></pre><p>使用npm run develop命令，我们可以创建我们的第一个包！</p>\n<pre><code>Asset      Size      Chunks           Chunk Names\nbundle.js  2.92 KiB  main  [emitted]  main\n</code></pre><p>您现在应该可以在浏览器中加载dist / index.html并看到“Hello Webpack”。</p>\n<p>打开<strong>dist / bundle.js</strong>以查看Webpack的功能。 顶部是Webpack的模块引导代码，底部是我们的模块。 你可能对此还没有很深刻的印象，但是如果你已经走到这一步，你现在可以开始使用ES模块，而Webpack将能够生成一个适用于所有浏览器的生产包。</p>\n<p>使用Ctrl + C重新编译并运行npm run build以在生产模式下编译我们的bundle。</p>\n<pre><code>Asset      Size       Chunks           Chunk Names\nbundle.js  647 bytes  main  [emitted]  main\n</code></pre><p>请注意，捆绑包大小已从2.92 KiB降至647字节。</p>\n<p>再看一下<strong>dist / bundle.js</strong>，你会看到一堆丑陋的代码。 我们的软件包已经用UglifyJS缩小了：代码将运行完全相同，但它是以尽可能小的文件大小完成的。</p>\n<ul>\n<li><ul>\n<li><strong>模式开发</strong>优化了构建速度和调试</li>\n</ul>\n</li>\n<li><ul>\n<li><strong>模式生产</strong>优化了运行时的执行速度和输出文件大小。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h2><p>使用ES模块，您可以将大型程序拆分为许多小型自包含程序。</p>\n<p>创造性地，Webpack知道如何使用导入和导出语句来使用ES模块。 举个例子，让我们现在通过安装lodash-es并添加第二个模块来尝试这个：</p>\n<pre><code>npm install --save-dev lodash-es\n</code></pre><p>src/index.js</p>\n<pre><code>import { groupBy } from &quot;lodash-es&quot;\nimport people from &quot;./people&quot;\n\nconst managerGroups = groupBy(people, &quot;manager&quot;)\n\nconst root = document.createElement(&quot;div&quot;)\nroot.innerHTML = `&lt;pre&gt;${JSON.stringify(managerGroups, null, 2)}&lt;/pre&gt;`\ndocument.body.appendChild(root)\n</code></pre><p>src/people.js</p>\n<pre><code>const people = [\n  {\n    manager: &quot;Jen&quot;,\n    name: &quot;Bob&quot;\n  },\n  {\n    manager: &quot;Jen&quot;,\n    name: &quot;Sue&quot;\n  },\n  {\n    manager: &quot;Bob&quot;,\n    name: &quot;Shirley&quot;\n  }\n]\n\nexport default people\n</code></pre><p>运行<strong>npm run develop</strong>启动Webpack并刷新<strong>index.html</strong>。 您应该看到按管理器分组的一组人员打印到屏幕上。</p>\n<p>注意：导入一个像<strong><em>‘es-lodash’</em></strong>这样没有相对路径的模块，是从npm安装到 node_modules的模块。 你自己的模块总是需要一个像<strong><em>‘./people’</em></strong>这样的相对路径，因此你可以区分它们。</p>\n<p>请注意，在控制台中我们的捆绑包大小已增加到<strong>1.41 MiB</strong>！ 这值得关注，但在这种情况下，没有理由担心。 使用<strong>npm run build</strong>在生产模式下编译，lodash-es中的所有未使用的lodash模块都将从bundle中删除。 删除未使用的导入的过程称为tree-shaking，并且是Webpack免费获得的。</p>\n<pre><code>&gt; npm run develop\n\nAsset      Size      Chunks                  Chunk Names\nbundle.js  1.41 MiB  main  [emitted]  [big]  main\n\n\n&gt; npm run build\n\nAsset      Size      Chunks        Chunk Names\nbundle.js  16.7 KiB  0  [emitted]  main\n</code></pre><h2 id=\"装载\"><a href=\"#装载\" class=\"headerlink\" title=\"装载\"></a>装载</h2><p>加载程序允许您在导入文件时运行预处理程序。 这允许您将静态资源捆绑到JavaScript之外，但让我们看看在首先加载<strong>.js</strong>模块时可以做些什么。</p>\n<p>让我们通过下一代JavaScript转换器Babel运行所有<strong>.js</strong>文件来保持代码的现代化：</p>\n<pre><code>npm install --save-dev &quot;babel-loader@^8.0.0-beta&quot; @babel/core @babel/preset-env\n</code></pre><p>webpack.config.js</p>\n<pre><code>const path = require(&#39;path&#39;)\n\n  module.exports = {\n    entry: &#39;./src/index.js&#39;,\n    output: {\n      filename: &#39;bundle.js&#39;,\n      path: path.resolve(__dirname, &#39;dist&#39;)\n    },\n   module: {\n     rules: [\n       {\n         test: /\\.js$/,\n         exclude: /(node_modules|bower_components)/,\n         use: {\n           loader: &#39;babel-loader&#39;,\n         }\n       }\n     ]\n   }\n  }\n</code></pre><p>.babelrc</p>\n<pre><code>{\n  &quot;presets&quot;: [\n    [&quot;@babel/env&quot;, {\n      &quot;modules&quot;: false\n    }]\n  ],\n  &quot;plugins&quot;: [&quot;syntax-dynamic-import&quot;]\n}\n</code></pre><p>此配置可防止Babel将导入和导出语句转换为ES5，并启用动态导入，这个我们将在后面的“代码拆分”一节中介绍。</p>\n<p>我们现在可以自由使用现代语言功能，它们将被编译为在所有浏览器中运行的ES5。</p>\n<h2 id=\"Sass\"><a href=\"#Sass\" class=\"headerlink\" title=\"Sass\"></a>Sass</h2><p>Loaders可以链接在一起进行一系列变换。 从我们的JavaScript导入Sass可以较好地演示它是如何工作的：</p>\n<pre><code>npm install --save-dev style-loader css-loader sass-loader node-sass\n</code></pre><p>webpack.config.js</p>\n<pre><code> module.exports = {\n...\nmodule: {\n  rules: [\n    ...\n       {\n         test: /\\.scss$/,\n         use: [{\n           loader: &#39;style-loader&#39;\n         }, {\n           loader: &#39;css-loader&#39;\n         }, {\n           loader: &#39;sass-loader&#39;\n         }]\n       }\n      ]\n    }\n  }\n</code></pre><p>这些加载器以相反的顺序处理:</p>\n<ul>\n<li>sass-loader将Sass转换为CSS。</li>\n<li>css-loader将CSS解析为JavaScript并解析任何依赖项。</li>\n<li>style-loader将我们的CSS输出到文档中的&lt;style>标记中。</li>\n</ul>\n<p>您可以将这些视为函数调用。 一个加载器的输出作为输入提供给下一个：</p>\n<pre><code>styleLoader(cssLoader(sassLoader(&quot;source&quot;)))\n</code></pre><p>让我们添加一个Sass源文件，import是一个模块。</p>\n<p>src/style.scss</p>\n<pre><code>$bluegrey: #2b3a42;\n\npre {\n  padding: 8px 16px;\n  background: $bluegrey;\n  color: #e1e6e9;\n  font-family: Menlo, Courier, monospace;\n  font-size: 13px;\n  line-height: 1.5;\n  text-shadow: 0 1px 0 rgba(23, 31, 35, 0.5);\n  border-radius: 3px;\n}\n</code></pre><p>src/index.js</p>\n<pre><code>import { groupBy } from &#39;lodash-es&#39;\nimport people from &#39;./people&#39;\n\nimport &#39;./style.scss&#39;\n\n  ...\n</code></pre><p>使用Ctrl + C和npm run develop重新启动构建。 在浏览器中刷新index.html，您应该看到一些样式。</p>\n<h2 id=\"JS中的样式表\"><a href=\"#JS中的样式表\" class=\"headerlink\" title=\"JS中的样式表\"></a>JS中的样式表</h2><p>我们刚从JavaScript中导入了一个Sass文件作为模块。</p>\n<p>打开dist / bundle.js并搜索“pre {”。 实际上，我们的Sass已被编译为一串CSS并在我们的包中保存为模块。 当我们将这个模块导入JavaScript时，style-loader将字符串输出到嵌入的&lt;style>标记中。</p>\n<p>你为什么需要做这样的事？</p>\n<p>我不会在这里深入研究这个主题，但这里有几个理由需要考虑：</p>\n<ul>\n<li>您可能希望包含在项目中的JavaScript组件可能依赖于其他资源才能正常运行（HTML，CSS，图像，SVG）。 如果这些都可以捆绑在一起，则导入和使用起来要容易得多。</li>\n<li>消除Dead code：当代码不再导入JS组件时，也不再导入CSS。 生成的包只会包含执行某些操作的代码。</li>\n<li>CSS模块：CSS的全局命名空间使得很难确信对CSS的更改不会产生任何副作用。 CSS模块通过设置CSS默认本地并显示您可以在JavaScript中引用的唯一类名来解决该问题。</li>\n<li>通过巧妙的方式捆绑/拆分代码来减少HTTP请求的数量。</li>\n</ul>\n<h2 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h2><p>我们将看到的最后一个加载器示例是使用文件加载器处理图像。</p>\n<p>在标准HTML文档中，当浏览器遇到img标记或具有background-image属性的元素时，将获取图像。 使用Webpack，您可以在小图像的情况下通过将图像源作为字符串存储在JavaScript中来优化它。 通过执行此操作，您可以预加载它们，浏览器不必在以后使用单独的请求获取它们：</p>\n<pre><code>npm install --save-dev file-loader\n</code></pre><p>webpack.config.js</p>\n<pre><code>module.exports = {\n    ...\n    module: {\n      rules: [\n        ...\n       {\n         test: /\\.(png|svg|jpg|gif)$/,\n         use: [\n           {\n             loader: &#39;file-loader&#39;\n           }\n         ]\n       }\n      ]\n    }\n  }\n</code></pre><p>用以下命令下载一个测试图像：</p>\n<pre><code>    curl https://raw.githubusercontent.com/sitepoint-editors/webpack-demo/master/src/code.png --output src/code.png\n</code></pre><p>使用Ctrl + C和npm run develop重新启动构建，您现在可以将图像作为模块导入！</p>\n<p>src/index.js</p>\n<pre><code>import { groupBy } from &#39;lodash-es&#39;\nimport people from &#39;./people&#39;\n\nimport &#39;./style.scss&#39;\nimport &#39;./image-example&#39;\n\n  ...\n</code></pre><p>src/image-example.js</p>\n<pre><code>import codeURL from &quot;./code.png&quot;\n\nconst img = document.createElement(&quot;img&quot;)\nimg.src = codeURL\nimg.style = &quot;background: #2B3A42; padding: 20px&quot;\nimg.width = 32\ndocument.body.appendChild(img)\n</code></pre><p>这将包括一个图像，其中src属性包含图像本身的数据URI：</p>\n<pre><code>&lt;img src=&quot;data:image/png;base64,iVBO...&quot; style=&quot;background: #2B3A42; padding: 20px&quot; width=&quot;32&quot;&gt;\n</code></pre><p>我们的CSS中的背景图像也由文件加载器处理。</p>\n<p>src/style.scss</p>\n<pre><code>$bluegrey: #2b3a42;\n\n  pre {\n    padding: 8px 16px;\n    background: $bluegrey;\n    background: $bluegrey url(&quot;code.png&quot;) no-repeat center center / 32px 32px;\n    color: #e1e6e9;\n    font-family: Menlo, Courier, monospace;\n    font-size: 13px;\n    line-height: 1.5;\n    text-shadow: 0 1px 0 rgba(23, 31, 35, 0.5);\n    border-radius: 3px;\n  }\n</code></pre><p>在文档中查看更多Loaders示例：</p>\n<ul>\n<li><a href=\"https://webpack.js.org/guides/asset-management/#loading-fonts\" target=\"_blank\" rel=\"noopener\">加载字体</a></li>\n<li><a href=\"https://webpack.js.org/guides/asset-management/#loading-data\" target=\"_blank\" rel=\"noopener\">加载数据</a></li>\n</ul>\n<h2 id=\"依赖图-Dependency-Graph\"><a href=\"#依赖图-Dependency-Graph\" class=\"headerlink\" title=\"依赖图 Dependency Graph\"></a>依赖图 Dependency Graph</h2><p>您现在应该能够看到加载器如何帮助您在资源中构建依赖关系树。 这就是Webpack主页上的图像所展示的内容。</p>\n<p><img src=\"https://dab1nmslvvntp.cloudfront.net/wp-content/uploads/2017/01/1484692838webpack-dependency-tree.png\" alt=\"\"></p>\n<p>尽管JavaScript是切入点，但Webpack明白您的其他资源类型（如HTML，CSS和SVG）各自具有自己的依赖关系，这应该被视为构建过程的一部分。</p>\n<h2 id=\"代码拆分\"><a href=\"#代码拆分\" class=\"headerlink\" title=\"代码拆分\"></a>代码拆分</h2><p>Webpack文档中写到：</p>\n<blockquote>\n<p>代码拆分是Webpack最引人注目的功能之一。 此功能允许您将代码拆分为各种捆绑包，然后可以按需或并行加载。 它可用于实现更小的捆绑并控制资源负载优先级，如果使用得当，可能会对加载时间产生重大影响。</p>\n</blockquote>\n<p>到目前为止，我们只看到了一个入口点 - <strong>src / index.js</strong> - 和一个输出包 - dist / bundle.js。 当您的应用程序增长时，您需要将其拆分，以便在开始时不会下载整个代码库。 一种好的方法是使用Code Splitting和Lazy Loading来按需获取内容，因为代码路径需要它们。</p>\n<p>我们通过添加一个“聊天”模块来证明这一点，该模块在有人与之交互时被提取和初始化。 我们将创建一个新的入口点并为其命名，我们还将使输出的文件名动态，因此每个块的不同。</p>\n<p>webpack.config.js</p>\n<pre><code> const path = require(&#39;path&#39;)\n\n  module.exports = {\n   entry: &#39;./src/index.js&#39;,\n   entry: {\n     app: &#39;./src/app.js&#39;\n   },\n   output: {\n     filename: &#39;bundle.js&#39;,\n     filename: &#39;[name].bundle.js&#39;,\n     path: path.resolve(__dirname, &#39;dist&#39;)\n    },\n    ...\n  }\n</code></pre><p>src/app.js</p>\n<pre><code>import &#39;./app.scss&#39;\n\nconst button = document.createElement(&quot;button&quot;)\nbutton.textContent = &#39;Open chat&#39;\ndocument.body.appendChild(button)\n\nbutton.onclick = () =&gt; {\n  import(/* webpackChunkName: &quot;chat&quot; */ &quot;./chat&quot;).then(chat =&gt; {\n    chat.init()\n  })\n}\n</code></pre><p>src/chat.js</p>\n<pre><code>import people from &quot;./people&quot;\n\nexport function init() {\n  const root = document.createElement(&quot;div&quot;)\n  root.innerHTML = `&lt;p&gt;There are ${people.length} people in the room.&lt;/p&gt;`\n  document.body.appendChild(root)\n}\n</code></pre><p>src/app.scss</p>\n<pre><code>button {\n  padding: 10px;\n  background: #24b47e;\n  border: 1px solid rgba(#000, .1);\n  border-width: 1px 1px 3px;\n  border-radius: 3px;\n  font: inherit;\n  color: #fff;\n  cursor: pointer;\n  text-shadow: 0 1px 0 rgba(#000, .3), 0 1px 1px rgba(#000, .2);\n}\n</code></pre><p>注意：尽管<em>/ </em> webpackChunkName <em> /</em> comment为包提供了名称，但此语法不是特定于Webpack的。 它是动态导入的建议语法，旨在直接在浏览器中支持。</p>\n<p>我们运行npm run build并查看它生成的内容：</p>\n<pre><code>Asset           Size       Chunks        Chunk Names\nchat.bundle.js  377 bytes  0  [emitted]  chat\napp.bundle.js   7.65 KiB   1  [emitted]  app\n</code></pre><p>由于我们的条目包已经更改，我们还需要更新它的路径。</p>\n<p>dist/index.html</p>\n<pre><code>&lt;!doctype html&gt;\n  &lt;html&gt;\n    &lt;head&gt;\n      &lt;title&gt;Hello Webpack&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n    &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;app.bundle.js&quot;&gt;&lt;/script&gt;\n    &lt;/body&gt;\n  &lt;/html&gt;\n</code></pre><p>我们从dist目录启动一个服务器，看看这个实际应用：</p>\n<pre><code>cd dist\nnpx serve\n</code></pre><p>在浏览器中打开<a href=\"http://localhost:5000，看看会发生什么。\" target=\"_blank\" rel=\"noopener\">http://localhost:5000，看看会发生什么。</a> 最初只获取bundle.js。 单击该按钮时，将导入并初始化聊天模块。<br><img src=\"https://dab1nmslvvntp.cloudfront.net/wp-content/uploads/2018/03/1521906882lazy-loading.png\" alt=\"\"></p>\n<p>只需很少的工作，我们就可以在我们的应用程序中添加动态代码拆分和延迟加载模块。 这是构建高性能Web应用程序的一个很好的起点。</p>\n<h2 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h2><p>当加载器对单个文件进行转换时，插件可以在更大的代码块上运行。</p>\n<p>现在我们正在打包代码，外部模块和静态资产，我们的包将会迅速增长。 插件可以帮助我们以巧妙的方式分割代码并优化生产。</p>\n<p>在不知情的情况下，我们实际上已经使用了许多默认的Webpack插件“模式”</p>\n<p>发展</p>\n<ul>\n<li>提供process.env.NODE_ENV，其值为“development”</li>\n<li>NamedModulesPlugin</li>\n</ul>\n<p>生产</p>\n<ul>\n<li>提供process.env.NODE_ENV，其值为“production”</li>\n<li>UglifyJsPlugin</li>\n<li>ModuleConcatenationPlugin</li>\n<li>NoEmitOnErrorsPlugin</li>\n</ul>\n<h2 id=\"产品\"><a href=\"#产品\" class=\"headerlink\" title=\"产品\"></a>产品</h2><p>在添加其他插件之前，我们首先拆分我们的配置，以便我们可以应用特定于每个环境的插件。</p>\n<p>将webpack.config.js重命名为webpack.common.js并添加用于开发和生产的配置文件。</p>\n<pre><code>- |- webpack.config.js\n+ |- webpack.common.js\n+ |- webpack.dev.js\n+ |- webpack.prod.js\n</code></pre><p>我们将使用webpack-merge将我们的公共配置与特定于环境的配置相结合：</p>\n<pre><code>npm install --save-dev webpack-merge\n</code></pre><p>webpack.dev.js</p>\n<pre><code>const merge = require(&#39;webpack-merge&#39;)\nconst common = require(&#39;./webpack.common.js&#39;)\n\nmodule.exports = merge(common, {\n  mode: &#39;development&#39;\n})\n</code></pre><p>webpack.prod.js</p>\n<pre><code>const merge = require(&#39;webpack-merge&#39;)\nconst common = require(&#39;./webpack.common.js&#39;)\n\nmodule.exports = merge(common, {\n  mode: &#39;production&#39;\n})\n</code></pre><p>package.json</p>\n<pre><code> &quot;scripts&quot;: {\n    &quot;develop&quot;: &quot;webpack --watch --mode development&quot;,\n    &quot;build&quot;: &quot;webpack --mode production&quot;\n    &quot;develop&quot;: &quot;webpack --watch --config webpack.dev.js&quot;,\n    &quot;build&quot;: &quot;webpack --config webpack.prod.js&quot;\n   },\n</code></pre><p>现在我们可以将特定于开发的插件添加到webpack.dev.js和webpack.prod.js中特定于生产的插件中。</p>\n<h2 id=\"拆分CSS\"><a href=\"#拆分CSS\" class=\"headerlink\" title=\"拆分CSS\"></a>拆分CSS</h2><p>在使用ExtractTextWebpackPlugin捆绑生产时，最好将CSS与JavaScript分开。</p>\n<p>当前的.scss加载器非常适合开发，所以我们将把它们从webpack.common.js移到webpack.dev.js中，并将ExtractTextWebpackPlugin添加到webpack.prod.js中。</p>\n<pre><code>npm install --save-dev extract-text-webpack-plugin@4.0.0-beta.0\n</code></pre><p>webpack.common.js</p>\n<pre><code> ...\n  module.exports = {\n    ...\n    module: {\n      rules: [\n        ...\n-       {\n-         test: /\\.scss$/,\n-         use: [\n-           {\n-             loader: &#39;style-loader&#39;\n-           }, {\n-             loader: &#39;css-loader&#39;\n-           }, {\n-             loader: &#39;sass-loader&#39;\n-           }\n-         ]\n-       },\n        ...\n      ]\n    }\n  }\n</code></pre><p>webpack.dev.js</p>\n<pre><code>  const merge = require(&#39;webpack-merge&#39;)\n+ const ExtractTextPlugin = require(&#39;extract-text-webpack-plugin&#39;)\n  const common = require(&#39;./webpack.common.js&#39;)\n\n  module.exports = merge(common, {\n    mode: &#39;production&#39;,\n    module: {\n     rules: [\n      {\n         test: /\\.scss$/,\n         use: ExtractTextPlugin.extract({\n           fallback: &#39;style-loader&#39;,\n           use: [&#39;css-loader&#39;, &#39;sass-loader&#39;]\n         })\n       }\n     ]\n   },\n   plugins: [\n     new ExtractTextPlugin(&#39;style.css&#39;)\n   ]\n  })\n</code></pre><p>我们来比较两个构建脚本的输出：</p>\n<pre><code>&gt; npm run develop\n\nAsset           Size      Chunks           Chunk Names\napp.bundle.js   28.5 KiB  app   [emitted]  app\nchat.bundle.js  1.4 KiB   chat  [emitted]  chat\n\n&gt; npm run build\n\nAsset           Size       Chunks        Chunk Names\nchat.bundle.js  375 bytes  0  [emitted]  chat\napp.bundle.js   1.82 KiB   1  [emitted]  app\nstyle.css       424 bytes  1  [emitted]  app\n</code></pre><p>现在CSS被从JavaScript包中提取出来用于生产，我们需要从我们的HTML &lt;link>到它。</p>\n<p>dist/index.html</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n  &lt;html&gt;\n    &lt;head&gt;\n      &lt;meta charset=&quot;UTF-8&quot;&gt;\n      &lt;title&gt;Code Splitting&lt;/title&gt;\n      &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n      &lt;script type=&quot;text/javascript&quot; src=&quot;app.bundle.js&quot;&gt;&lt;/script&gt;\n    &lt;/body&gt;\n  &lt;/html&gt;\n</code></pre><p>这允许在浏览器中并行下载CSS和JavaScript，因此加载速度比单个捆绑包更快。 它还允许在JavaScript完成下载之前显示样式。</p>\n<h2 id=\"生成HTML\"><a href=\"#生成HTML\" class=\"headerlink\" title=\"生成HTML\"></a>生成HTML</h2><p>每当我们的输出发生变化时，我们必须不断更新index.html以引用新的文件路径。 这正是html-webpack-plugin自动为我们创建的。</p>\n<p>我们也可以在每次构建之前同时添加clean-webpack-plugin来清除/dist目录。</p>\n<pre><code>npm install --save-dev html-webpack-plugin clean-webpack-plugin\n</code></pre><p>webpack.common.js</p>\n<pre><code> const path = require(&#39;path&#39;)\n const CleanWebpackPlugin = require(&#39;clean-webpack-plugin&#39;);\n const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);\n\n  module.exports = {\n    ...\n   plugins: [\n     new CleanWebpackPlugin([&#39;dist&#39;]),\n     new HtmlWebpackPlugin({\n       title: &#39;My killer app&#39;\n     })\n   ]\n  }\n</code></pre><p>现在每次我们建立时，dist都会被清除掉。 我们现在也会看到index.html输出，以及我们的入口包的正确路径。</p>\n<p>运行npm run develop会产生以下结果：</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;My killer app&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;app.bundle.js&quot;&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>而npm run build产生了这个：</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;My killer app&lt;/title&gt;\n    &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;app.bundle.js&quot;&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><h2 id=\"发展\"><a href=\"#发展\" class=\"headerlink\" title=\"发展\"></a>发展</h2><p>webpack-dev-server为您提供了一个简单的Web服务器，并为您提供实时重新加载，因此您无需手动刷新页面即可查看更改。</p>\n<pre><code>npm install --save-dev webpack-dev-server\n</code></pre><p>package.json</p>\n<pre><code>{\n    ...\n    &quot;scripts&quot;: {\n     &quot;develop&quot;: &quot;webpack --watch --config webpack.dev.js&quot;,\n     &quot;develop&quot;: &quot;webpack-dev-server --config webpack.dev.js&quot;,\n    }\n    ...\n  }\n\n&gt; npm run develop\n\n ｢wds｣: Project is running at http://localhost:8080/\n ｢wds｣: webpack output is served from /\n</code></pre><p>在浏览器中打开<a href=\"http://localhost:8080/并对其中一个JavaScript或CSS文件进行更改。\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/并对其中一个JavaScript或CSS文件进行更改。</a> 您应该看到它自动构建和刷新。</p>\n<h2 id=\"HotModuleReplacement\"><a href=\"#HotModuleReplacement\" class=\"headerlink\" title=\"HotModuleReplacement\"></a>HotModuleReplacement</h2><p>HotModuleReplacement插件比Live Reloading更进一步，并在运行时交换模块而无需刷新。 正确配置后，这可以节省开发单页应用程序的大量时间。 如果页面中有很多状态，则可以对组件进行增量更改，只更换和更新已更改的模块。</p>\n<p>webpack.dev.js</p>\n<pre><code>  const webpack = require(&#39;webpack&#39;)\n  const merge = require(&#39;webpack-merge&#39;)\n  const common = require(&#39;./webpack.common.js&#39;)\n\n  module.exports = merge(common, {\n    mode: &#39;development&#39;,\n   devServer: {\n     hot: true\n   },\n   plugins: [\n     new webpack.HotModuleReplacementPlugin()\n   ],\n    ...\n  }\n</code></pre><p>现在我们需要从代码中接受更改的模块来重新初始化事物。</p>\n<p>src/app.js</p>\n<pre><code> if (module.hot) {\n   module.hot.accept()\n }\n\n  ...\n</code></pre><p>注意：启用热模块替换时，module.hot设置为true以进行开发，false设置为生产，因此这些将从捆绑中剥离。</p>\n<p>重新启动构建，看看执行以下操作时会发生什么：</p>\n<ul>\n<li>单击打开聊天</li>\n<li>将新人添加到people.js模块</li>\n<li>再次单击“打开聊天”</li>\n</ul>\n<p><img src=\"https://dab1nmslvvntp.cloudfront.net/wp-content/uploads/2018/03/1521906879hmr.png\" alt=\"\"></p>\n<p>这是发生了什么：</p>\n<ol>\n<li>单击“打开聊天”时，将获取并初始化chat.js模块</li>\n<li>HMR检测perple.js何时被修改</li>\n<li>index.js中的module.hot.accept（）会导致替换此条目块加载的所有模块</li>\n<li>再次单击“打开聊天”时，将使用更新模块中的代码运行chat.init（）。</li>\n</ol>\n<h2 id=\"CSS替换\"><a href=\"#CSS替换\" class=\"headerlink\" title=\"CSS替换\"></a>CSS替换</h2><p>让我们将按钮颜色更改为红色，看看会发生什么：</p>\n<pre><code>src/app.scss\n\n  button {\n    ...\n   background: #24b47e;\n   background: red;\n    ...\n  }\n</code></pre><p><img src=\"https://dab1nmslvvntp.cloudfront.net/wp-content/uploads/2018/03/1521906881hmr2.png\" alt=\"\"></p>\n<p>现在我们可以看到我们的样式的即时更新，而不会丢失任何状态。这是一个大大改善的开发人员体验！感觉就像未来。</p>\n<h2 id=\"HTTP-2\"><a href=\"#HTTP-2\" class=\"headerlink\" title=\"HTTP/2\"></a>HTTP/2</h2><p>使用像Webpack这样的module bundler的主要好处之一是它可以帮助您控制资源的构建方式，然后在客户端上获取，从而帮助您提高性能。多年来，连接文件以减少需要在客户端上进行的请求数量被认为是最佳实践。这仍然有效，但HTTP/2现在允许在单个请求中传递多个文件，因此连接不再是银弹。您的应用程序实际上可能会受益于单独缓存许多小文件。然后，客户端可以获取单个已更改的模块，而不必再次获取具有大部分相同内容的整个包。</p>\n<p>Webpack的创建者Tobias Koppers撰写了一篇内容丰富的文章，解释了为什么捆绑仍然很重要，即使在HTTP/2时代也是如此。</p>\n<p>在Webpack和HTTP / 2上阅读更多相关信息。</p>\n<h2 id=\"给你的话\"><a href=\"#给你的话\" class=\"headerlink\" title=\"给你的话\"></a>给你的话</h2><p>我希望你已经发现Webpack的这个介绍很有帮助，并且能够开始使用它并产生很大的效果。可能需要一些时间来围绕Webpack的配置，加载器和插件，但了解这个工具如何工作将会有所回报。</p>\n<p>Webpack 4的文档目前正在进行中，但实际上很好地组合在一起。我强烈建议您阅读概念和指南以获取更多信息。以下是您可能感兴趣的一些其他主题：</p>\n<ul>\n<li><a href=\"https://webpack.js.org/guides/development/#using-source-maps\" target=\"_blank\" rel=\"noopener\">源地图开发</a></li>\n<li><a href=\"https://webpack.js.org/guides/production/#source-mapping\" target=\"_blank\" rel=\"noopener\">生产的源地图</a></li>\n<li><a href=\"https://webpack.js.org/guides/caching/\" target=\"_blank\" rel=\"noopener\">缓存破坏与散列文件名</a></li>\n<li><a href=\"https://webpack.js.org/plugins/commons-chunk-plugin/#explicit-vendor-chunk\" target=\"_blank\" rel=\"noopener\">拆分供应商包</a></li>\n</ul>\n<p>Webpack 4是您选择的module bundler吗？请在下面的评论中告诉我。</p>"}],"PostAsset":[{"_id":"source/_posts/HEXO/How-To-Build-Personal-Blog-By-Hexo/github配置.png","post":"cjlhtwxdn0002xcl5f72ps02o","slug":"github配置.png","modified":1,"renderable":1},{"_id":"source/_posts/HEXO/How-To-Build-Personal-Blog-By-Hexo/markdown常见语法.png","post":"cjlhtwxdn0002xcl5f72ps02o","slug":"markdown常见语法.png","modified":1,"renderable":1},{"_id":"source/_posts/TOOLS/Chrome-Devtool/memory_png1.png","post":"cjlhtwxej000lxcl5vyhxhqdb","slug":"memory_png1.png","modified":1,"renderable":1},{"_id":"source/_posts/TOOLS/Chrome-Devtool/memory_png10.png","post":"cjlhtwxej000lxcl5vyhxhqdb","slug":"memory_png10.png","modified":1,"renderable":1},{"_id":"source/_posts/TOOLS/Chrome-Devtool/memory_png11.png","post":"cjlhtwxej000lxcl5vyhxhqdb","slug":"memory_png11.png","modified":1,"renderable":1},{"_id":"source/_posts/TOOLS/Chrome-Devtool/memory_png12.png","post":"cjlhtwxej000lxcl5vyhxhqdb","slug":"memory_png12.png","modified":1,"renderable":1},{"_id":"source/_posts/TOOLS/Chrome-Devtool/memory_png13.png","post":"cjlhtwxej000lxcl5vyhxhqdb","slug":"memory_png13.png","modified":1,"renderable":1},{"_id":"source/_posts/TOOLS/Chrome-Devtool/memory_png2.png","post":"cjlhtwxej000lxcl5vyhxhqdb","slug":"memory_png2.png","modified":1,"renderable":1},{"_id":"source/_posts/TOOLS/Chrome-Devtool/memory_png3.png","post":"cjlhtwxej000lxcl5vyhxhqdb","slug":"memory_png3.png","modified":1,"renderable":1},{"_id":"source/_posts/TOOLS/Chrome-Devtool/memory_png4.png","post":"cjlhtwxej000lxcl5vyhxhqdb","slug":"memory_png4.png","modified":1,"renderable":1},{"_id":"source/_posts/TOOLS/Chrome-Devtool/memory_png5.png","post":"cjlhtwxej000lxcl5vyhxhqdb","slug":"memory_png5.png","modified":1,"renderable":1},{"_id":"source/_posts/TOOLS/Chrome-Devtool/memory_png6.png","post":"cjlhtwxej000lxcl5vyhxhqdb","slug":"memory_png6.png","modified":1,"renderable":1},{"_id":"source/_posts/TOOLS/Chrome-Devtool/memory_png7.png","post":"cjlhtwxej000lxcl5vyhxhqdb","slug":"memory_png7.png","modified":1,"renderable":1},{"_id":"source/_posts/TOOLS/Chrome-Devtool/memory_png8.png","post":"cjlhtwxej000lxcl5vyhxhqdb","slug":"memory_png8.png","modified":1,"renderable":1},{"_id":"source/_posts/TOOLS/Chrome-Devtool/memory_png9.png","post":"cjlhtwxej000lxcl5vyhxhqdb","slug":"memory_png9.png","modified":1,"renderable":1},{"_id":"source/_posts/TOOLS/Chrome-Devtool/png1.png","post":"cjlhtwxej000lxcl5vyhxhqdb","slug":"png1.png","modified":1,"renderable":1},{"_id":"source/_posts/TOOLS/Chrome-Devtool/png2.png","post":"cjlhtwxej000lxcl5vyhxhqdb","slug":"png2.png","modified":1,"renderable":1},{"_id":"source/_posts/TOOLS/Chrome-Devtool/png3.png","post":"cjlhtwxej000lxcl5vyhxhqdb","slug":"png3.png","modified":1,"renderable":1},{"_id":"source/_posts/TOOLS/Chrome-Devtool/png4.png","post":"cjlhtwxej000lxcl5vyhxhqdb","slug":"png4.png","modified":1,"renderable":1},{"_id":"source/_posts/TOOLS/Chrome-Devtool/png5.png","post":"cjlhtwxej000lxcl5vyhxhqdb","slug":"png5.png","modified":1,"renderable":1},{"_id":"source/_posts/TOOLS/Chrome-Devtool/png6.png","post":"cjlhtwxej000lxcl5vyhxhqdb","slug":"png6.png","modified":1,"renderable":1},{"_id":"source/_posts/TOOLS/Chrome-Devtool/png7.png","post":"cjlhtwxej000lxcl5vyhxhqdb","slug":"png7.png","modified":1,"renderable":1},{"_id":"source/_posts/TOOLS/Chrome-Devtool/png8.png","post":"cjlhtwxej000lxcl5vyhxhqdb","slug":"png8.png","modified":1,"renderable":1},{"_id":"source/_posts/TOOLS/Chrome-Devtool/png9.png","post":"cjlhtwxej000lxcl5vyhxhqdb","slug":"png9.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cjlhtwxdi0001xcl5uhq17xgp","category_id":"cjlhtwxdp0003xcl5mzir89dx","_id":"cjlhtwxdz000axcl5poo6bveg"},{"post_id":"cjlhtwxdn0002xcl5f72ps02o","category_id":"cjlhtwxdp0003xcl5mzir89dx","_id":"cjlhtwxe1000dxcl5pgznqczq"},{"post_id":"cjlhtwxdr0005xcl5739w3abr","category_id":"cjlhtwxdp0003xcl5mzir89dx","_id":"cjlhtwxe2000fxcl5v5s7bryn"},{"post_id":"cjlhtwxee000gxcl5d65pd133","category_id":"cjlhtwxeg000ixcl5ql7sxcr3","_id":"cjlhtwxen000qxcl5ryfs2i2x"},{"post_id":"cjlhtwxef000hxcl5bswkqebw","category_id":"cjlhtwxeg000ixcl5ql7sxcr3","_id":"cjlhtwxeo000uxcl5w8jhwmgc"},{"post_id":"cjlhtwxeh000kxcl5imw4csg6","category_id":"cjlhtwxeg000ixcl5ql7sxcr3","_id":"cjlhtwxep000xxcl5ze9z7czx"},{"post_id":"cjlhtwxej000lxcl5vyhxhqdb","category_id":"cjlhtwxeo000txcl5jwa7cdic","_id":"cjlhtwxeq000zxcl53393xkwh"},{"post_id":"cjlhtwxex0010xcl51vlvui3j","category_id":"cjlhtwxf00011xcl5hx6upycw","_id":"cjlhtwxf20014xcl59lwrktk7"}],"PostTag":[{"post_id":"cjlhtwxdi0001xcl5uhq17xgp","tag_id":"cjlhtwxdr0004xcl5ldu64e66","_id":"cjlhtwxdx0008xcl5rr27rmhm"},{"post_id":"cjlhtwxdn0002xcl5f72ps02o","tag_id":"cjlhtwxdr0004xcl5ldu64e66","_id":"cjlhtwxe0000cxcl50m52iaxx"},{"post_id":"cjlhtwxdr0005xcl5739w3abr","tag_id":"cjlhtwxdr0004xcl5ldu64e66","_id":"cjlhtwxe2000excl55es1ytbf"},{"post_id":"cjlhtwxee000gxcl5d65pd133","tag_id":"cjlhtwxeh000jxcl50gypdj2c","_id":"cjlhtwxem000oxcl5nbymcp5j"},{"post_id":"cjlhtwxef000hxcl5bswkqebw","tag_id":"cjlhtwxeh000jxcl50gypdj2c","_id":"cjlhtwxeo000sxcl570udepb3"},{"post_id":"cjlhtwxeh000kxcl5imw4csg6","tag_id":"cjlhtwxeh000jxcl50gypdj2c","_id":"cjlhtwxep000wxcl53lo0yk0f"},{"post_id":"cjlhtwxej000lxcl5vyhxhqdb","tag_id":"cjlhtwxeo000vxcl58yh5ep58","_id":"cjlhtwxep000yxcl5o7bt9zzb"},{"post_id":"cjlhtwxex0010xcl51vlvui3j","tag_id":"cjlhtwxf10012xcl5k2yh0m6g","_id":"cjlhtwxf10013xcl5bb680gqz"}],"Tag":[{"name":"Hexo","_id":"cjlhtwxdr0004xcl5ldu64e66"},{"name":"移动","_id":"cjlhtwxeh000jxcl50gypdj2c"},{"name":"chrome devtool 性能分析 内存泄露","_id":"cjlhtwxeo000vxcl58yh5ep58"},{"name":"WebPack","_id":"cjlhtwxf10012xcl5k2yh0m6g"}]}}