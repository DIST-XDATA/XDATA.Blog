<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2FXDATA.Blog%2F2018%2F10%2F31%2FFRONTEND%2FVue%20%2B%20iview%20%2B%20webpack%20%E5%AF%B9%20ie%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E7%AE%80%E5%8D%95%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[title: Vue + iview + webpack ie 浏览器兼容简单处理date: 2018-10-31 14:36:05tags: Front endcategories: frontend Vue + iview + webpack ie 浏览器兼容简单处理 环境介绍：vue: ^2.5.2 iview: ^3.1.0 Webpack: ^3.8.1 前情提要： ie 浏览器不支持 ES6 Promise 的语法。 ie8 及以下对 html5 标签不兼容（可以通过引入html5shiv包解决，本文不处理IE11的更低版本，故不提及此法）。 ie9 以下 对 CSS3 的不兼容，各种不兼容的细节比较多，这里不说明。 ie10 及以下浏览器中不支持 dataset 方法（经学习实践发现ie11也是不支持的），而我在项目中使用了 iview, iview 的一些组件用到了这个方法。 ie 浏览器是非 webkit 内核，不支持 display: -webkit-box; 和相关样式； Polyfill 是 shim 的一种，但他的 API 是遵循标准的。polyfill 的做法通常是：先检查浏览器是否支持某个标准 API,如果不支持,就使用旧的技术对浏览器做兼容处理,这样就可以在旧的浏览器上使用新的标准 API。比如,旧浏览器不支持 ES6 的 Array.prototype.find 方法,我们想要在项目中使用 Array.prototype.find,只要 polyfill 就行了,而不是封装一个新的方法。 处理过程1、安装 polyfill 组件，使浏览器兼容 es6 的写法 在终端输入命令 npm install –save babel-polyfill main.js 头部引入 babel-polyfill， 注意这个放最前面： import ‘babel-polyfill’ 或者在项目的 webpack.base.conf.js 中配置： entry: { app:[&#39;babel-polyfill&#39;,&#39;./src/main.js&#39;] }, 另外，引入的一些模块需要单独引入到 babel 的配置中，不然不起作用（具体为啥我没深究），网上查到用到 echarts-v3 的需要配置，经测试我用到 iview 也是要配置的, 下面代码的 include 中就是我配置的项，这个主要是按需配置的，具体看项目里的情况： module: { rules: [ ...(config.dev.useEslint ? [createLintingRule()] : []), { test: /\.vue$/, loader: &#39;vue-loader&#39;, options: vueLoaderConfig }, { test: /\.js$/, loader: &#39;babel-loader&#39;, include: [ resolve(&#39;src&#39;), resolve(&#39;test&#39;), resolve(&#39;static&#39;), resolve(&#39;node_modules/webpack-dev-server/client&#39;), // resolve(&#39;node_modules/vue-echarts&#39;), resolve(&#39;node_modules/iview/src&#39;), // resolve(&#39;node_modules/resize-detector&#39;) ] }, } 2、兼容 dataset我在引入了 babel-polyfill 后还是报错，信息如下图： 搜了半天关于 SCRIPT1003 和 SCRIPT5007 的错误, 发现没有直接的解决办法，就主要是说缺少项目中包含的某个模块的某种方法的引入。于是我就从我主要用到的 iview 入手去查找，发现了有相关的内容。有说到 iview 兼容 IE 需要写一个 dataset 方法才能正常加载。 dataset方法只要能够加载全局使用即可。我是写了一个脚本嵌入 index.html 文件中。代码如下： &lt;script&gt; // dataset 方法兼容 IE 浏览器。ie10及以下不支持dataset if (window.HTMLElement) { if (Object.getOwnPropertyNames(HTMLElement.prototype).indexOf(&#39;dataset&#39;) === -1) { Object.defineProperty(HTMLElement.prototype, &#39;dataset&#39;, { get: function () { var attributes = this.attributes // 获取节点的所有属性 var name = [] var value = [] // 定义两个数组保存属性名和属性值 var obj = {} // 定义一个空对象 for (var i = 0; i &lt; attributes.length; i++) { // 遍历节点的所有属性 if (attributes[i].nodeName.slice(0, 5) === &#39;data-&#39;) { // 如果属性名的前面5个字符符合&quot;data-&quot; // 取出属性名的&quot;data-&quot;的后面的字符串放入name数组中 name.push(attributes[i].nodeName.slice(5)); // 取出对应的属性值放入value数组中 value.push(attributes[i].nodeValue); } } for (var j = 0; j &lt; name.length; j++) { // 遍历name和value数组 obj[name[j]] = value[j]; // 将属性名和属性值保存到obj中 } return obj // 返回对象 } }) } } &lt;/script&gt; 搞到这里，我的项目就已经可以在 IE 里出现了，也不打算继续支持更低的IE版本，坑太深，果断弃。但是样式还是有问题。这个搞起来也是很麻烦。点了点项目里出现的样式问题，未发现很复杂的，主要一个就是 flex 布局出现混乱，经过调整已经好了。还有就是 -webkit-box 不支持，之前显示数据使用以下方式解决多行溢出省略号显示问题失效了： overflow: hidden; display: -webkit-box; /* Chrome 4+, Safari 3.1, iOS Safari 3.2+ */ -webkit-box-orient: vertical; -webkit-line-clamp: 2; word-break: break-all; 纠结了一下，不想用js 的方式写，也不想用 伪标签（高度不好定，易出现文字被覆盖的情况），也不想特意让后台修改返回的数据，所以决定用比较low的相对保险的截取字符的方式展示。 总结第一次处理这个问题，很多东西不明白，描述也不大清楚，处理的不全面，还望多交流指正！]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2FXDATA.Blog%2F2018%2F09%2F26%2FMOBILE%2FAndroid%20Gis%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[Android Gis开发经验分享概述一、地图坐标系的认识二、地图管理类的认识三、Gis开发熟知四、Gis开发平台差异化注意事项一、地图坐标系的认识1. WGS84坐标系​ 一种国际上采用的地心坐标系. 2. WGS84 Web墨卡托​ Web墨卡托是2005年谷歌在谷歌地图中首次使用的,如今主流的Web地图几乎都是使用的Web墨卡托,如：国内的百度地图、高德地图、腾讯地图和天地图等也是基于Web墨卡托（国内地图有加密要求，有两种情况，一种是在 Web墨卡托的基础上经过国家标准加密的国标02坐标系，熟称“火星坐标系”；另一种是在国标的02坐标系下进一步进行加密，如百度地图的BD09坐标系）。​ 3.GCJ02经纬度投影​ GCJ-02是由中国国家测绘局（G表示Guojia国家，C表示Cehui测绘，J表示Ju局）制订的地理信息系统的坐标系统。它其实就是对真实坐标系统进行人为的加偏处理，按照特殊的算法，将真实的坐标加密成虚假的坐标，而这个加偏并不是线性的加偏，所以各地的偏移情况都会有所不同。而加密后的坐标也常被大家称为“火星坐标系统”。​ 该坐标系的坐标值为经纬度格式，单位为度； GCJ02经纬度投影，就是在WGS84经纬度的基础之上，进行GCJ-02加偏；BD09经纬度投影属于百度坐标系，它是在标准经纬度的基础上进行GCJ-02加偏之后，再加上百度自身的加偏算法，也就是在标准经纬度的基础之上进行了两次加偏。 4.GCJ02 Web 墨卡托投影​ 该坐标系的坐标值为Web墨卡托格式，单位为米；这里的GCJ02 Web 墨卡托，也就是在标准Web默卡托的基础之上，进行GCJ-02加偏。 5. 北京54坐标系​ 我国与前苏联1942年坐标系进行联测，通过计算建立了我国大地坐标系，定名为1954年北京坐标系。它的原点不在北京而是在前苏联的普尔科沃；该坐标系存在很多缺点，为此，我国在1978年在西安召开了”全国天文大地网整体平差会议”，提出了建立属于我国自己的大地坐标系，即后来的1980西安坐标系。 6. 西安80坐标系​ 该坐标系的大地原点设在我国中部的陕西省泾阳县永乐镇，位于西安市西北方向约60公里。 7. CGCS2000坐标系​ 2000中国大地坐标系(China Geodetic Coordinate System 2000，CGCS2000)，又称之为2000国家大地坐标系，是中国新一代大地坐标系，21世纪初已在中国正式实施。 8. OGC标准​ OGC 全称是开放地理空间信息联盟(Open Geospatial Consortium),是一个非盈利的国际标准组织，它制定了数据和服务的一系列标准，GIS厂商按照这个标准进行开发可保证空间数据的互操作 9.EPSP代码​ EPSP的英文全称是European Petroleum Survey Group，中文名称为欧洲石油调查组织。这个组织成立于1986年，2005年并入IOGP(InternationalAssociation of Oil &amp; Gas Producers)，中文名称为国际油气生产者协会；EPSG对世界的每一个地方都制定了地图，但是由于座标系不同，所以地图也各不相同。 10.SRID：​ OGC标准中的参数SRID，也是指的空间参考系统的ID，与EPSG一致；天地图通常采用的4490坐标系其实也就是CGCS2000坐标系 。 二、地图管理类的认识1. ArcGISDynamicMapServiceLayer​ extends DynamicLayer 2. ArcGISTiledMapServiceLayer​ extends TiledServiceLayer 3. ArcGISLocalTiledLayer​ extends TiledLayer 4. ArcGISFeatureLayer​ extends GraphicsLayer 5. TianDiTuLayer​ extends TiledServiceLayer 6. GraphicsLayer​ extends Layer 7. WMSLayer​ extends DynamicLayer 8. 其他：​ WMSLayer、WFS、 WMTSLayer、 WebMapLayer、 WCS、WPS、WCPS等…​ 其中wms是web地图服务，是一个仓库管理系统；wfs 是web要素服务，是一个工作流系统； 三、Gis开发常用函数1.FindTask​ 多个图层的要素查询、不能进行“空间查询”； 2. QueryTask​ 空间和属性查询 3. IdentifyTask​ 多个图层中查询、识别要素（Feature）； 4. OnSingleTapListener​ 地图点击事件监听 5. calculateLength2D()​ 线长度计算 6. polygon.calculateArea2D()​ 面积计算 7. GeometryEngine​ 图形交叉关系识别及计算 四、Gis平台差异化注意事项（android为主）1.ArcGISDynamicMapServiceLayer 无法显示问题属性设置：Supports Dynamic Layers: true2.ArcGISDynamicMapServiceLayer可根据底图坐标系自行调整。​ 如：加载wmts地图服务后进行ArcGISDynamicMapServiceLayer叠加可进行图层显示、反之无法显示。 3.ArcGISDynamicMapServiceLayer(String url) 与ArcGISDynamicMapServiceLayer(String url, int[] visiblelayers)差异​ 初始化传入visiblelayers，后面可通过图层id进行单个图层的控制、否则无法正常控制。​ 4.ArcGISDynamicMapServiceLayer(String url, int[] visiblelayers)部分地图服务必须使用此函数才可正常显示图层。​ 项目经历：广州项目添加特有的配置文件支持该函数的使用。 问题讨论：​ 1.三大查询的异步处理机制？​ 2.地图服务操作常见问题总结。​ 3.天地图加载方式及注意事项。 ​]]></content>
  </entry>
  <entry>
    <title><![CDATA[移动一张图专题分析]]></title>
    <url>%2FXDATA.Blog%2F2018%2F08%2F31%2FMOBILE%2F%E7%A7%BB%E5%8A%A8%E4%B8%80%E5%BC%A0%E5%9B%BE%E4%B8%93%E9%A2%98%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[移动一张图专题分析 ##简介[专题模块为整个项目中的重要组成部分，也是不可或缺之一。用户可通过专题信息查看其主要层级结构和内部构造划分。对主要层级可进行收藏展示，便于直观查看。可手动点击某一层级结构打开对应图层，查看详细信息。] 列表主要分为两种结构，一种为树状结构、一种为层级结构。以相同的数据模型展示不同的列表结构，便于用户选择。 ##逻辑列表项包括三角号小图标、收藏按钮和点击开关的按钮。根据不同情境分别设置相应的展示状态。 当为树状结构时：首先初始化专题列表，通过Id展示最新列表。当点击Item项时，我们会记录专题的id,通过id找到子集列表数据，查看子集的type类型是否为“catalog”,如果是该类型，则会继续打开。直到我们点击Item项为“group”类型时，这时图层状态则不显示下一级别。 当我们点击开关状态时，获取子结点数据，将当前状态设置为打开，设置专题是否可见，根据id判断找到父级与子级，并更新整个专题的数据。当开关状态点击到“group”级别时，下一级别则是“layer”级别，图层状态则不显示下一级别。直接在图层上加载layer级别的数据。关闭时如果点击group级别的数据，则会直接关闭当前对应级别数据，父级状态为半开状态，如果关闭“catalog级则会将子级数据共同关闭，直到点击状态为“catalog”级别，对应“parentLayerId”=-1时，这时所有子级数据将全部关闭。 当为层级结构时：当我们点击开关状态时，记录当前id,并通过id找到对应子级的信息，清空当前数据，将最新数据更新到列表上。关闭时当”parentLayerId!=-1”时,列表下方有一个按钮提示返回上一级，当点击按钮时会找到上一级别数据，将当前级别数据清空，并将父级数据展示到列表上，更新适配器。 Windows平台/AndroidStudio开发环境##重要代码实现1. 通过ID获取列表，projectId刚开始传入-1.显示根目录列表：public void replaceAndShowListById(Context context, String projectId, boolean isOnlyShow) { try { List&lt;ThemeInfo&gt; themeInfoList=TopicLayerManager.getSubTopicList(context, projectId); if (null != themeInfoList) { if (null != showList) { showList.clear(); } } listViewSetAdapter(themeInfoList); if (!isOnlyShow &amp;&amp; null != themeInfoList &amp;&amp; themeInfoList.size() &gt; 0) { TotalApplication.getListIdInstance().clear(); TotalApplication.getListIdInstance().add(projectId); } } catch (Exception e) { e.printStackTrace(); } } public synchronized void listViewSetAdapter(List&lt;ThemeInfo&gt; dmpList) { if (null != dmpList &amp;&amp; dmpList.size() &gt; 0) { if (null == projectAdapter) { if (null != this.themeListView) { this.showList = dmpList; projectAdapter = new TopicAdapter(this.context, this.showList, handler, isGradedData); this.themeListView.setAdapter(projectAdapter); } } else { this.showList = dmpList; projectAdapter.setThemeInfoList(this.showList); } } } 2. 列表Item的点击事件： public synchronized void clickItemResponse(Context context, int position) throws Exception { if (null != showList) { ThemeInfo node = showList.get(position); if (JudgeNullUtil.ObjIsNull(node)) { return; } List&lt;ThemeInfo&gt; dmpList = new ArrayList&lt;&gt;(); String projectId = node.getId(); String type = node.getType(); if (projectId != null &amp;&amp; projectId.length() &gt; 0 &amp;&amp; Constants.TYPE_CATLOG.equals(type)) { dmpList = TopicLayerManager.getSubTopicList(context, projectId); } if (null != dmpList &amp;&amp; dmpList.size() &gt; 0) { if (isGradedData) { if (projectId != null &amp;&amp; projectId.length() &gt; 0) { if (!node.isLeaf()) { node.setExpand(!node.isExpand()); if (node.isExpand()) { for (ThemeInfo cNode : dmpList) { cNode.setLevel(node.getLevel() + 1); } showList.addAll(position + 1, dmpList); listViewSetAdapter(showList); } else { List&lt;ThemeInfo&gt; rmList = new ArrayList&lt;&gt;(); TopicUtil.getAllChildren(node, rmList, showList, false); showList.removeAll(rmList); listViewSetAdapter(showList); } TotalApplication.getListIdInstance().add(projectId); } } } else { if (projectId != null &amp;&amp; projectId.length() &gt; 0) { showList = dmpList; listViewSetAdapter(showList); TotalApplication.getListIdInstance().add(projectId); } } } } } 3. 开关按钮的点击事件： public static void projectSwitch(Context context, Handler handler, List&lt;ThemeInfo&gt; themeInfoList, ThemeInfo info, TopicAdapter.ViewHolder finalHolder, boolean isGradedData) { List&lt;ThemeInfo&gt; parents = new ArrayList&lt;&gt;(); TopicUtil.getAllParent(info, parents, themeInfoList, false); List&lt;ThemeInfo&gt; childrens = new ArrayList&lt;&gt;(); TopicUtil.getAllChildren(info, childrens, themeInfoList, false); String openStatus = info.getOpenStatus(); if (!openStatus.equals(Constants.TOPIC_STATUS_OFF)) { finalHolder.isOpen.setImageResource(R.mipmap.topic_off); info.setOpenStatus(Constants.TOPIC_STATUS_OFF); TopicUtil.closeCurrentNode(info, themeInfoList, false); } else { finalHolder.isOpen.setImageResource(R.mipmap.topic_on); info.setOpenStatus(Constants.TOPIC_STATUS_ON); for (ThemeInfo node : childrens) { node.setOpenStatus(Constants.TOPIC_STATUS_ON); } for (ThemeInfo node : parents) { node.setOpenStatus(Constants.TOPIC_STATUS_ON); } } if (JudgeNullUtil.ObjIsNull(info)) { return; } TopicUtil.topicSwitchVisible(context, info, handler, isGradedData); } 4.通过图层id显示专题图层： /** * 通过图层id显示专题图层。 * * @param context 上下文 * @param visibleInfos 当前需要显示的图层 */ public static void setLayerVisible(Context context, List&lt;ThemeInfo&gt; visibleInfos, String currentStatus) throws Exception { if (JudgeNullUtil.ObjIsNull(visibleInfos)) { return; } boolean isOpenLayer = false; if (!currentStatus.equals(Constants.TOPIC_STATUS_OFF)) { isOpenLayer = true; } if(App.isOnLineData){ onlineVisibleLayer(context, visibleInfos, isOpenLayer); }else{ offlineVisibleLayer(visibleInfos,isOpenLayer); } } 5.更新专题数据： /** * 更新专题某一层级数据或整个专题数据源 */ public static void updateThemeList(Context context, List&lt;ThemeInfo&gt; themeList) throws Exception { App appCtx = (App) context.getApplicationContext(); appCtx.getDataSource().setTheme(themeList); } /** * 更新子级目录专题数据 */ public static List&lt;ThemeInfo&gt; updateSubData(ThemeInfo subThemeInfo, List&lt;ThemeInfo&gt; themeList) throws Exception { if (subThemeInfo == null) { return themeList; } String currentId = subThemeInfo.getId(); if (currentId == null || JudgeNullUtil.ObjIsNull(themeList)) { return themeList; } List&lt;String&gt; subLayerIds = getSubLayerIds(currentId, themeList); if (JudgeNullUtil.ObjIsNull(subLayerIds)) { return themeList; } assert subLayerIds != null; for (int i = 0; i &lt; subLayerIds.size(); i++) { String subId = subLayerIds.get(i); subThemeInfo.setId(subId); String type = getThemeType(subThemeInfo, themeList); updateCurrentData(subThemeInfo, themeList); if (type == null) { continue; } if (type.equals(Constants.TYPE_CATLOG)) { updateSubData(subThemeInfo, themeList); } } return themeList; } 6. 更新layer数据：/** * 设置layer显示状态 * @param layer专题图层 * @param visibleIds 图层id */ public static void updateLayerVisible(Layer layer, int[] visibleIds, boolean isOpenLayer) throws Exception { if (layer == null) { return; } if (layer instanceof ArcGISDynamicMapServiceLayer) { ArcGISDynamicMapServiceLayer dynamicLayer = (ArcGISDynamicMapServiceLayer) layer; refreshDynamicLayer(visibleIds, dynamicLayer, isOpenLayer); } else { layer.setVisible(isOpenLayer); } } /** * 根据visibleIds 更新DymicLayer * @param visibleIds layer Ids * @param dynamicLayer 当前需要刷新的图层 */ private static void refreshDynamicLayer(int[] visibleIds, ArcGISDynamicMapServiceLayer dynamicLayer, boolean isOpenLayer) throws Exception { if (dynamicLayer == null) { return; } ArcGISLayerInfo[] arcGISLayerInfos = dynamicLayer.getAllLayers(); if (visibleIds.length &gt; arcGISLayerInfos.length) { return; } ArcGISLayerInfo layerInfo; for (int index : visibleIds) { if (index &lt; 0) { continue; } layerInfo = arcGISLayerInfos[index]; if (layerInfo == null) { continue; } boolean isVisible = layerInfo.isVisible(); ArcGISLayerInfo layerParentInfo = layerInfo.getParentLayer(); if (layerParentInfo != null) { boolean parentVisible = layerParentInfo.isVisible(); if (isOpenLayer) { if (!parentVisible) { layerParentInfo.setVisible(true); } } else { if (parentVisible) { layerParentInfo.setVisible(false); } } } if (isOpenLayer) { if (!isVisible) { layerInfo.setVisible(true); } } else { if (isVisible) { layerInfo.setVisible(false); } } } if (!dynamicLayer.isVisible()) { dynamicLayer.setVisible(true); } dynamicLayer.refresh(); } 结语专题模块的开发提高了项目的灵活性和通透性，大大缩短了用户点击搜索的时间，保证了多层级结构加载时层与层之间的联系不冲突，确保它们之间稳定性。查询时可通过坐标点查询多个图层所对应信息，大大缩短了查询效率，确保项目的顺利进行。为后期新功能迭代打下坚实基础，提高用户体验。]]></content>
      <categories>
        <category>mobile</category>
      </categories>
      <tags>
        <tag>移动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome-Devtool]]></title>
    <url>%2FXDATA.Blog%2F2018%2F08%2F14%2FTOOLS%2FChrome-Devtool%2F</url>
    <content type="text"><![CDATA[基于Chrome DevTools的Web应用程序的性能分析 ======= 前端页面渲染——原理：定义： 即是web用户在访问一个页面时所要花费的时间总和。即一个完全意义上的用户响应时间，相对于服务器的响应时间而言还会包括更多的内容和影响因素。那么一个web页面的完整请求包括了哪些部分的时间总和就是web前端性能分析和优化所需要了解的基础知识，先了解一下用户从浏览器访问一个url后到页面完全展示所有内容的整个过程吧。 页面请求的过程： 浏览器的url请求 递归寻找DNS服务器 连接目标IP并建立TCP连接 向目标服务器发送http请求 web服务器接收请求后处理 web服务器返回相应的结果【无效、重定向、正确页面等】 浏览器接收返回的http内容 页面解析的过程： Dom Tree：浏览器将html解析成一个dom树，dom树的创建时一个深遍历的过程。 Css Rule Tree：将css样式全部解析成Css Rule Tree的规则树。 Render Tree：将Dom Tree和Css Rule Tree结合进行Render Tree的构建，Render Tree不同于Dom Tree，它将一些没有必要渲染的dom节点进行了相应的处理，例如：header标签，display为none的标签元素等。 layout：有了Render Tree我们就可以对每个节点在屏幕中的位置进行计算处理。 paiting: 最后通过位置和样式进行相应的节点进行绘制展示在前端页面上。 影响前端流畅相应的因素（回流与重绘）减少Render Tree的回流和重绘，主要需要处理的是回流问题。定义：回流： Render Tree中的元素因为尺寸，布局，隐藏等改变而需要重新构建，这就叫做回流（reflow）。 重绘：当Render Tree的一部分元素需要更新元素，而这些元素只是外观，风格不影响布局，则叫做重绘。 注： 回流必定带来重绘，而重绘不一定会回流，回流带来页面渲染的工作量打，过多的回流容易造成页面的卡顿。 浏览器的优化策略：一般浏览器都会进行回流的优化处理，因为回流的代价比较大，所以如果每一个操作都需要进行回流处理，那么浏览器很容易承受不住，于是浏览器自身就进行了优化处理，将回流和重绘操作放置在一个队列中，在到达一定时间或者一定数量则进行批量的处理，这样将多次的回流和重绘操作减少成为一次的操作。 前端注意：一些操作可能提前强制浏览器对队列进行flush，例如在向浏览器请求一些style信息时就可能造成队列flush。 请求offsetTop、offsetLeft、offsetWidth、offsetHeight时 请求scrollTop、scrollLeft、scrollWidth、scrollHeight 请求clientTop、clientLeft、clentWidth、clientHeight 请求getComputedStyle()计算样式时 因为请求一些属性时，浏览器为了给精确的值，队列中的一些操作可能会影响到这些值，那么即使获取元素的布局和样式信息根最近发生或者改变的布局信息无关，浏览器都会强行刷新渲染队列。 减少回流的策略： 减少回流和重绘其实就是减少对Render Tree的操作，减少对一些style信息的请求，尽量利用浏览器的优化策略。 直接改变className，如果动态改变样式则使用cssText（考虑没有优化浏览器） // 不好的写法 var left = 1; var top = 1; el.style.left = left + &#39;px&#39;; el.style.top = top + &#39;px&#39;; // 比较好的写法 el.className = &#39;class1&#39;; 让操作元素进行“离线处理”，处理完一起更新a) 使用DocumentFragment进行缓存操作,引发一次回流和重绘； // 不好的写法 var p = document.createElement(&#39;p&#39;); var t = document.createTextNode(&#39;text1&#39;); p.appendChild(t); document.appendChild(p); // 引起一次回流 p = document.createElement(&#39;p&#39;); t = document.createTextNode(&#39;text2&#39;); p.appendChild(t); document.body.appendChild(p); // 又引起一次回流 // 比较好的写法 var farg = document.creatDocumentFragment(); var p = document.creatElement(&#39;p&#39;); var t = document.creatTextNode(&#39;text1&#39;); p.appendChild(t); farg.appendChild(p); p = document.creatElement(&#39;p&#39;); t = document.creatTextNode(&#39;text2&#39;); p.appendChild(t); farg.appendChild(p); document.body.appendChild(frag); // 这样只会引起一次回流 b) 使用display:none技术，只引发两次回流和重绘； var container = document.getElementById(&#39;div1&#39;); container.style.display = &#39;none&#39;; // 引起一次回流 for (var i = 0; i &lt; 10; i++) { var p = document.createElement(&#39;p&#39;); var t = document.creatTextNode(&#39;text&#39; + i); container.appendChild(p); } container.style.display = &#39;block&#39;; // 引起另外一次回流 c) 使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘； //建立克隆镜像 var oldNode = document.getElementById(&#39;target&#39;), clone = oldNode.cloneNode(true); //深复制 // 处理克隆对象的操作.... //完成后 oldNode.parentNode.replaceChild(clone,oldNode); 不要经常访问会flush队列的属性，如果确定要访问，则多利用缓存 // 不好的方式 for(循环) { el.style.left = el.offsetLeft + 5 + &#39;px&#39;; el.style.top = el.offsetTop + 5 + &#39;px&#39;; } // 好的方式 var left = el.offsetLeft, top = el.offsetTop, s = el.style; for (循环) { left += 10; top += 10; s.left = left + &#39;px&#39;; s.top = top + &#39;px&#39;; } 让元素脱离动画流，减少回流的Render Tree的规模 Performanance的使用Chrome Performance： 主要是用于页面性能分析，可进行页面状态、事件、运行、内存查看，通过操作页面查看性能情况，进行分析定位。Demo测试： https://googlechrome.github.io/devtools-samples/jank/ 1、先对移动方块进行添加，添加至页面进行卡顿，因为每台机器的性能不同，添加至一定数目之后才会造成卡顿 2、打开开发者工具进行performance的记录得到分析数据的展示情况。 1) 数据展示主要的花费事件在于Rendering 2) fps显示红色提醒，卡顿，缩放至细节查看 3) 点击有红色三角的Recalculate Style的调用栈。 发现有提示可能发生回流情况，点击reveal查看详细信息。 进入代码查看在app.js的70行代码发生了回流情况。 ![image](png7.png) 发现在其中多次访问了offsetTop的属性，造成了回流问题。 ![image](png8.png) 3、在采用另外一种优化性能方式查看代码（获取样式top缓存处理不多次访问），发现页面流畅了很多。 Memory的使用Chrome Memory： 主要是用于深度性能分析，提供记录场景运行、记录堆快照、记录堆分配等三个功能实现对渲染性能和内存泄漏的分析定位。 快照的方式Demo测试： https://handsome-hang.github.io/test/chrome/目前采用比较多的方式是是使用快照对比来完成，如图： 1、首先在初始化页面进行一次快照处理记录初始化状态。（基本参照） 2、然后进行点击添加按钮进行widget的创建添加。 3、接着进行删除操作对widget进行了移除处理，进行一次快照获取。 4、然后反复先前操作进行快照记录处理。 可以发现内存在一次次操作后得到的快照内存大小不断的在增长，这个时候就可以判断出应该是有内存泄漏没有被回收。 5、将获取的快照进行对比处理。 6、对引用类型（以Detached DOM 为例子）进行分析查看， #Delta是否有不断增加，如果有则是有异常内存泄漏。 7、查看详细增长内容有属性被哪些地方引用而导致没有办法回收，发现widget的一些信息没有被回收而一直存在。 8、通过删除操作找到对应的代码，来查看widget被移除操作中间发生了什么而导致widget内容没有被回收，发现index.html代码中有问题。 // 问题所在 domConstruct.destroy(window.container1.domNode); // 只是移除了dom节点，并没有对widget整个对象进行处理导致有引用存在 // 将widget进行整个摧毁处理调用destroy方法 window.container.destroy(); // 进行widget的摧毁处理 9、之后再次进行来看内存是否能够被及时的处理，发现内存增长停止了，并且Detached DOM增长没有了，内存被及时的回收防止了内存的泄漏。 Memory还有提供另外两个分析内存的工具。Collect JavaScript CPU Profile： 记录一段场景cpu的分配使用情况。 对其中对内存影响较大的，并且有提示的方法进行相应的注意和相应的处理 Record Heap Allocations： 一段记录堆分配内存进行处理 堆突出的蓝条，如果没有释放掉要进行特别注意并且分析其中的情况详情，如果没有释放则需要跟踪代码进行处理 内存泄漏的原因：（1）监听在window/document/body等handler事件没有解绑 （2）模块形成的闭包内部变量使用完后没有将引入变量设为null （3）使用第三方库创建，没有调用正确的销毁函数 （4）dom的移除若子节点存在引用则无法回收 （5）widget使用事件的订阅，在摧毁时没有移除 总结语在Performance中已经可以完成大多数的性能检测定位。而在其中Memory进行详细分析处理内存泄漏问题处理，使用工具处理问题是一部分解决方案，但是根源问题还是在于编码的规范问题，如果已经成熟的系统，在内存性能检测上是很麻烦的事情，所以内存性能检测是一个不断持续的过程。 内容中如果出现什么有错误的地方请及时的提醒，以便进行及时的修正。]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>chrome devtool 性能分析 内存泄露</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动用地分析]]></title>
    <url>%2FXDATA.Blog%2F2018%2F08%2F13%2FMOBILE%2F%E7%94%A8%E5%9C%B0%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[移动用地分析功能 简介 用地分析是指在对地区各自然要素进行综合分析研究的基础上，按照城市规划和建设要求、用地整备工程技术的可能性和经济性，对城市规划用地进行适用性分析评定，以划出城市用地的不同等级。另外用于查清村和农、林、牧、渔场，居民点及其以外的独立工矿企事业单位土地权属界线和村以上各级行政界线，查清各类用地面积、分布和利用状况。在本文中，用地分析主要实现为对所选中区域进行土地类别、面积和分布的识别与判断，计算其中各个层级占其父级的百分比以及面积情况。* 实现逻辑略析 可视化与相关功能操作窗口的基本实现 加载功能基础的地图底图与分析操作图层 分析区域的选择并获取当前图形 离线调用FeatureQuery（在线调用QueryTask）进行要素查询与过滤 获得结果FeatureResult，从中获取Geometry（并非与绘制图形做过交叉处理的Geometry）与Attribute 图形切割与面积计算 通过GraphicLayer进行图形展示以及图形条组与相应控件Item绑定 重要部分代码实现 1.分析区域选择 //通过多点集合绘制几何图形 polygon.lineTo(currentPoint); currentGraphic = new Graphic(polygon, symbol); drawLayer.updateGraphic(currentGraphicIndex,currentGraphic); pointGraphic=new Graphic(multiPoint,pointSymbol); drawLayer.updateGraphic(pointGraphicIndex,pointGraphic); multiPoint.add(currentPoint); if(lastGraphicIndex!=-1){ drawLayer.removeGraphic(lastGraphicIndex); } lastGraphic=new Graphic(currentPoint,lastSymbol); lastGraphicIndex=drawLayer.addGraphic(lastGraphic); 2.地图查询 离线查询 离线查询通过初始化一个QueryParameter并设置其参数，调用FeatureLayer对象的QueryFeature方法进行查询，拿到查询结果的Geometry与Attribute。 QueryParameters queryParams=new QueryParameters(); //设置区域 if (isALL) { queryParams.setGeometry(mapView_main.getExtent()); }else { Polygon queryPolygon=measureManager.getpolygon(); queryParams.setGeometry(queryPolygon); } //设置过滤字段 queryParams.setOutFields(new String[]{&quot;*&quot;}); landAnalysisResultInfos=new ArrayList&lt;&gt;(); List&lt;LandAnalysisResultInfo&gt; analysisResultInfos=new ArrayList&lt;&gt;(); Future&lt;FeatureResult&gt; resultFuture=null; FeatureResult featureResult=null; FeatureLayer featureLayer=(FeatureLayer)layer; resultFuture=featureLayer.getFeatureTable().queryFeatures(queryParams,callbackListener); try { //获取结果 featureResult=resultFuture.get(); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } if (featureResult!=null&amp;&amp;featureResult.featureCount()&gt;0) { Iterator it = featureResult.iterator(); while (it.hasNext()){ GeodatabaseFeature geodatabaseFeature= (GeodatabaseFeature) it.next(); Geometry geometry=geodatabaseFeature.getGeometry(); &lt;String, Object&gt; featureMap=geodatabaseFeature.getAttributes(); if(geometry!=null){ //进行图形处理 } if (featureMap!=null&amp;&amp;featureMap.size()&gt;0) { //进行内容详情提取处理 } } 在线查询 在线查询通过初始化一个QueryParameter并设置其参数，然后通过在线图层的URL初始化一个QueryTask，通过其对象的execute方法拿到查询结果的Geometry与Attribute。 QueryParameters queryParams=new QueryParameters(); Polygon Querypolygon=measureManager.getpolygon(); queryParams.setGeometry(Querypolygon); landAnalysisResultInfos=new ArrayList&lt;&gt;(); queryParams.setOutFields(new String[]{&quot;*&quot;}); List&lt;LandAnalysisResultInfo&gt; analysisResultInfos=new ArrayList&lt;&gt;(); Future&lt;FeatureResult&gt; resultFuture=null; FeatureResult featureResult=null; ArcGISDynamicMapServiceLayer featureLayer=(ArcGISDynamicMapServiceLayer)layer; QueryTask queryTask=new QueryTask(featureLayer.getQueryUrl(0)); resultFuture=queryTask.execute(queryParams, callbackListener); try { featureResult=resultFuture.get(); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } if (featureResult!=null&amp;&amp;featureResult.featureCount()&gt;0) { for (Object element : featureResult) { if (element instanceof Feature) { Feature f = (Feature) element; Geometry geometry=f.getGeometry(); Map&lt;String, Object&gt; featureMap=f.getAttributes(); if(geometry!=null){ //进行图形处理 } if (featureMap!=null&amp;&amp;featureMap.size()&gt;0) { //进行内容详情提取处理 } } } } 3.图形交叉处理 通过调用GeometeyEngine.intersect()方法获取。 Geometry geometry = GeometryEngine.intersect(geometry,measureManager.getpolygon(),mapView_main.getSpatialReference()); 4.面积计算 由于获取的Geometry的面积与其父Geometry的面积均为调用Geometry对象的calculateArea2D()方法，并非实际面积。所以我们需要通过Attribute获得的实际面积计算切割Geometry与其父Geometry的实际面积，并计算其百分比。 /** *通过在地图上的Area大小计算百分比与实际面积 * * @param landResourceInfos 分析结果的数组 成员： {@link LandAnalysisResultInfo} * @return 一个结果的数组 变更了参数数组中成员的属性 */ public static List&lt;LandAnalysisResultInfo&gt; getLandPercentValue(List&lt;LandAnalysisResultInfo&gt; landResourceInfos){ /*计算实际面积 */ double MUM=0; for (LandAnalysisResultInfo landResourceInfo : landResourceInfos) { if (landResourceInfo.getYDMJ()==null) { landResourceInfos.remove(landResourceInfo); continue; } Double visualArea=landResourceInfo.getGeometry().calculateArea2D(); Double visualParentArea=landResourceInfo.getParentGeometry().calculateArea2D(); Double realArea=landResourceInfo.getYDMJ()/visualParentArea*visualArea; landResourceInfo.setYDMJ(realArea); //累计求和 MUM=MUM+landResourceInfo.getYDMJ(); } /*分别计算百分比*/ for (LandAnalysisResultInfo landResourceInfo : landResourceInfos) { landResourceInfo.setPercentValue(String.valueOf(landResourceInfo.getYDMJ()/MUM*100)); } return landResourceInfos; } 5.图形展示 由于本次使用为列表显示，故图形展示在点击子Item的时候进行Geometry的绘制与添加。 /** * 结果列表点击效果 */ private AdapterView.OnItemClickListener resultListOnItemClickListener =new AdapterView.OnItemClickListener() { @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) { resultDrawerLayer.removeAll(); resultDrawerLayer.addGraphic(new Graphic(landAnalysisResultInfos.get(position).getGeometry(), MapViewTapTool.getLabelSymbol(MainMapActivity.this,Geometry.Type.POLYGON, Color.BLUE))); resultDrawerLayer.addGraphic(new Graphic(landAnalysisResultInfos.get(position).getParentGeometry(),MapViewTapTool.getLabelSymbol(MainMapActivity.this,Geometry.Type.POLYLINE, Color.BLACK))); Envelope tempEnvelope = new Envelope(); landAnalysisResultInfos.get(position).getParentGeometry().queryEnvelope(tempEnvelope); Point tempPoint = tEnvelope.getCenter(); mapView_main.centerAt(tempPoint,true); } }; 结语 &emsp;&emsp;用地分析功能的开发，既减少了用户查看地图计算面积的时间，提高了地图的可阅读性。让用户通过移动设备简单的操作即可获取选取区域中各类型的板块内容与面积，并通过绘制图层让用户在地图上更直观的看清板块对象。 相关关键代码查看 &emsp;]]></content>
      <categories>
        <category>mobile</category>
      </categories>
      <tags>
        <tag>移动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动在线缓存功能]]></title>
    <url>%2FXDATA.Blog%2F2018%2F08%2F10%2FMOBILE%2F%E5%9C%A8%E7%BA%BF%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[#1. 简介 离线在线一体化数据存储在企业级地理数据库中，通过Arcgis桌面加载后配图处理，并发布到Arcgis for Server中，供移动端设备编辑使用，并可以同步回传版本化存档。 应用场景在没有网络的情况下我们需要用到在线的地图数据进行操作，这些数据需要有一定的时效性，如果采用，打包离线包的方式提前做好离线数据，那时效性相对较差。所以，用在线缓存技术可以支持这一点。#2. 在线缓存的实现逻辑思路 在地图上选定区域，作为需要下载对应离线数据的地图范围（可以设定范围，也可以自定义） 获取下载滴地图服务所需要的具体参数 在本地创建文件，存放下载的数据，以供使用#3. 用到的核心功能类以及说明 GeodatabaseSyncTask类，实现下载同步功能 GenerateGeodatabaseParameters，下载数据时所需的参数对象，该类构造函数一共有7个根据需要选择 CallbackListener，完成GDB数据库下载的回调函数类，在该回调中我们只可以执行一些操作，如示例里在回调中删除了在线的服务图层，加载离线的数据图层到地图上进行显示。通过Geodatabase本地数据库可以获取要素图层列表List&lt;GdbFeatureTable&gt;对象，通过newFeatureLayer(gdbFeatureTable)来创建一个离线要素图层进行要素显示。 GeodatabaseStatusCallback，本地数据库回调状态类，在数据下载过程中会有很多状态改变，各种状态改变时都会走这个类的回调函数。 GeodatabaseTask.generateGeodatabase，通过该方法生成离线数据库和相应的要素表，方法需要传递上面介绍的三个参数和一个数据库存储的路径。#4. 代码示例 在地图上自定义一个区域 /** * 绘制出在线缓存区域 * */ private void polygonState(Point currentPoint)throws Exception{ if(startPoint!=null&amp;&amp;!startPoint.isEmpty()){ polygon.lineTo(currentPoint); currentGraphic = new Graphic(polygon, symbol); drawLayer.updateGraphic(currentGraphicIndex,currentGraphic); pointGraphic=new Graphic(multiPoint,pointSymbol); drawLayer.updateGraphic(pointGraphicIndex,pointGraphic); multiPoint.add(currentPoint); if(lastGraphicIndex!=-1){ drawLayer.removeGraphic(lastGraphicIndex); } lastGraphic=new Graphic(currentPoint,lastSymbol); lastGraphicIndex=drawLayer.addGraphic(lastGraphic); if(polygon.getPointCount()&gt;=3){ isCheckedSave=true; isSave=isCheckedSave; onlinesave.setTextColor(ContextCompat.getColor(mActivity,R.color.blue)); onlinesave.setClickable(isSave); } }else{ polygon=new Polygon(); multiPoint=new MultiPoint(); polygon.startPath(currentPoint); startPoint=currentPoint; currentGraphic=new Graphic(startPoint,symbol); currentGraphicIndex=drawLayer.addGraphic(currentGraphic); pointGraphic=new Graphic(startPoint,lastSymbol); pointGraphicIndex=drawLayer.addGraphic(pointGraphic); multiPoint.add(currentPoint); } } /** * 确定所选区域范围 * */ public void SaveLabel()throws Exception{ if(isSave&amp;&amp;drawLayer!=null) { startPoint = null; isCheckedSave=false; isSave=isCheckedSave; onlinesave.setTextColor(ContextCompat.getColor(mActivity,R.color.gray)); onlinesave.setClickable(isSave); if(currentGraphicIndex!=-1){ Graphic graphic = drawLayer.getGraphic(currentGraphicIndex); if(graphic!=null){ Geometry geometry=graphic.getGeometry(); Graphic saveGraphic=null; if(geometryType.equals(Geometry.Type.POLYGON)){ symbol=MapViewTapTool.getLabelSymbol(mActivity,geometryType,ContextCompat.getColor(mActivity,R.color.green_transparent)); saveGraphic=new Graphic(geometry,symbol); pointSymbol=MapViewTapTool.getCircleGreenSymbol(mActivity); pointGraphic=new Graphic(geometry,pointSymbol); }else{ symbol=MapViewTapTool.getLabelSymbol(mActivity,geometryType,ContextCompat.getColor(mActivity,R.color.green)); saveGraphic=new Graphic(geometry,symbol); pointSymbol=MapViewTapTool.getCircleGreenSymbol(mActivity); pointGraphic=new Graphic(geometry,pointSymbol); } if(onlineCacheInfoList!=null&amp;&amp;onlineCacheInfoList.size()&gt;0){ setView(); int i = 0; if(onlineCacheInfoList.get(i).getCacheurl().trim().length()&gt;0) { downloadData(onlineCacheInfoList.get(i), geometry, i);//缓存featureLayer } } } } }else{ isCheckedSave=false; isSave=isCheckedSave; onlinesave.setTextColor(ContextCompat.getColor(mActivity,R.color.gray)); onlinesave.setClickable(isSave); } } 下载选定区域所对应的在线缓存的文件 private void downloadData(final OnlineCacheInfo onlineCacheInfo, final Geometry geometry, final int i) { gdbSyncTask = new GeodatabaseSyncTask(onlineCacheInfo.getCacheurl(), null); gdbSyncTask.fetchFeatureServiceInfo(new CallbackListener&lt;FeatureServiceInfo&gt;() { @Override public void onError(Throwable arg0) { Log.e(TAG, &quot;Error fetching FeatureServiceInfo&quot;); } @Override public void onCallback(FeatureServiceInfo fsInfo) { if (fsInfo.isSyncEnabled()) { //回调获取所需要的下载的图层信息 createGeodatabase(onlineCacheInfo.getIds(),geometry,i); } } }); } //创建下载 private void createGeodatabase(int[] ids, final Geometry geometry, final int i) { SpatialReference sp=mOneMapView.getSpatialReference(); GenerateGeodatabaseParameters params = new GenerateGeodatabaseParameters(ids, geometry,sp,true, SyncModel.GEODATABASE); CallbackListener&lt;String&gt; gdbResponseCallback = new CallbackListener&lt;String&gt;() { @Override public void onError(final Throwable e) { Log.e(TAG, &quot;Error creating geodatabase&quot;); Toast.makeText(mActivity, &quot;数据下载失败!&quot;, Toast.LENGTH_LONG).show(); pDialog.dismiss(); } @Override public void onCallback(String path) { updateFeatureLayer(path); if(i&lt;onlineCacheInfoList.size()&amp;&amp;onlineCacheInfoList.get(i+1).getCacheurl().trim().length()&gt;0){ downloadData(onlineCacheInfoList.get(i+1),geometry,i+1); }else { pDialog.dismiss(); Toast.makeText(mActivity, &quot;数据下载完成!&quot;, Toast.LENGTH_LONG).show(); } } }; localGdbFilePath = &quot;对应在本地存储的存储路径以及存储名称&quot;; submitTask(params, localGdbFilePath, statusCallback, gdbResponseCallback); } private void submitTask(GenerateGeodatabaseParameters params, String file, GeodatabaseStatusCallback statusCallback, CallbackListener&lt;String&gt; gdbResponseCallback) { // submit task gdbSyncTask.generateGeodatabase(params, file, false, statusCallback, gdbResponseCallback); } 将下载完成的数据再地图上展示 //加载数据 private void updateFeatureLayer(String featureLayerPath) { // create a new geodatabase Geodatabase localGdb = null; try { localGdb = new Geodatabase(featureLayerPath); } catch (FileNotFoundException e) { e.printStackTrace(); } if (localGdb != null) { for (GeodatabaseFeatureTable gdbFeatureTable : localGdb .getGeodatabaseTables()) { if (gdbFeatureTable.hasGeometry()){ mOneMapView.addLayer(new FeatureLayer(gdbFeatureTable)); } } } } #5. 结语在线缓存的应用，减少了手动制作离线数据的步骤，大大提高了地图制作的效率，只需发布对应的地图服务就能实现离线数据的在线下载。另外也同时保证了数据的时效性，如果对应地图服务有新的数据更改，那我们可以重新下载新的在线数据，不需要再去手动打包地图文件。 最后感谢您的阅读，有机会一起探讨！]]></content>
      <categories>
        <category>mobile</category>
      </categories>
      <tags>
        <tag>移动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World With Hexo]]></title>
    <url>%2FXDATA.Blog%2F2018%2F08%2F10%2FHEXO%2Fhello-world%2F</url>
    <content type="text"><![CDATA[快速开始创建一篇新的博客$ hexo new &quot;My New Post&quot; 详情: Writing 启动服务器$ hexo server 详情: Server 生成博客静态文件$ hexo generate 详情: Generating 发布到服务器$ hexo deploy 详情: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 配置完善]]></title>
    <url>%2FXDATA.Blog%2F2018%2F08%2F10%2FHEXO%2FHexo%E9%85%8D%E7%BD%AE%E5%AE%8C%E5%96%84%2F</url>
    <content type="text"><![CDATA[hexo搭建后,我们需要加入许多个性化功能,在此进行记录. 添加返回顶部按钮 打开\themes\landscape\layout_partial,新建文件名称为totop.ejs. &lt;div id=&quot;totop&quot;&gt; &lt;a title=&quot;javascript:;&quot;&gt;返回&lt;br&gt;顶部&lt;/a&gt; &lt;/div&gt; 打开\themes\landscape\source\js,新建文件totop.js. (function($) { var upperLimit = 1000; // Our scroll link element var scrollElem = $(&#39;#totop&#39;); // Scroll to top speed var scrollSpeed = 1600; scrollElem.hide(); $(window).scroll(function () { var scrollTop = $(document).scrollTop(); if ( scrollTop &gt; upperLimit ) { $(scrollElem).stop().fadeTo(300, 1); }else{ $(scrollElem).stop().fadeTo(300, 0); } }); $(scrollElem).click(function(){ $(&#39;html, body&#39;).animate({scrollTop:0}, scrollSpeed); return false; }); })(jQuery); 打开\themes\landscape\layout_partial\after_footer.ejs,添加代码 &lt;%- partial(&#39;totop&#39;) %&gt; &lt;script src=&quot;&lt;%- config.root %&gt;js/totop.js&quot;&gt;&lt;/script&gt; 设置样式,打开\themes\landscape\source\css_partial,创建文件totop.styl,添加样式代码 #totop position:fixed bottom:50px right:30px text-align: center z-index: 100 a display: block padding 4px 8px color: #fff background-color: #258fb8 cursor: pointer border-radius: 5px &amp;:hover opacity: .8 打开\themes\landscape\source\css\style.styl,添加代码 @import &quot;_partial/totop&quot;]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebPack4入门]]></title>
    <url>%2FXDATA.Blog%2F2018%2F07%2F10%2FWEBPACK%2FWebpack4%E5%8F%8A%E6%A8%A1%E5%9D%97%E7%BB%91%E5%AE%9A%E5%85%A5%E9%97%A8%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[Webpack4及模块绑定入门手册 本文在我们的书《现代JavaScript工具和技能》中有所介绍。 让我们一起熟悉支持现代JavaScript开发的基本工具。 Webpack4 文档中说到： Webpack是一个module bundler。 它的主要目的是捆绑JavaScript文件以便在浏览器中使用，但它也能够转换，捆绑或打包任何资源。 Webpack已成为现代Web开发最重要的工具之一。 它主要是JavaScript的module bundler，但它可以用来转换所有前端资源，如HTML，CSS，甚至图像。 它可以让您更好地控制应用程序正在进行的HTTP请求的数量，并允许您使用其他类型的这些资源（例如，Pug，Sass和ES8）。 Webpack还允许您轻松地从npm使用包。 本文面向那些刚接触Webpack的人，将介绍初始设置和配置，模块，加载器（loaders），插件，代码拆分和热模块更换。 如果您发现视频教程很有帮助，我强烈推荐Glen Maddern的Webpack from First Principles 作为起点，了解Webpack的特殊之处。 它现在有点旧了，但原则仍然相同，这是一个很好的介绍。 要在家中进行操作，您需要安装Node.js. 您也可以从我们的GitHub仓库下载演示应用程序。 开始让我们用npm初始化一个新项目并安装webpack和webpack-cli： mkdir webpack-demo &amp;&amp; cd webpack-demo npm init -y npm install --save-dev webpack webpack-cli 接下来我们将创建下面文件结构和内容： webpack-demo |- package.json |- webpack.config.js |- /src |- index.js |- /dist |- index.html dist/index.html &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Hello Webpack&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; src/index.js const root = document.createElement(&quot;div&quot;) root.innerHTML = `&lt;p&gt;Hello Webpack.&lt;/p&gt;` document.body.appendChild(root) webpack.config.js const path = require(&#39;path&#39;) module.exports = { entry: &#39;./src/index.js&#39;, output: { filename: &#39;bundle.js&#39;, path: path.resolve(__dirname, &#39;dist&#39;) } } 这告诉Webpack在我们的入口点src / index.js中编译代码并在/dist/bundle.js中输出一个bundle。 我们来添加一个用于运行Webpack的npm脚本。 package.json { ... &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;develop&quot;: &quot;webpack --mode development --watch&quot;, &quot;build&quot;: &quot;webpack --mode production&quot; }, ... } 使用npm run develop命令，我们可以创建我们的第一个包！ Asset Size Chunks Chunk Names bundle.js 2.92 KiB main [emitted] main 您现在应该可以在浏览器中加载dist / index.html并看到“Hello Webpack”。 打开dist / bundle.js以查看Webpack的功能。 顶部是Webpack的模块引导代码，底部是我们的模块。 你可能对此还没有很深刻的印象，但是如果你已经走到这一步，你现在可以开始使用ES模块，而Webpack将能够生成一个适用于所有浏览器的生产包。 使用Ctrl + C重新编译并运行npm run build以在生产模式下编译我们的bundle。 Asset Size Chunks Chunk Names bundle.js 647 bytes main [emitted] main 请注意，捆绑包大小已从2.92 KiB降至647字节。 再看一下dist / bundle.js，你会看到一堆丑陋的代码。 我们的软件包已经用UglifyJS缩小了：代码将运行完全相同，但它是以尽可能小的文件大小完成的。 模式开发优化了构建速度和调试 模式生产优化了运行时的执行速度和输出文件大小。 模块使用ES模块，您可以将大型程序拆分为许多小型自包含程序。 创造性地，Webpack知道如何使用导入和导出语句来使用ES模块。 举个例子，让我们现在通过安装lodash-es并添加第二个模块来尝试这个： npm install --save-dev lodash-es src/index.js import { groupBy } from &quot;lodash-es&quot; import people from &quot;./people&quot; const managerGroups = groupBy(people, &quot;manager&quot;) const root = document.createElement(&quot;div&quot;) root.innerHTML = `&lt;pre&gt;${JSON.stringify(managerGroups, null, 2)}&lt;/pre&gt;` document.body.appendChild(root) src/people.js const people = [ { manager: &quot;Jen&quot;, name: &quot;Bob&quot; }, { manager: &quot;Jen&quot;, name: &quot;Sue&quot; }, { manager: &quot;Bob&quot;, name: &quot;Shirley&quot; } ] export default people 运行npm run develop启动Webpack并刷新index.html。 您应该看到按管理器分组的一组人员打印到屏幕上。 注意：导入一个像‘es-lodash’这样没有相对路径的模块，是从npm安装到 node_modules的模块。 你自己的模块总是需要一个像‘./people’这样的相对路径，因此你可以区分它们。 请注意，在控制台中我们的捆绑包大小已增加到1.41 MiB！ 这值得关注，但在这种情况下，没有理由担心。 使用npm run build在生产模式下编译，lodash-es中的所有未使用的lodash模块都将从bundle中删除。 删除未使用的导入的过程称为tree-shaking，并且是Webpack免费获得的。 &gt; npm run develop Asset Size Chunks Chunk Names bundle.js 1.41 MiB main [emitted] [big] main &gt; npm run build Asset Size Chunks Chunk Names bundle.js 16.7 KiB 0 [emitted] main 装载加载程序允许您在导入文件时运行预处理程序。 这允许您将静态资源捆绑到JavaScript之外，但让我们看看在首先加载.js模块时可以做些什么。 让我们通过下一代JavaScript转换器Babel运行所有.js文件来保持代码的现代化： npm install --save-dev &quot;babel-loader@^8.0.0-beta&quot; @babel/core @babel/preset-env webpack.config.js const path = require(&#39;path&#39;) module.exports = { entry: &#39;./src/index.js&#39;, output: { filename: &#39;bundle.js&#39;, path: path.resolve(__dirname, &#39;dist&#39;) }, module: { rules: [ { test: /\.js$/, exclude: /(node_modules|bower_components)/, use: { loader: &#39;babel-loader&#39;, } } ] } } .babelrc { &quot;presets&quot;: [ [&quot;@babel/env&quot;, { &quot;modules&quot;: false }] ], &quot;plugins&quot;: [&quot;syntax-dynamic-import&quot;] } 此配置可防止Babel将导入和导出语句转换为ES5，并启用动态导入，这个我们将在后面的“代码拆分”一节中介绍。 我们现在可以自由使用现代语言功能，它们将被编译为在所有浏览器中运行的ES5。 SassLoaders可以链接在一起进行一系列变换。 从我们的JavaScript导入Sass可以较好地演示它是如何工作的： npm install --save-dev style-loader css-loader sass-loader node-sass webpack.config.js module.exports = { ... module: { rules: [ ... { test: /\.scss$/, use: [{ loader: &#39;style-loader&#39; }, { loader: &#39;css-loader&#39; }, { loader: &#39;sass-loader&#39; }] } ] } } 这些加载器以相反的顺序处理: sass-loader将Sass转换为CSS。 css-loader将CSS解析为JavaScript并解析任何依赖项。 style-loader将我们的CSS输出到文档中的&lt;style>标记中。 您可以将这些视为函数调用。 一个加载器的输出作为输入提供给下一个： styleLoader(cssLoader(sassLoader(&quot;source&quot;))) 让我们添加一个Sass源文件，import是一个模块。 src/style.scss $bluegrey: #2b3a42; pre { padding: 8px 16px; background: $bluegrey; color: #e1e6e9; font-family: Menlo, Courier, monospace; font-size: 13px; line-height: 1.5; text-shadow: 0 1px 0 rgba(23, 31, 35, 0.5); border-radius: 3px; } src/index.js import { groupBy } from &#39;lodash-es&#39; import people from &#39;./people&#39; import &#39;./style.scss&#39; ... 使用Ctrl + C和npm run develop重新启动构建。 在浏览器中刷新index.html，您应该看到一些样式。 JS中的样式表我们刚从JavaScript中导入了一个Sass文件作为模块。 打开dist / bundle.js并搜索“pre {”。 实际上，我们的Sass已被编译为一串CSS并在我们的包中保存为模块。 当我们将这个模块导入JavaScript时，style-loader将字符串输出到嵌入的&lt;style>标记中。 你为什么需要做这样的事？ 我不会在这里深入研究这个主题，但这里有几个理由需要考虑： 您可能希望包含在项目中的JavaScript组件可能依赖于其他资源才能正常运行（HTML，CSS，图像，SVG）。 如果这些都可以捆绑在一起，则导入和使用起来要容易得多。 消除Dead code：当代码不再导入JS组件时，也不再导入CSS。 生成的包只会包含执行某些操作的代码。 CSS模块：CSS的全局命名空间使得很难确信对CSS的更改不会产生任何副作用。 CSS模块通过设置CSS默认本地并显示您可以在JavaScript中引用的唯一类名来解决该问题。 通过巧妙的方式捆绑/拆分代码来减少HTTP请求的数量。 图片我们将看到的最后一个加载器示例是使用文件加载器处理图像。 在标准HTML文档中，当浏览器遇到img标记或具有background-image属性的元素时，将获取图像。 使用Webpack，您可以在小图像的情况下通过将图像源作为字符串存储在JavaScript中来优化它。 通过执行此操作，您可以预加载它们，浏览器不必在以后使用单独的请求获取它们： npm install --save-dev file-loader webpack.config.js module.exports = { ... module: { rules: [ ... { test: /\.(png|svg|jpg|gif)$/, use: [ { loader: &#39;file-loader&#39; } ] } ] } } 用以下命令下载一个测试图像： curl https://raw.githubusercontent.com/sitepoint-editors/webpack-demo/master/src/code.png --output src/code.png 使用Ctrl + C和npm run develop重新启动构建，您现在可以将图像作为模块导入！ src/index.js import { groupBy } from &#39;lodash-es&#39; import people from &#39;./people&#39; import &#39;./style.scss&#39; import &#39;./image-example&#39; ... src/image-example.js import codeURL from &quot;./code.png&quot; const img = document.createElement(&quot;img&quot;) img.src = codeURL img.style = &quot;background: #2B3A42; padding: 20px&quot; img.width = 32 document.body.appendChild(img) 这将包括一个图像，其中src属性包含图像本身的数据URI： &lt;img src=&quot;data:image/png;base64,iVBO...&quot; style=&quot;background: #2B3A42; padding: 20px&quot; width=&quot;32&quot;&gt; 我们的CSS中的背景图像也由文件加载器处理。 src/style.scss $bluegrey: #2b3a42; pre { padding: 8px 16px; background: $bluegrey; background: $bluegrey url(&quot;code.png&quot;) no-repeat center center / 32px 32px; color: #e1e6e9; font-family: Menlo, Courier, monospace; font-size: 13px; line-height: 1.5; text-shadow: 0 1px 0 rgba(23, 31, 35, 0.5); border-radius: 3px; } 在文档中查看更多Loaders示例： 加载字体 加载数据 依赖图 Dependency Graph您现在应该能够看到加载器如何帮助您在资源中构建依赖关系树。 这就是Webpack主页上的图像所展示的内容。 尽管JavaScript是切入点，但Webpack明白您的其他资源类型（如HTML，CSS和SVG）各自具有自己的依赖关系，这应该被视为构建过程的一部分。 代码拆分Webpack文档中写到： 代码拆分是Webpack最引人注目的功能之一。 此功能允许您将代码拆分为各种捆绑包，然后可以按需或并行加载。 它可用于实现更小的捆绑并控制资源负载优先级，如果使用得当，可能会对加载时间产生重大影响。 到目前为止，我们只看到了一个入口点 - src / index.js - 和一个输出包 - dist / bundle.js。 当您的应用程序增长时，您需要将其拆分，以便在开始时不会下载整个代码库。 一种好的方法是使用Code Splitting和Lazy Loading来按需获取内容，因为代码路径需要它们。 我们通过添加一个“聊天”模块来证明这一点，该模块在有人与之交互时被提取和初始化。 我们将创建一个新的入口点并为其命名，我们还将使输出的文件名动态，因此每个块的不同。 webpack.config.js const path = require(&#39;path&#39;) module.exports = { entry: &#39;./src/index.js&#39;, entry: { app: &#39;./src/app.js&#39; }, output: { filename: &#39;bundle.js&#39;, filename: &#39;[name].bundle.js&#39;, path: path.resolve(__dirname, &#39;dist&#39;) }, ... } src/app.js import &#39;./app.scss&#39; const button = document.createElement(&quot;button&quot;) button.textContent = &#39;Open chat&#39; document.body.appendChild(button) button.onclick = () =&gt; { import(/* webpackChunkName: &quot;chat&quot; */ &quot;./chat&quot;).then(chat =&gt; { chat.init() }) } src/chat.js import people from &quot;./people&quot; export function init() { const root = document.createElement(&quot;div&quot;) root.innerHTML = `&lt;p&gt;There are ${people.length} people in the room.&lt;/p&gt;` document.body.appendChild(root) } src/app.scss button { padding: 10px; background: #24b47e; border: 1px solid rgba(#000, .1); border-width: 1px 1px 3px; border-radius: 3px; font: inherit; color: #fff; cursor: pointer; text-shadow: 0 1px 0 rgba(#000, .3), 0 1px 1px rgba(#000, .2); } 注意：尽管/ webpackChunkName / comment为包提供了名称，但此语法不是特定于Webpack的。 它是动态导入的建议语法，旨在直接在浏览器中支持。 我们运行npm run build并查看它生成的内容： Asset Size Chunks Chunk Names chat.bundle.js 377 bytes 0 [emitted] chat app.bundle.js 7.65 KiB 1 [emitted] app 由于我们的条目包已经更改，我们还需要更新它的路径。 dist/index.html &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Hello Webpack&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;app.bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 我们从dist目录启动一个服务器，看看这个实际应用： cd dist npx serve 在浏览器中打开http://localhost:5000，看看会发生什么。 最初只获取bundle.js。 单击该按钮时，将导入并初始化聊天模块。 只需很少的工作，我们就可以在我们的应用程序中添加动态代码拆分和延迟加载模块。 这是构建高性能Web应用程序的一个很好的起点。 插件当加载器对单个文件进行转换时，插件可以在更大的代码块上运行。 现在我们正在打包代码，外部模块和静态资产，我们的包将会迅速增长。 插件可以帮助我们以巧妙的方式分割代码并优化生产。 在不知情的情况下，我们实际上已经使用了许多默认的Webpack插件“模式” 发展 提供process.env.NODE_ENV，其值为“development” NamedModulesPlugin 生产 提供process.env.NODE_ENV，其值为“production” UglifyJsPlugin ModuleConcatenationPlugin NoEmitOnErrorsPlugin 产品在添加其他插件之前，我们首先拆分我们的配置，以便我们可以应用特定于每个环境的插件。 将webpack.config.js重命名为webpack.common.js并添加用于开发和生产的配置文件。 - |- webpack.config.js + |- webpack.common.js + |- webpack.dev.js + |- webpack.prod.js 我们将使用webpack-merge将我们的公共配置与特定于环境的配置相结合： npm install --save-dev webpack-merge webpack.dev.js const merge = require(&#39;webpack-merge&#39;) const common = require(&#39;./webpack.common.js&#39;) module.exports = merge(common, { mode: &#39;development&#39; }) webpack.prod.js const merge = require(&#39;webpack-merge&#39;) const common = require(&#39;./webpack.common.js&#39;) module.exports = merge(common, { mode: &#39;production&#39; }) package.json &quot;scripts&quot;: { &quot;develop&quot;: &quot;webpack --watch --mode development&quot;, &quot;build&quot;: &quot;webpack --mode production&quot; &quot;develop&quot;: &quot;webpack --watch --config webpack.dev.js&quot;, &quot;build&quot;: &quot;webpack --config webpack.prod.js&quot; }, 现在我们可以将特定于开发的插件添加到webpack.dev.js和webpack.prod.js中特定于生产的插件中。 拆分CSS在使用ExtractTextWebpackPlugin捆绑生产时，最好将CSS与JavaScript分开。 当前的.scss加载器非常适合开发，所以我们将把它们从webpack.common.js移到webpack.dev.js中，并将ExtractTextWebpackPlugin添加到webpack.prod.js中。 npm install --save-dev extract-text-webpack-plugin@4.0.0-beta.0 webpack.common.js ... module.exports = { ... module: { rules: [ ... - { - test: /\.scss$/, - use: [ - { - loader: &#39;style-loader&#39; - }, { - loader: &#39;css-loader&#39; - }, { - loader: &#39;sass-loader&#39; - } - ] - }, ... ] } } webpack.dev.js const merge = require(&#39;webpack-merge&#39;) + const ExtractTextPlugin = require(&#39;extract-text-webpack-plugin&#39;) const common = require(&#39;./webpack.common.js&#39;) module.exports = merge(common, { mode: &#39;production&#39;, module: { rules: [ { test: /\.scss$/, use: ExtractTextPlugin.extract({ fallback: &#39;style-loader&#39;, use: [&#39;css-loader&#39;, &#39;sass-loader&#39;] }) } ] }, plugins: [ new ExtractTextPlugin(&#39;style.css&#39;) ] }) 我们来比较两个构建脚本的输出： &gt; npm run develop Asset Size Chunks Chunk Names app.bundle.js 28.5 KiB app [emitted] app chat.bundle.js 1.4 KiB chat [emitted] chat &gt; npm run build Asset Size Chunks Chunk Names chat.bundle.js 375 bytes 0 [emitted] chat app.bundle.js 1.82 KiB 1 [emitted] app style.css 424 bytes 1 [emitted] app 现在CSS被从JavaScript包中提取出来用于生产，我们需要从我们的HTML &lt;link>到它。 dist/index.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Code Splitting&lt;/title&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;app.bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 这允许在浏览器中并行下载CSS和JavaScript，因此加载速度比单个捆绑包更快。 它还允许在JavaScript完成下载之前显示样式。 生成HTML每当我们的输出发生变化时，我们必须不断更新index.html以引用新的文件路径。 这正是html-webpack-plugin自动为我们创建的。 我们也可以在每次构建之前同时添加clean-webpack-plugin来清除/dist目录。 npm install --save-dev html-webpack-plugin clean-webpack-plugin webpack.common.js const path = require(&#39;path&#39;) const CleanWebpackPlugin = require(&#39;clean-webpack-plugin&#39;); const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); module.exports = { ... plugins: [ new CleanWebpackPlugin([&#39;dist&#39;]), new HtmlWebpackPlugin({ title: &#39;My killer app&#39; }) ] } 现在每次我们建立时，dist都会被清除掉。 我们现在也会看到index.html输出，以及我们的入口包的正确路径。 运行npm run develop会产生以下结果： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;My killer app&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;app.bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 而npm run build产生了这个： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;My killer app&lt;/title&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;app.bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 发展webpack-dev-server为您提供了一个简单的Web服务器，并为您提供实时重新加载，因此您无需手动刷新页面即可查看更改。 npm install --save-dev webpack-dev-server package.json { ... &quot;scripts&quot;: { &quot;develop&quot;: &quot;webpack --watch --config webpack.dev.js&quot;, &quot;develop&quot;: &quot;webpack-dev-server --config webpack.dev.js&quot;, } ... } &gt; npm run develop ｢wds｣: Project is running at http://localhost:8080/ ｢wds｣: webpack output is served from / 在浏览器中打开http://localhost:8080/并对其中一个JavaScript或CSS文件进行更改。 您应该看到它自动构建和刷新。 HotModuleReplacementHotModuleReplacement插件比Live Reloading更进一步，并在运行时交换模块而无需刷新。 正确配置后，这可以节省开发单页应用程序的大量时间。 如果页面中有很多状态，则可以对组件进行增量更改，只更换和更新已更改的模块。 webpack.dev.js const webpack = require(&#39;webpack&#39;) const merge = require(&#39;webpack-merge&#39;) const common = require(&#39;./webpack.common.js&#39;) module.exports = merge(common, { mode: &#39;development&#39;, devServer: { hot: true }, plugins: [ new webpack.HotModuleReplacementPlugin() ], ... } 现在我们需要从代码中接受更改的模块来重新初始化事物。 src/app.js if (module.hot) { module.hot.accept() } ... 注意：启用热模块替换时，module.hot设置为true以进行开发，false设置为生产，因此这些将从捆绑中剥离。 重新启动构建，看看执行以下操作时会发生什么： 单击打开聊天 将新人添加到people.js模块 再次单击“打开聊天” 这是发生了什么： 单击“打开聊天”时，将获取并初始化chat.js模块 HMR检测perple.js何时被修改 index.js中的module.hot.accept（）会导致替换此条目块加载的所有模块 再次单击“打开聊天”时，将使用更新模块中的代码运行chat.init（）。 CSS替换让我们将按钮颜色更改为红色，看看会发生什么： src/app.scss button { ... background: #24b47e; background: red; ... } 现在我们可以看到我们的样式的即时更新，而不会丢失任何状态。这是一个大大改善的开发人员体验！感觉就像未来。 HTTP/2使用像Webpack这样的module bundler的主要好处之一是它可以帮助您控制资源的构建方式，然后在客户端上获取，从而帮助您提高性能。多年来，连接文件以减少需要在客户端上进行的请求数量被认为是最佳实践。这仍然有效，但HTTP/2现在允许在单个请求中传递多个文件，因此连接不再是银弹。您的应用程序实际上可能会受益于单独缓存许多小文件。然后，客户端可以获取单个已更改的模块，而不必再次获取具有大部分相同内容的整个包。 Webpack的创建者Tobias Koppers撰写了一篇内容丰富的文章，解释了为什么捆绑仍然很重要，即使在HTTP/2时代也是如此。 在Webpack和HTTP / 2上阅读更多相关信息。 给你的话我希望你已经发现Webpack的这个介绍很有帮助，并且能够开始使用它并产生很大的效果。可能需要一些时间来围绕Webpack的配置，加载器和插件，但了解这个工具如何工作将会有所回报。 Webpack 4的文档目前正在进行中，但实际上很好地组合在一起。我强烈建议您阅读概念和指南以获取更多信息。以下是您可能感兴趣的一些其他主题： 源地图开发 生产的源地图 缓存破坏与散列文件名 拆分供应商包 Webpack 4是您选择的module bundler吗？请在下面的评论中告诉我。]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>WebPack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How To Build Personal Blog By Hexo]]></title>
    <url>%2FXDATA.Blog%2F2018%2F06%2F13%2FHEXO%2FHow-To-Build-Personal-Blog-By-Hexo%2F</url>
    <content type="text"><![CDATA[Hexo,Github搭建个人Blog踩坑准备工作 下载安装node.js(推荐使用淘宝npm镜像) 下载安装git 下载安装github desktop(用于blog与github关联时验证账户) 利用npm安装hexo( npm install -g hexo) 部署Hexo 创建工作空间,cd到工作空间 初始化hexo hexo init 安装依赖(npm install) 本地启动 发布静态网页(hexo g),在public目录下 启动本地服务器(hexo server),默认端口4000 将博客与Github关联 在Github上创建名字为XXX.github.io的项目,XXX为自己的github用户名。 打开工作空间下的_config.yml配置文件，添加配置 运行npm install hexo-deployer-git -save hexo g生成静态文件 hexo d将本地静态文件推送至github,中途可能会进行用户验证 浏览器访问https://hertz9409.github.io/ 创建博客文章并发布 hexo new “my new md” 编写markdown内容 hexo clean,删除本地静态文件 hexo g,重新生成本地静态文件 hexo deploy,将本地静态文件推送至github 在文章中使用图片方法一 在文章中写入 在themes主题文件夹下source目录下，新建目录upload_image，把图片放到该目录下 执行hexo g命令时会自动上传图片方法二 安装npm插件hexo-asset-image 使用主题 进入主题商店,查看主题 cd 工作空间中的themes文件夹 执行命令git clone https://github.com/Ben02/hexo-theme-Anatole.git themes/anatole 主题更新cd anatole git pull 常见MarkDown语法]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
