<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浅谈跨域--了解跨域的几种方式]]></title>
    <url>%2FXDATA.Blog%2F2018%2F12%2F29%2FFRONTEND%2F%E6%B5%85%E8%B0%88%E8%B7%A8%E5%9F%9F%E2%80%94%E2%80%94%E4%BA%86%E8%A7%A3%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言部分一、跨域是什么？跨域是指一个域下的文档或脚本试图去请求另一个域下的资源（广义的）。 广义的跨域场景有以下几种： 资源的跳转：A链接、重定向、表单提交； 资源嵌入：、、、 等DOM标签，还有样式中 background:url()、@font-face()等文件外链； 脚本请求： js发起的ajax请求、dom和js对象的跨域操作等； 我们通常所说的跨域是狭义的，是由浏览器同源策略限制的一类请求场景。 二、同源策略是什么？同源策略/SOP（Same origin policy）是一种约定，由 Netscape 公司 1995 年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS（跨站脚本攻击）、CSFR（Cross-site request forgery 跨站请求伪造）等攻击。所谓同源是指 ”协议+域名+端口” 三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。 跨域的安全限制，主要是针对浏览器端来说的，服务器端是不存在跨域安全限制的。 浏览器的同源策略限制从一个源加载的文档或脚本与来自另一个源的资源进行交互。如果协议、端口和主机对于两个页面是相同的，则两个页面具有相同的源，否则就是不同源的。如果要在js里发起跨域请求，则要进行一些特殊处理了。或者，你可以把请求发到自己的服务端，再通过后台代码发起请求，再将数据返回前端。 总结来说同源策略限制以下几种行为： Cookie、LocalStorage 和 IndexDB（也是一种前端缓存） 无法读取； DOM 和 Js对象无法获得； AJAX 请求不能发送； 三、常见的跨域场景有哪些？ URL 说明 是否允许通信 http://www.demo.com/a.js http://www.demo.com/b.jshttp://www.demo.com/lab/c.js 同一域名，不同文件或路径 允许 http://www.demo.com:8000/a.js http://www.demo.com/b.js 同一域名，不同端口 不允许 http://www.demo.com/a.js https://www.demo.com/b.js 同一域名，不同协议 不允许 http://www.demo.com/a.js http://127.0.0.1/b.js 域名和域名对应相同ip 不允许 http://www.demo.com/a.js http://x.demo.com/b.jshttp://demo.com/c.js 主域相同，子域不同 不允许 了解更多： 以上表格中第四个 “域名和域名对应相同IP” 不允许通信，虽然对应的IP地址是相同，但是也是不同的域名，这种也是判定为跨域的。我遇到的示例：做微信公众号的测试号配置时，需要在测试号的 体验接口权限表 - 网页服务 - 网页帐号 - 网页授权获取用户基本信息 中配置 授权回调页面域名，这里配置的域名需要和提供公众号访问的域名保持一致，我理解的也就是保证非跨域情况配置。经过我多次踩坑，发现以下两种情况域名配置微信是无法进行授权回调的： 公司内网 IP 地址，经过外网映射之后形成的 IP 地址； IP 地址对应的一个域名； IP 地址相同，对应端口号未配置； 第3条情况对应表格第二个“同一域名，不同端口”不允许访问，需要将端口严格保持一致。 第1、2 条两种情况其实和表格中第四个的情况都是一回事，是属于 “域名和域名对应相同 IP” 的情况。后来我使用了内网的IP去设置，使授权回调IP和配置在公众号菜单访问的地址链接中的IP保持一致，完成了授权。 ##四、解决方案 通过 jsonp 跨域 document.domain + iframe 跨域 location.hash + iframe window.name + iframe 跨域 postMessage 跨域 跨域资源共享（CORS） nginx 代理跨域 nodejs 中间件代理跨域 WebSocket 协议跨域 #跨域的几种解决方案 ##一、jsonp 方式jsonp (json with padding) 是 json 的一种“使用模式”，是为了解决跨域问题而产生的解决方案。 ####1、jsonp 产生思路： AJAX 直接请求普通文件存在跨域无权限访问的问题, 尽管是静态页面； 我们在调用 js 文件的时候又不受跨域影响, 比如引入 jquery 框架的时候（通过标签引入）； 凡是拥有 src 这个属性的标签都可以跨域例如 ; 如果想通过纯web端跨域访问数据只有一种可能,那就是把远程服务器上的数据装进js格式的文件里； json 是一个轻量级的数据格式,还被 js 原生支持； 为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback 参数给服务端； ####2、举例：以下是使用jQuery的jsonp发起跨域请求的例子描述，并总结。为了将过程描述清楚，内容过长，请谅解。 我们先来看一看模拟静态文件访问跨域情况：只前端自己写一写代码，在不同端口形成的跨域情况下进行模拟；MacBook 的本地服务端口配置我将会在后续给出。​ 1. 准备环境​ Macbook users 路径下的站点，用自带Apache 配置一个 8001 端口，Apache默认端口 80 (/Library/WebServer/Document) 端口。端口不一样，构成跨域条件。 2. 开始模拟，使用 &lt;script&gt; 标签实现跨域访问 测试文件准备 端口为 *8001站点目录：代码如下, 文件名称写在代码顶部： &lt;!--requestTest.html--&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;跨域测试&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; // /* // 演示端口不同引起的跨域 $(document).ready(function () { $(&quot;#btn&quot;).click(function () { $.ajax({ // url: &#39;http://localhost:8001/student&#39;, // 默认的 *8001 端口站点, 数据所在位置，跨域条件达成 // url: &#39;http://localhost:8080/message&#39;, // 自己配置的 users 下的 *8080 端口站点，数据所在位置，非跨域 type: &#39;GET&#39;, success: function (data) { $(text).val(JSON.stringify(data)) } }) }) }) // */ var message = function(data) { console.log(&#39;执行 message 方法.返回数据为：&#39;, data) alert(data[1].title) } &lt;/script&gt; &lt;!--使用 jsonp 实现跨域请求，用 js 包裹数据，可以访问。（这种情况更适用于前端的处理）--&gt; &lt;!--经测试，在未拼接 callback 的情况下，浏览器执行完这俩 js 文件，自动匹配了 message 方法。效果相同--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://localhost:8080/message?callback=message&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;跨域获取数据&quot;&gt; &lt;textarea id=&quot;text&quot; style=&quot;width: 400px; height: 100px;&quot;&gt;&lt;/textarea&gt; &lt;/body&gt; &lt;/html&gt; /** * student.json */ [{ &quot;age&quot;: 22, &quot;birthday&quot;: &quot;2018-1-10 12:12&quot;, &quot;id&quot;: 1, &quot;major&quot;: &quot;信息管理&quot;, &quot;name&quot;: &quot;Damon&quot;, &quot;status&quot;: true }, { &quot;age&quot;: 23, &quot;birthday&quot;: &quot;2018-1-10 12:12&quot;, &quot;id&quot;: 2, &quot;major&quot;: &quot;软件工程&quot;, &quot;name&quot;: &quot;John&quot;, &quot;status&quot;: true }, { &quot;age&quot;: 24, &quot;birthday&quot;: &quot;2018-1-10 12:12&quot;, &quot;id&quot;: 3, &quot;major&quot;: &quot;计算机科学与技术&quot;, &quot;name&quot;: &quot;Sonia&quot;, &quot;status&quot;: true }, { &quot;age&quot;: 22, &quot;birthday&quot;: &quot;2018-1-10 12:12&quot;, &quot;id&quot;: 4, &quot;major&quot;: &quot;计算机科学与技术&quot;, &quot;name&quot;: &quot;Mary&quot;, &quot;status&quot;: true }] 端口为8080站点目录：代码如下： /** * message.js */ console.log(&#39;服务器端执行前端传来的 message 方法。并携带参数返回。&#39;) message([ {&quot;id&quot;:&quot;1&quot;, &quot;title&quot;:&quot;上海新闻联播，12岁的小王竟然比年仅六岁的小李大6岁！&quot;}, {&quot;id&quot;:&quot;2&quot;, &quot;title&quot;:&quot;楼市告别富得流油 专家:房价下跌是大概率事件&quot;}, {&quot;id&quot;:&quot;3&quot;, &quot;title&quot;:&quot;股市暴跌，双十一战绩赫然，这究竟是什么鬼迷了心窍？！&quot;}, {&quot;id&quot;:&quot;4&quot;, &quot;title&quot;:&quot;没有运气，不要玩A股，你以为的谷底，只是下一个高地！&quot;}, {&quot;id&quot;:&quot;5&quot;, &quot;title&quot;:&quot;美丽新世界，啦啦啦啦啦~&quot;}, {&quot;id&quot;:&quot;6&quot;, &quot;title&quot;:&quot;国际要闻：听说昨天特朗普因为下个小雨没去开会！&quot;}, {&quot;id&quot;:&quot;7&quot;, &quot;title&quot;:&quot;易烊千玺太帅，阿姨、妈妈、女友、姐姐组成的几千万粉丝高呼请他停止散发魅力！&quot;}, {&quot;id&quot;:&quot;8&quot;, &quot;title&quot;:&quot;谢耳朵和艾米结婚了，好感动！&quot;}, {&quot;id&quot;:&quot;9&quot;, &quot;title&quot;:&quot;如果明天不下雨，竟然也不一定看到太阳！&quot;}, {&quot;id&quot;:&quot;10&quot;, &quot;title&quot;:&quot;没有新闻了。&quot;} ]); 演示在8001端口下的 requestTest.html 文件中，访问本端口映射的文件中的student文件，并展示在页面中，可正常访问到，结果如下: 在8001端口下 requestTest.html 文件中，访问 8080端口下的文件 message.js: 该请求报错，提示跨域不被允许： 在8001端口下 requestTest.html 文件中，通过 标签 包裹message.js 的请求: 可以看到跨域报错信息不见了，可以正常访问到数据： 总结：能够正常访问数据，script 标签可以得到其他来源的数据，这也是jsonp的理论依据。缺点：只能进行get 请求，无法访问服务器的响应文本（单向请求）。 现在来看jQuery 的 jsonp 方式跨域请求，结合后台服务器进行 jsonp 请求：这部分内容是后台小伙伴帮忙完成的，这里也非常感谢不辞劳苦，不厌其烦替我解答还帮我写demo的后台小伙伴！服务端代码如下：`javaprotected final static String CHARSET = “;charset=UTF-8”; @RequestMapping(value = “/rest/public/weChat/subscription/queryAuthTaskStatus” ,method = RequestMethod.GET,produces = MediaType.APPLICATION_JSON_VALUE + CHARSET) @ResponseBody public void queryTaskStatus(HttpServletRequest request, PrintWriter out, HttpServletResponse response)throws ServletException, IOException { List&lt;Student&gt; studentList = new ArrayList(); Student student = new Student(); student.setName(&quot;Zhangshan&quot;); student.setAge(&quot;23&quot;); student.setMajor(&quot;前端html&quot;); student.setStatus(true); studentList.add(student); Student student2 = new Student(); student2.setName(&quot;list&quot;); student2.setAge(&quot;20&quot;); student2.setMajor(&quot;java开发&quot;); student2.setStatus(true); studentList.add(student2); Student student3 = new Student(); student3.setName(&quot;李明&quot;); student3.setAge(&quot;18&quot;); student3.setMajor(&quot;数据部门&quot;); student3.setStatus(false); studentList.add(student3); JSONArray jsonArray = JSONArray.fromObject(studentList); String result = jsonArray.toString(); //前端传过来的回调函数名称 String callback = request.getParameter(&quot;callback&quot;); //前端传过来的回调函数名称 result = callback + &quot;(&quot; +result+&quot;)&quot;; response.getWriter().write(result); //out.write(result); //out.flush(); //out.close(); } } 我们首先看一下采用ajax 普通方式进行请求， js 代码如下： ```js $ajax({ url: &quot;http://localhost:8082/SSM2/rest/public/weChat/subscription/query/queryAuthTaskStatus&quot;, type: &quot;get&quot;, datatype: &quot;json&quot;, // 指定服务器返回的数据类型 success: function(data) { alert(asd); // var asd = JSON.stringify(data); } }); 普通方式请求提示跨域无法访问，结果如图： 然后我们更改代码，使用ajax jsonp方式请求，如果使用简单的方式，就只需配置 dataType: ‘jsonp’,就可以发起一个跨域请求。jsonp 指定服务器返回的数据类型为 jsonp 格式，可以看到请求的路径自动带了一个callback=xxx，xxx是 jQuery随机生成的一个回调函数名称。服务器端代码不变，js 代码截图如下: 可正常访问数据，请求结果如下(示例中json 数据解析出现乱码，暂时忽略): 以上的例子能简单看到 jsonp 是能够完成跨域请求的，结合前后台的配合，也更好理解怎么使用 jsonp 。 我们再来简单看下如何指定 jsonp 回调函数：以下的例子和解说我搬运自：https://www.cnblogs.com/chiangchou/p/jsonp.html，看完醍醐灌顶。上代码：`js1 &lt;%@ page pageEncoding=”utf-8” contentType=”text/html;charset=UTF-8” language=”java” %&gt;2 3 4 跨域测试5 6 78 function showData (data) {9 console.info(“调用showData”);1011 var result = JSON.stringify(data);12 $(“#text”).val(result);13 }1415 $(document).ready(function () {1617 // window.showData = function (data) {18 // console.info(“调用showData”);19 //20 // var result = JSON.stringify(data);21 // $(“#text”).val(result);22 // }2324 $(“#btn”).click(function () {2526 $.ajax({27 url: “http://localhost:9090/student&quot;,28 type: “GET”,29 dataType: “jsonp”, //指定服务器返回的数据类型30 jsonpCallback: “showData”, //指定回调函数名称31 success: function (data) {32 console.info(“调用success”);33 }34 });35 });3637 });38 39 40 41 42 4344 45 回调函数可以写到&lt;script&gt;里（默认属于window对象），或者指明写到window对象里，看jQuery源码，可以看到jQuery调用回调函数时，是调用的window.callback。代码如上，看调用结果发现，请求时带的参数是callback=showData,然后再调用了success，后台先将参数放进回调函数里，本质上前端是插入了一个脚本，放入数据，就等于执行了那个回调方法，再进行网络请求的响应处理，所以回调函数先拿到了数据，success再走。success是返回成功以后必定会调的函数。 如果想要更改 callback 这个参数的名称，参考以下代码第23行。 ```js 1 &lt;%@ page pageEncoding=&quot;utf-8&quot; contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; 2 &lt;html&gt; 3 &lt;head&gt; 4 &lt;title&gt;跨域测试&lt;/title&gt; 5 &lt;script src=&quot;js/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; 6 &lt;script&gt; 7 8 function showData (data) { 9 console.info(&quot;调用showData&quot;); 10 11 var result = JSON.stringify(data); 12 $(&quot;#text&quot;).val(result); 13 } 14 15 $(document).ready(function () { 16 17 $(&quot;#btn&quot;).click(function () { 18 19 $.ajax({ 20 url: &quot;http://localhost:9090/student&quot;, 21 type: &quot;GET&quot;, 22 dataType: &quot;jsonp&quot;, //指定服务器返回的数据类型 23 jsonp: &quot;theFunction&quot;, //指定参数名称，前端调用时接口后面要指定的参数名(必须，作为后台参数，执行该回调方法，便会把数据带回) 24 jsonpCallback: &quot;showData&quot;, //指定回调函数名称，本地接收数据的函数。(必须) 25 success: function (data) { 26 console.info(&quot;调用success&quot;); 27 } 28 }); 29 }); 30 31 }); 32 &lt;/script&gt; 33 &lt;/head&gt; 34 &lt;body&gt; 35 &lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;跨域获取数据&quot; /&gt; 36 &lt;textarea id=&quot;text&quot; style=&quot;width: 400px; height: 100px;&quot;&gt;&lt;/textarea&gt; 37 38 &lt;/body&gt; 39 &lt;/html&gt; 如此以来后台也要跟着改变，找到我前面的例子jQuery 的 jsonp 方式跨域请求中后台代码，找到下图对应位置并作出修改： 把getParameter(“callback”)里的callback改成前面23行代码配置的函数名“theFunction”即可。 经测试，无法进行POST请求，要测试就将前面的请求方式更改成POST即可，结果如下： jsonp 本质就是执行了JavaScript。是通过 script 标签的开放策略，使网页可以获取其他来源的数据，用 jsonp 获取的数据也不是真正的 json,而是任意的JavaScript, 用JavaScript解释器，而不是用json解析器解析，ajax 只是对脚本请求做了封装。所以，ajax 的 jsonp 请求也是不支持 POST 的。在谷歌浏览器Chrome中查看 jsonp 发送的请求都是js类型，而不是 xhr【1，文末注解】 ：【图片来源自水印地址】 3、总结综上一大堆解释和示例，我们可以对 jsonp 原理作如下简单描述：以下例子是较早学习跨域看到的描述，觉得写得很好，当时只记录了这个片段，未保存出处，若有人看到过望在评论指出，我会补上。也在此对作者表达歉意，并检讨以后摘录要记下出处。 首先我们假设a网页调用b网站的服务 a 网站需要准备一个方法，例如 callback(args); a 网站在页面中插入一个 标签，src 指向 b 网站的地址，并带上callback 作为参数; b网站接受请求处理后，把结果和回调方法的名字组成一个字符串返回，例如callback(‘data’); 由于是 script 标签，b 网站返回的字符串会被当成js解析执行，相当于调用到了 callback 方法; 主要利用了 script（img, iframe等有src属性的标签）可以跨站点访问的特性，且只能用 GET 请求，需要服务端做点配合，并且需要信任服务器(安全考虑)。jquery 的 jsonp ajax 只是封装了这个过程，让你看上去和普通 ajax 没什么区别，其实却一点关系都没有。 友情提示：axios 不支持 jsonp ,要用的话，可以装插件或者使用原生实现。 ##二、跨域资源共享 跨域资源共享（CORS）是一种网络浏览器的技术规范，它为web服务器定义了一种方式，允许网页从不同的域访问资源。CORS就是为了让AJAX可以实现可控的跨域访问而生的。 1、内部机制讲解1) 简介通过在HTTP Header中加入扩展字段，服务器在相应网页头部加入字段表示允许访问的domain和HTTP method，客户端检查自己的域是否在允许列表中，决定是否处理响应。 CORS 需要浏览器和服务器同时支持。目前所有浏览器都支持该功能，IE浏览器不能低于IE10。 整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 2) 两种请求浏览器将 cors 请求分为两种请求：简单请求 和 非简单请求。简单请求就是使用设定的请求方式请求数据而非简单请求则是在使用设定的请求方式请求数据之前,先发送一个OPTIONS请求,看服务端是否允许客户端发送非简单请求.只有”预检”通过后才会再发送一次请求用于数据传输。（例子，get、put 请求方式的区别）。 只要同时满足以下两大条件，就属于简单请求。 （1) 请求方法是以下三种方法之一： HEAD GET POST （2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 凡是不同时满足上面两个条件，就属于非简单请求。 浏览器对这两种请求的处理，是不一样的。 3) 简单请求：浏览器对于简单的请求，直接发起 cors 请求。具体的说，就是在请求头加上 Origin 字段。比如截取规划小智请求的报头信息：（这个请求不是真的简单请求，只是找了实例为了方便查看结果关键的头信息） Accept:*/* Accept-Encoding:gzip, deflate, br Accept-Language:zh-CN,zh;q=0.8 Cache-Control:no-cache Connection:keep-alive Content-Length:630 content-type:application/json Host:server.guihuaxiaozhi.com Origin:http://127.0.0.1:33284 Pragma:no-cache Referer:https://servicewechat.com/wx3e0ec267606ff974/devtools/page-frame.html User-Agent:Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1 wechatdevtools/1.02.1812180 MicroMessenger/6.7.3 Language/zh_CN webview/ token/9c8817cf1182bd6804aab2b7ad0a756a 上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。 如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。（ps: 我理解具体就是请求的回应状态为200，但是会在控制台提示错误信息，access-origin-check） 如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。 Access-Control-Allow-Credentials:true Access-Control-Allow-Origin:http://127.0.0.1:33284 Access-Control-Expose-Headers:Set-Cookie Connection:keep-alive Content-Type:application/json;charset=UTF-8 Date:Thu, 27 Dec 2018 02:24:44 GMT Server:nginx/1.10.2 Set-Cookie:SESSION=243e9e07-c7f9-4cb5-b896-e8807ecbb695; Path=/bdp-webconsumer/; HttpOnly Transfer-Encoding:chunked Vary:Origin 上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。注意这几个是响应头里的，由服务器端设置。 Access-Control-Allow-Origin 该字段是必须的。它的值要么是请求时Origin字段的值，指定域名的请求; 要么是一个*，表示接受任意域名的请求。 Access-Control-Allow-Credentials 该字段可选。它的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，Cookie 不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。 Access-Control-Expose-Headers 该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(&#39;Set-Cookie&#39;)可以返回Set-Cookie(服务器为浏览器设置cookie)字段的值。 上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。另一方面，需要前端，在请求的时候设置withCredentials属性，才能让浏览器处理携带 cookie 发起请求。 注意： 如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 4）非简单请求 预检请求 非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 下面是一段浏览器的JavaScript脚本。 var url = &#39;http://api.alice.com/cors&#39;; var xhr = new XMLHttpRequest(); xhr.open(&#39;PUT&#39;, url, true); xhr.setRequestHeader(&#39;X-Custom-Header&#39;, &#39;value&#39;); xhr.send(); 上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。 浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。 OPTIONS /cors HTTP/1.1 Origin: http://api.bob.com Access-Control-Request-Method: PUT Access-Control-Request-Headers: X-Custom-Header Host: api.alice.com Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0... “预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。 除了Origin字段，”预检”请求的头信息包括两个特殊字段。 Access-Control-Request-Method 该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。 Access-Control-Request-Headers 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。 预检请求的回应(仍以上面的例子来说明) 服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。 HTTP/1.1 200 OK Date: Mon, 01 Dec 2008 01:15:39 GMT Server: Apache/2.0.61 (Unix) Access-Control-Allow-Origin: http://api.bob.com Access-Control-Allow-Methods: GET, POST, PUT Access-Control-Allow-Headers: X-Custom-Header Content-Type: text/html; charset=utf-8 Content-Encoding: gzip Content-Length: 0 Keep-Alive: timeout=2, max=100 Connection: Keep-Alive Content-Type: text/plain 上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号(*)，表示同意任意跨源请求。注意的点在简单请求里有提到，这里类似。 Access-Control-Allow-Origin: * 如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。 XMLHttpRequest cannot load http://api.alice.com. Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin. 服务器回应的其他CORS相关字段如下。 Access-Control-Allow-Methods: GET, POST, PUT Access-Control-Allow-Headers: X-Custom-Header Access-Control-Allow-Credentials: true Access-Control-Max-Age: 1728000 Access-Control-Allow-Methods 该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。 Access-Control-Allow-Headers 如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。 Access-Control-Allow-Credentials 该字段与简单请求时的含义相同。 Access-Control-Max-Age 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。 浏览器的正常请求和回应 一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。 下面是”预检”请求之后，浏览器的正常CORS请求。 PUT /cors HTTP/1.1 Origin: http://api.bob.com Host: api.alice.com X-Custom-Header: value Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0... 上面头信息的Origin字段是浏览器自动添加的。 下面是服务器正常的回应。 Access-Control-Allow-Origin: http://api.bob.com Content-Type: text/html; charset=utf-8 上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的。 ####2、如何实现 CORS只需要在后台中加上配置来允许跨域请求。如果还需要携带cookie在前端被请求的Response header中加入允许携带配置，就可以实现跨域访问了！ 以下也是后台小伙伴友情提供，这里再次感谢~(^__^) 嘻嘻……下面我们来看一下 Java 的Tomcat 配置 cors:首先需要下载 jar 包cors-filter与java-property-utils： &lt;!-- https://mvnrepository.com/artifact/com.thetransactioncompany/cors-filter --&gt; &lt;dependency&gt; &lt;groupId&gt;com.thetransactioncompany&lt;/groupId&gt; &lt;artifactId&gt;cors-filter&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.thetransactioncompany/java-property-utils --&gt; &lt;dependency&gt; &lt;groupId&gt;com.thetransactioncompany&lt;/groupId&gt; &lt;artifactId&gt;java-property-utils&lt;/artifactId&gt; &lt;version&gt;1.10&lt;/version&gt; &lt;/dependency&gt; 修改web.xml, 增加以下代码（最好放在其他filter前边） &lt;filter&gt; &lt;filter-name&gt;CORS&lt;/filter-name&gt; &lt;filter-class&gt;com.thetransactioncompany.cors.CORSFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;cors.allowOrigin&lt;/param-name&gt; &lt;param-value&gt;*&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.supportedMethods&lt;/param-name&gt; &lt;param-value&gt;GET, POST, HEAD, PUT, DELETE&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.supportedHeaders&lt;/param-name&gt; &lt;param-value&gt;Accept, Origin, X-Requested-With, Content-Type, Last-Modified&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.exposedHeaders&lt;/param-name&gt; &lt;param-value&gt;Set-Cookie&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.supportsCredentials&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CORS&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; jQuery请求示例: $.ajax(&quot;url&quot;, { type: &quot;POST&quot;, xhrFields: { withCredentials: true, useDefaultXhrHeader: false }, data: { type: &quot;test&quot; }, dataType: &#39;json&#39;, crossDomain: true, success: function(data, status, xhr) { console.log(data); } }); 跨域请求默认不会携带 cookie 信息，如果要携带请配置以下信息： // 前端设置 “withCredentials”: true Vue 框架 axios 配置： axios.defaults.withCredentials = true 如果前端访问成功，则说明后台配置正确，反之，说明后台配置失败。 3、CORS 与 JSONP 的比较: jsonp只能实现 GET 请求，而cors支持所有类型的http请求； 使用cors，开发者可以使用XMLHttpRequest发起请求和获得响应，可以有更好的错误处理； jsonp 主要被老的浏览器支持，但它们往往不支持cors，而绝大多数现代浏览器都已经支持了cors。 4、CORS主要应用场景： 后台使用 restful API 架构，前后台不在同一服务器，需要用到。 ##三、nginx 反向代理接口跨域有反向代理，那就肯定有正向代理。我们先来简单说说这个正、反向代理是个啥。 关于代理，生活中代理场景，中介。 ###1、正向代理原理正向代理类似一个跳板机，把浏览器访问过程委托给代理去做，代理访问外部资源。 举个例子：我是一个用户，我访问不了某网站，但是我能访问一个代理服务器，这个代理服务器能访问那个我不能访问的网站，于是我先连上代理服务器,告诉他我需要那个无法访问网站的内容，代理服务器去取回来,然后返回给我。从目标网站的角度，只在代理服务器来取内容的时候有一次记录，有时候并不知道是用户的请求，也隐藏了用户的资料，这取决于代理告不告诉网站。类似场景比如我们在外网去访问公司内网服务器B，我们先设置VPN，通过VPN将我们的请求转发到内网的A服务器，然后A把请求发到B上，响应内容返回到A，再由A通过VPN返回到我们。工作流程可以描述为：用户设置代理服务器，用户访问url，代理服务器代替用户访问并将网页内容返回。 ###2、反向代理服务器工作原理反向代理（Reverse Proxy）方式是指后台内部网络服务器委托代理服务器，以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器；并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。用户访问的是代理服务器，前端是不知道后台真实地址，只知道代理地址。 再举个栗子：我是一个用户，我可以访问某一个网站，网站的数据是来源于我访问不到的内部网络上的内容服务器，内容服务器设置了可以访问自己的代理服务器。于是我向目标内容服务器发起请求，其实我访问的是内容服务器设置的代理服务器，这个代理服务器将我的请求转发到目标内容服务器上，获取到数据后再返回给网站上，我就可以看见了。工作流程可以描述为：和正向代理相反，由目标内容服务器设置代理服务器，代理转发用户发起的请求，获取数据再返回给用户。 ###3、使用 nginx 反向代理解决跨域Nginx (engine x) 是一个高性能的HTTP和反向代理服务，也是一个IMAP/POP3/SMTP服务。 我们前面提到跨域是浏览器的同源策略导致的，同源策略它是浏览器针对脚本攻击采取的一种安全策略，并不是 HTTP 协议的一部分。所以服务器端调用 HTTP 接口只是使用了 HTTP 协议，是不会执行 js 脚本的，不需要同源策略，也就不会形成跨域问题。我们使用代理（同源）服务器发起请求，再由代理（同源）服务器请求内部服务器。 我们先来看看怎么来设置反向代理实现跨域请求。 跨域举例假设有两个网站，A网站部署在：http://localhost:81 即本地ip端口81上；B网站部署在：http://localhost:82 即本地ip端口82上。现在A网站的页面想去访问B网站的信息，这时候浏览器是会报错的，因为形成了跨域。访问代码：&lt;h2&gt;Index&lt;/h2&gt; &lt;div id=&quot;show&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function () { $.get(&quot;http://localhost:82/api/values&quot;, {}, function (result) { $(&quot;#show&quot;).html(result); }) }) nginx 搭建去官网下载 nginx，这个安装例子是Windows系统下的，下完然后安装。解压缩得到目录如下： 配置 nginx.conf打开目录中的 “conf” 文件夹下的“nginx.conf”。以下为未修改的配置文件片段： #服务器的集群 upstream rj.nginx.com { #服务器集群名字 server 127.0.0.1:8001 weight=1;#服务器配置 weight是权重的意思，权重越大，分配的概率越大。 server 127.0.0.1:8002 weight=2; } #当前的Nginx的配置 server { listen 80; #监听80端口，可以改成其他端口 server_name localhost; # 当前服务的域名 #charset koi8-r; #access_log logs/host.access.log main; location / { proxy_pass http://rj.nginx.com; proxy_redirect default; } 修改后代码： server { listen 80; #监听80端口，可以改成其他端口 server_name localhost; # 当前服务的域名 #charset koi8-r; #access_log logs/host.access.log main; #这里是单一代理，也可以配置多个，多代理 location /apis { #添加访问目录为/apis的代理配置 rewrite ^/apis/(.*)$ /$1 break; proxy_pass http://localhost:82; } #以下配置省略 如果要实现前端跨域携带cookie的则在 location中另外配置： # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 add_header Access-Control-Allow-Origin http://www.domain1.com; #当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Credentials true; 如果是在浏览器中访问，项目访问地址需要和nginx代理同源，可以在同一个站点或者对nginx实现cors相关配置。修改代码片段解析： 由配置信息可知，我们让nginx监听localhost的80端口，网站A与网站B的访问都是经过localhost的80端口进行访问； 我们特殊配置了一个“/apis”目录的访问，并且对url执行了重写，最后使以“/apis”开头的地址（访问时的地址）都转到“http://localhost:82”（目标服务器地址）进行处理； rewrite ^/apis/(.)$ /$1 break; rewrite代表重写拦截进来的请求，并且只能对域名后边以“/apis”开头的起作用，例如www.a.com/apis/msg?x=1重写。只对/apis重写。 rewrite后面的参数是一个简单的正则 ^/apis/(.)$ ,$1代表正则中的第一个(),$2代表第二个()的值,以此类推。 break代表匹配一个之后停止匹配。 访问地址修改配置了nginx，那么所有的访问都要走nginx，而不是走网站原本的地址（A网站localhost:81,B网站localhost:82）。所以要修改A网站中的ajax访问地址，把访问地址由“ http://localhost:82/api/values” 改成 “/apis/api/values”`Index $(function () { $.get(“/apis/api/values”, {}, function (result) { $(“#show”).html(result); }) }) 然后在浏览器中访问B的数据就可以成功获取了。 ##四、nodejs 中间件代理跨域 node中间件实现跨域代理，原理大致与nginx相同，都是通过开启一个代理服务器（同源），实现数据的转发。 由于我所试验 nodejs 跨域的例子是已有的Vue项目，配置代理后实现了跨域获取数据，下面的例子分“非 Vue”和“Vue”两种进行说明。 1. 非 Vue 框架的跨域 利用node + express + http-proxy-middleware搭建一个proxy服务器。 - 安装 node 环境、 express、 http-proxy-middleware &gt;***express***是基于 Node.js 平台，快速、开放、极简的 web 开发框架。 &gt;***http-proxy-middleware*** 是专门用于 http 代理的一个 node 中间件，适用于*connect*, *express*, *browser-sync* 等等，由热门的*http-proxy* 驱动。 - 新建 js 文件： nodeProxy.js “use strict”;const express = require(‘express’);const path = require(‘path’);const app = express();const request = require(‘request’); // 配置静态文件服务中间件let serverUrl=’http://192.168.1.220:8080&#39;; // 目标后端服务地址app.use(express.static(path.join(__dirname, ‘./‘))); //静态资源 index.html 和node代码在一个目录下app.use(‘/‘, function(req, res) { let url = serverUrl + req.url; // req.url 传入的接口路径 req.pipe(request(url)).pipe(res);}); app.listen(3000,’127.0.0.1’, function () {//前端 ajax 地址写 http://127.0.0.1:3000/ console.log(‘server is running at port 3000’); // 3000为将要启动的端口}); - 运行 node nodeProxy.js node 做代理转发请求服务器，可以跨域请求数据。 2. Vue 框架的跨域 利用node + webpack + webpack-dev-server代理接口跨域。在开发环境下，由于vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域，无须设置headers跨域信息了。 - 安装中间件 http-proxy-middleware 和 express，已经有的话就不必装了。 使用命令： &gt;npm install --save-dev express http-proxy-middleware - webpack文件配置 我使用的vue-cli, webpack 版本为 3.8.1。 找到项目中config文件夹，然后打开index.js, 看到如下片段，进行配置: module.exports = { dev: {http://192.168.1.220:8080/gxtz/api/login // Paths assetsSubDirectory: ‘static’, assetsPublicPath: ‘/‘, proxyTable: { ‘/api/‘: { tartget: ‘http://192.168.1.220:8080&#39;, changeOrigin: true, pathRewrite: {‘^/api/‘: ‘/‘} } }, // Various Dev Server settings host: &#39;localhost&#39;, // can be overwritten by process.env.HOST port: 8080, // can be overwritten by process.env.PORT, if port is in use, a free one will be determined /** * Source Maps */ // https://webpack.js.org/configuration/devtool/#development devtool: &#39;#source-map&#39;, #其他省略 },} 这样配置完，浏览器请求地址变成如：http://localhost:8000/gxtz-server-web/* 就会匹配paths通过，进行代理转发到目标 http://192.168.1.220 上。 配置相关属性含义和前面 nginx 中相同。这样就可以进行代理了。 ##五、WebSocket协议跨域 WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。 原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。 关于WebSocket我没还没有自己做实例去验证跨域，但是WebSocket本身支持跨域，只要会使用就行，之前写小程序使用过，但是代码封装程度高不适合作为例子看。以下例子是从[前端常见跨域解决方案（全）](https://segmentfault.com/a/1190000011145364) 摘抄来的，可以参考一下。 - 前端代码: user input： var socket = io(‘http://www.domain2.com:8080&#39;); // 连接成功处理socket.on(‘connect’, function() { // 监听服务端消息 socket.on(‘message’, function(msg) { console.log(‘data from server: —&gt; ‘ + msg); }); // 监听服务端关闭 socket.on(&#39;disconnect&#39;, function() { console.log(&#39;Server socket has closed.&#39;); }); }); document.getElementsByTagName(‘input’)[0].onblur = function() { socket.send(this.value);}; - Nodejs socket后台： var http = require(‘http’);var socket = require(‘socket.io’); // 启http服务var server = http.createServer(function(req, res) { res.writeHead(200, { ‘Content-type’: ‘text/html’ }); res.end();}); server.listen(‘8080’);console.log(‘Server is running at port 8080…’); // 监听socket连接socket.listen(server).on(‘connection’, function(client) { // 接收信息 client.on(‘message’, function(msg) { client.send(‘hello：’ + msg); console.log(‘data from client: —&gt; ‘ + msg); }); // 断开处理 client.on(&#39;disconnect&#39;, function() { console.log(&#39;Client socket has closed.&#39;); }); }); #结尾 简单的总结概括： - jsonp 适用于访问接口get请求返回值是json类型，又是跨域的情况。 1）只支持 get 请求； 2）需要后端配合，能够返回 callback 返回希望得到的数据； 3）存在一定的安全性问题，不能防止滥用跨域请求的非法网站恶意调用。使用的话需做好安全防范； - cors 由于CORS是W3C中一项较“新”的方案，目前，浏览器支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS），CORS也已经成为主流的跨域解决方案。 1）纯后端设置，无需前端做处理，如果需要携带cookie，前后端都要配置，前端需要配置&quot;withCredetails&quot;: &quot;true; - 代理 1）nginx 反向代理，一般适用于外网访问不了的内部网络请求，做反向代理来获取数据； 2）nodejs 中间件代理，前后端分离引起跨域问题（从原理看nginx 反向代理应该也适用），开发阶段前后台不同源的情况。 其他的没有详细描述。在使用过程中就能够知晓很明确的使用场景，后续我再陆续补充。 #参考链接 [前端常见跨域解决方案（全）](https://segmentfault.com/a/1190000011145364) [jQuery jsonp跨域请求](https://www.cnblogs.com/chiangchou/p/jsonp.html) [script 标签加载文件](https://blog.csdn.net/qq_24520119/article/details/70154369) [浏览器同源政策及其规避方法-阮一峰](http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html) [cors跨域解析-阮一峰](http://www.ruanyifeng.com/blog/2016/04/cors.html) [http header 的一些含义](https://cloud.tencent.com/developer/section/1189898) 还有关于 iframe 等相关的可以参考阮一峰的 [浏览器同源政策及其规避方法](http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html) 如果有没理解的也可以去这些博客找找灵感~~ * * * 【注解1】使用XMLHttpRequest (XHR)对象可以与服务器交互。您可以从URL获取数据，而无需让整个的页面刷新。这使得Web页面可以只更新页面的局部，而不影响用户的操作。 尽管名称如此，XMLHttpRequest可以用于获取任何类型的数据，而不仅仅是XML，它还支持 [HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP)以外的协议(包括文件和ftp)。 【注解2】前端将回调函数传到后台，后台将要返回的数据绑定到回调函数上，这时候前端的回调中就可以拿到数据了，在后台执行响应response的相关语句后在前端的请求success中才会拿到。 ```Java result = callback + &quot;(&quot; +result+&quot;)&quot;; // 绑定前端传入回调函数 response.getWriter().write(result); // 后台将数据作为响应带回。不加这一句前端指定的callback对应函数能拿到数据，但是ajax请求success中是获取不到数据的。 对于更详细的XMLHttpRequest请求内容可以参考：使用XMLHttpRequest]]></content>
      <categories>
        <category>frontend</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 实践小结]]></title>
    <url>%2FXDATA.Blog%2F2018%2F11%2F04%2FFRONTEND%2FVue%E5%AE%9E%E8%B7%B5%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Vue子组件改变 props 的方法由于 vue 遵循单向数据流，不建议在子组件里面直接改变 props 的值，一般通过 2 种方法 通过$emit调用父组件事件来改变父组件传给子组件的值，然后在子组件里面watch props 的值，状态变化时触发相关反应 给 props 加个对象字段，如: props: [&#39;state&#39;], template: &lt;span&gt;{{state.someData.value}}&lt;/span&gt; // 改 js: this.state.someData.value = xxx; // 直接改变了父组件的data值 如何在 vue 组件中绑定原生点击事件？使用.native修饰符，这样原生点击事件会绑定到该组件的$el节点上 例如使用 iview 某个组件 &lt;Card @click.native=&quot;handleClick&quot; /&gt; 使用组件时如何加行内 syle在使用 vue 组件时，如果想给该组件加个行内 style，需要:style=&quot;{}&quot;这种写法，直接写 style 不会生效，class 则可以 关于 v-model v-model 是 v-bind:value 和 v-on:input 和语法糖 &lt;div id=&quot;app&quot;&gt; &lt;input v-model=&quot;value&quot; type=&quot;text&quot;&gt; &lt;input :value=&quot;value&quot; type=&quot;text&quot; @input=&quot;value = $event.target.value&quot;&gt; &lt;custom-input v-model=&quot;value&quot;/&gt; &lt;/div&gt; 其中，custom-input 的写法 Vue.component(&quot;custom-input&quot;, { props: [&quot;value&quot;], template: ` &lt;input :value=&quot;value&quot; @input=&quot;$emit(&#39;input&#39;, $event.target.value)&quot; &gt; ` }); render 函数里如何用组件的 v-model用 iview 中 Poptip 组件举例： &lt;template&gt; &lt;Poptip v-model=&quot;visible&quot;&gt; &lt;a&gt;Click&lt;/a&gt; &lt;div slot=&quot;title&quot;&gt;Custom title&lt;/div&gt; &lt;div slot=&quot;content&quot;&gt; &lt;a @click=&quot;close&quot;&gt;close&lt;/a&gt; &lt;/div&gt; &lt;/Poptip&gt; &lt;/template&gt; &lt;script&gt; export default { data () { return { visible: false } }, methods: { close () { this.visible = false; } } } &lt;/script&gt; 用 render 函数方法调用该组件 核心就是把 v-model 拆成 value 和 input 的写法 export default { name: &quot;RenderPoptip&quot;, data() { return { visible: false }; }, methods: { close() { this.visible = false; } }, render(h) { const vm = this; return; h( &quot;Poptip&quot;, { props: { value: vm.visible }, on: { input: e =&gt; { this.visible = e; } }, ref: &quot;poptip&quot; }, [ h(&quot;a&quot;, &quot;click&quot;), h( &quot;div&quot;, { slot: &quot;title&quot; }, &quot;Custom title&quot; ), h(&quot;div&quot;, [ h( &quot;a&quot;, { slot: &quot;content&quot;, on: { click: () =&gt; { this.close(); } } }, &quot;关闭&quot; ) ]) ] ); } }; 在 iview 的一些组件中，只提供 render 函数给我们渲染内部的内容，这时候我们可以用以上方法渲染 iview 的其它组件 template 模板写法和 render 写法最终都会渲染成Vnode，然后再挂载到 dom 上，在有些场景上，使用 render 写法更为清晰 Transition 组件 mode in-out：新元素先进行过渡，完成之后当前元素过渡离开。 out-in：当前元素先进行过渡，完成之后新元素过渡进入。 data 属性不被代理的方法const app = new Vue({ data: { _app: &quot;&quot;, $ppa: &quot;&quot; } }); // 以上_app,$ppa都不会被代理，只要加了_和$开头的属性都不会被vue代理 // this._app 和 this.$ppa皆不存在 cli3 传递全局 scss 变量小坑// vue.config.js module.exports = { css: { loaderOptions: { // 给 sass-loader 传递选项 sass: { // @/ 是 src/ 的别名 // 所以这里假设你有 `src/variables.scss` 这个文件 data: `@import &quot;@/variables.scss&quot;;` } } } }; 注意：如果第一个加载的 vue 组件，&lt;style&gt;处没有声明lang=scss，然后第二个组件中声明了scoped也声明了lang=scss，那么上面传递的全局变量都会被前缀处理 解决方案：第一个组件(通常 App.vue)style 处声明lang=&#39;scss&#39;且不能声明scoped watch 路由中复用的组件的属性在使用vue-router中，在/page/a 跳转到 /page/b 中，如果注册的是动态路由，那么它们使用的也是同一个组件，例如 Page.vue。从 a 页面跳转到 b 页面，由于是同一个组件，vue-router 会复用这个在内存中的组件实例，所以相关生命周期不会重复调用，数据也不会更新，所以如果要在跳转页面做一些动作(例如：高亮菜单，数据获取)，就需要用watch方法： data() { return { subNavList: [] } }, watch: { &#39;$route&#39;: { handler: &#39;getSubNavList&#39;, immediate: true // 使用这个就不需要在created里面调用getSubNavList } }, methods: { getSubNavList(route) { this.subNavList = getSubNavList(route) } } 父组件调用子组件方法在父组件中用$refs或者$children拿到对应子组件实例对象进行调用 关于数组和对象数据更新视图不更新问题这些都是 js 的限制，使用Vue.set方法解决，或者一些变异方法 数组更新方法 对象更新方法 iview 瞄点组件注意的问题&lt;div class=&quot;anchor-class &quot; v-if=&quot;isAnchor&quot;&gt; &lt;Anchor container=&quot;.scrollcontent&quot; show-ink&gt; &lt;AnchorLink :href=&#39;&quot;?name=&quot;+activeName+&quot;#&quot;+index&#39; :title=&quot;itemData.name &quot; v-for=&quot;(itemData,index) in selectCardList &quot; :key=&quot;index &quot; /&gt; &lt;/Anchor&gt; &lt;/div&gt; 如果瞄点依赖的 dom 内容是要 ajax 获取信息进行渲染的，那么直接挂载瞄点组件会报错，因为组件渲染是比 ajax 快的，数据没回来，dom 节点没加载，瞄点组件无法扫描需要的 dom 节点，所以会出问题 用v-if+nextTick即可解决 created() { this.$http.get(&quot;xxx&quot;).then(res =&gt; { if (res.status === 200) { this.$nextTick(() =&gt; { // nextTick回调函数中，scrollcontent内容已经渲染完毕 // 这时可以渲染iview瞄点组件了 this.isAnchor = true; }); } }); } 如何利用$mount挂载实例(组件)什么是$mount? 如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。可以使用 vm.$mount() 手动地挂载一个未挂载的实例 &lt;div id=&quot;app&quot;&gt; &lt;span&gt;{{message}}&lt;/span&gt; &lt;/div&gt; &lt;span id=&quot;component-1&quot;&gt; {{message}} &lt;/span&gt; &lt;span id=&quot;component-2&quot;&gt; {{message}} &lt;/span&gt; &lt;span id=&quot;component-3&quot;&gt; &lt;!-- {{message}} --&gt; &lt;/span&gt; 挂载根实例 // 方法一 new Vue({ data: { message: &quot;hello vue&quot; } }).$mount(&quot;#app&quot;); // 方法二 new Vue({ el: &quot;#app&quot;, data: { message: &quot;hello vue&quot; } }); 组件实例挂载 // 利用extend构造一个组件实例 const MyComponent = Vue.extend({ // 注意，组件经常会被多次实例 // 所以data必须是个函数 data() { return { message: &quot;component&quot; }; } }); // 有三种方法可以挂载 // 方法一 new MyComponent().$mount(&quot;#component-1&quot;); // 方法二 new MyComponent({ el: &quot;#component-2&quot; }); // 方法三 const c = new MyComponent({ data() { return { message: &quot;component&quot; }; }, render: function(h) { return h(&quot;span&quot;, this.message); } }).$mount(); document.getElementById(&quot;component-3&quot;).appendChild(c.$el); Vue-routerbeforeEach 路由守卫该注意的以简单的登录拦截举例： /** * 开启路由守卫 */ router.beforeEach((to, from, next) =&gt; { // cookie上存了token，可以不用登录 const token = getToken(); if (token) { // 如果要跳转的页面是登录页，强制跳转到根页面 if (to.path === LOGIN_PAGE_PATH) { next({ path: &quot;/&quot; }); } next(); } else { // 没存就跳转到登录页面 if (to.path !== LOGIN_PAGE_PATH) { next({ path: LOGIN_PAGE_PATH }); } // 这里如果不加next()，会进入死循环 // 因为 next({ path: LOGIN_PAGE_PATH })也会触发 beforeEach // 所以需要提供最终的next()，才能把导航的状态置为confirmed next(); } }); 2018/11/10更新 vue 模板解析报错 [Vue warn]: You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build. vue.config.js增加别名： module.exports = { configureWebpack: { resolve: { alias: { &#39;vue$&#39;: &#39;vue/dist/vue.esm.js&#39; } } } vue-router 为 history 时请求本地 static 的小坑如果vue-router使用history模式，比如在http://localhost:8080/about/home页面下，发起本地json文件ajax请求 this.$http.get(&#39;static/foo.json&#39;).then(res =&gt; { console.log(res) }) 这时控制台会发出404报错，GET http://localhost:8080/about/static/foo.json 404 (Not Found) 问题在于发起的请求地址是错的，应该是http://localhost:8080/static/foo.json才对 对这种问题，有2种解决方法 static前面加个/，this.$http.get(&#39;/static/foo.json&#39;)，但这种情况打包路径要额外处理 vue-router模式改为hash模式 路由高级异步组件处理方法const LoadingCom = { name: &#39;loading-com&#39;, render(h) { return h(&#39;h1&#39;, &#39;Loading...&#39;) } } const ErrorCom = { name: &#39;error-com&#39;, render(h) { return h(&#39;h1&#39;, &#39;Error&#39;) } } function lasyLoadView (AsyncView) { const AsyncHandler = () =&gt; ({ // component选项必须返回Promise // import(&#39;xxx.vue&#39;)会返回一个Promise component: AsyncView, loading: LoadingCom, error: ErrorCom, // 组件挂载延迟时间，默认200 // 0的话loading组件也会立即渲染 delay: 0, // 超时渲染error组件 timeout: 10000 }) return Promise.resolve({ functional: true, render(h, { data, children }) { return h(AsyncHandler, data, children) } }) } // 使用方法 const router = new VueRouter({ routes: [ { path: &#39;home&#39;, // 如果home.vue组件很大，请求很慢 // 会先渲染loading组件，请求完成再渲染home.vue组件 component: () =&gt; lazyLoadView(import(&#39;./home.vue&#39;)) } ] }) 未完待续…]]></content>
      <categories>
        <category>frontend</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue + iview + webpack ie 浏览器兼容简单处理]]></title>
    <url>%2FXDATA.Blog%2F2018%2F10%2F31%2FFRONTEND%2FVue%20%2B%20iview%20%2B%20webpack%20%E5%AF%B9%20ie%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E7%AE%80%E5%8D%95%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[Vue + iview + webpack ie 浏览器兼容简单处理 环境介绍：vue: ^2.5.2 iview: ^3.1.0 Webpack: ^3.8.1 前情提要： ie 浏览器不支持 ES6 Promise 的语法。 ie8 及以下对 html5 标签不兼容（可以通过引入html5shiv包解决，本文不处理IE11的更低版本，故不提及此法）。 ie9 以下 对 CSS3 的不兼容，各种不兼容的细节比较多，这里不说明。 ie10 及以下浏览器中不支持 dataset 方法（经学习实践发现ie11也是不支持的），而我在项目中使用了 iview, iview 的一些组件用到了这个方法。 ie 浏览器是非 webkit 内核，不支持 display: -webkit-box; 和相关样式； Polyfill 是 shim 的一种，但他的 API 是遵循标准的。polyfill 的做法通常是：先检查浏览器是否支持某个标准 API,如果不支持,就使用旧的技术对浏览器做兼容处理,这样就可以在旧的浏览器上使用新的标准 API。比如,旧浏览器不支持 ES6 的 Array.prototype.find 方法,我们想要在项目中使用 Array.prototype.find,只要 polyfill 就行了,而不是封装一个新的方法。 处理过程1、安装 polyfill 组件，使浏览器兼容 es6 的写法 在终端输入命令 npm install –save babel-polyfill main.js 头部引入 babel-polyfill， 注意这个放最前面： import ‘babel-polyfill’ 或者在项目的 webpack.base.conf.js 中配置： entry: { app:[&#39;babel-polyfill&#39;,&#39;./src/main.js&#39;] }, 另外，引入的一些模块需要单独引入到 babel 的配置中，不然不起作用（具体为啥我没深究），网上查到用到 echarts-v3 的需要配置，经测试我用到 iview 也是要配置的, 下面代码的 include 中就是我配置的项，这个主要是按需配置的，具体看项目里的情况： module: { rules: [ ...(config.dev.useEslint ? [createLintingRule()] : []), { test: /\.vue$/, loader: &#39;vue-loader&#39;, options: vueLoaderConfig }, { test: /\.js$/, loader: &#39;babel-loader&#39;, include: [ resolve(&#39;src&#39;), resolve(&#39;test&#39;), resolve(&#39;static&#39;), resolve(&#39;node_modules/webpack-dev-server/client&#39;), // resolve(&#39;node_modules/vue-echarts&#39;), resolve(&#39;node_modules/iview/src&#39;), // resolve(&#39;node_modules/resize-detector&#39;) ] }, } 2、兼容 dataset我在引入了 babel-polyfill 后还是报错，信息如下图： 搜了半天关于 SCRIPT1003 和 SCRIPT5007 的错误, 发现没有直接的解决办法，就主要是说缺少项目中包含的某个模块的某种方法的引入。于是我就从我主要用到的 iview 入手去查找，发现了有相关的内容。有说到 iview 兼容 IE 需要写一个 dataset 方法才能正常加载。 dataset方法只要能够加载全局使用即可。我是写了一个脚本嵌入 index.html 文件中。代码如下： &lt;script&gt; // dataset 方法兼容 IE 浏览器。ie10及以下不支持dataset if (window.HTMLElement) { if (Object.getOwnPropertyNames(HTMLElement.prototype).indexOf(&#39;dataset&#39;) === -1) { Object.defineProperty(HTMLElement.prototype, &#39;dataset&#39;, { get: function () { var attributes = this.attributes // 获取节点的所有属性 var name = [] var value = [] // 定义两个数组保存属性名和属性值 var obj = {} // 定义一个空对象 for (var i = 0; i &lt; attributes.length; i++) { // 遍历节点的所有属性 if (attributes[i].nodeName.slice(0, 5) === &#39;data-&#39;) { // 如果属性名的前面5个字符符合&quot;data-&quot; // 取出属性名的&quot;data-&quot;的后面的字符串放入name数组中 name.push(attributes[i].nodeName.slice(5)); // 取出对应的属性值放入value数组中 value.push(attributes[i].nodeValue); } } for (var j = 0; j &lt; name.length; j++) { // 遍历name和value数组 obj[name[j]] = value[j]; // 将属性名和属性值保存到obj中 } return obj // 返回对象 } }) } } &lt;/script&gt; 搞到这里，我的项目就已经可以在 IE 里出现了，也不打算继续支持更低的IE版本，坑太深，果断弃。但是样式还是有问题。这个搞起来也是很麻烦。点了点项目里出现的样式问题，未发现很复杂的，主要一个就是 flex 布局出现混乱，经过调整已经好了。还有就是 -webkit-box 不支持，之前显示数据使用以下方式解决多行溢出省略号显示问题失效了： overflow: hidden; display: -webkit-box; /* Chrome 4+, Safari 3.1, iOS Safari 3.2+ */ -webkit-box-orient: vertical; -webkit-line-clamp: 2; word-break: break-all; 纠结了一下，不想用js 的方式写，也不想用 伪标签（高度不好定，易出现文字被覆盖的情况），也不想特意让后台修改返回的数据，所以决定用比较low的相对保险的截取字符的方式展示。 总结第一次处理这个问题，很多东西不明白，描述也不大清楚，处理的不全面，还望多交流指正！]]></content>
      <categories>
        <category>frontend</category>
      </categories>
      <tags>
        <tag>Front end</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Gis开发经验分享]]></title>
    <url>%2FXDATA.Blog%2F2018%2F09%2F26%2FMOBILE%2FAndroid%20Gis%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[Android Gis开发经验分享概述一、地图坐标系的认识二、地图管理类的认识三、Gis开发熟知四、Gis开发平台差异化注意事项一、地图坐标系的认识1. WGS84坐标系​ 一种国际上采用的地心坐标系. 2. WGS84 Web墨卡托​ Web墨卡托是2005年谷歌在谷歌地图中首次使用的,如今主流的Web地图几乎都是使用的Web墨卡托,如：国内的百度地图、高德地图、腾讯地图和天地图等也是基于Web墨卡托（国内地图有加密要求，有两种情况，一种是在 Web墨卡托的基础上经过国家标准加密的国标02坐标系，熟称“火星坐标系”；另一种是在国标的02坐标系下进一步进行加密，如百度地图的BD09坐标系）。​ 3.GCJ02经纬度投影​ GCJ-02是由中国国家测绘局（G表示Guojia国家，C表示Cehui测绘，J表示Ju局）制订的地理信息系统的坐标系统。它其实就是对真实坐标系统进行人为的加偏处理，按照特殊的算法，将真实的坐标加密成虚假的坐标，而这个加偏并不是线性的加偏，所以各地的偏移情况都会有所不同。而加密后的坐标也常被大家称为“火星坐标系统”。​ 该坐标系的坐标值为经纬度格式，单位为度； GCJ02经纬度投影，就是在WGS84经纬度的基础之上，进行GCJ-02加偏；BD09经纬度投影属于百度坐标系，它是在标准经纬度的基础上进行GCJ-02加偏之后，再加上百度自身的加偏算法，也就是在标准经纬度的基础之上进行了两次加偏。 4.GCJ02 Web 墨卡托投影​ 该坐标系的坐标值为Web墨卡托格式，单位为米；这里的GCJ02 Web 墨卡托，也就是在标准Web默卡托的基础之上，进行GCJ-02加偏。 5. 北京54坐标系​ 我国与前苏联1942年坐标系进行联测，通过计算建立了我国大地坐标系，定名为1954年北京坐标系。它的原点不在北京而是在前苏联的普尔科沃；该坐标系存在很多缺点，为此，我国在1978年在西安召开了”全国天文大地网整体平差会议”，提出了建立属于我国自己的大地坐标系，即后来的1980西安坐标系。 6. 西安80坐标系​ 该坐标系的大地原点设在我国中部的陕西省泾阳县永乐镇，位于西安市西北方向约60公里。 7. CGCS2000坐标系​ 2000中国大地坐标系(China Geodetic Coordinate System 2000，CGCS2000)，又称之为2000国家大地坐标系，是中国新一代大地坐标系，21世纪初已在中国正式实施。 8. OGC标准​ OGC 全称是开放地理空间信息联盟(Open Geospatial Consortium),是一个非盈利的国际标准组织，它制定了数据和服务的一系列标准，GIS厂商按照这个标准进行开发可保证空间数据的互操作 9.EPSP代码​ EPSP的英文全称是European Petroleum Survey Group，中文名称为欧洲石油调查组织。这个组织成立于1986年，2005年并入IOGP(InternationalAssociation of Oil &amp; Gas Producers)，中文名称为国际油气生产者协会；EPSG对世界的每一个地方都制定了地图，但是由于座标系不同，所以地图也各不相同。 10.SRID：​ OGC标准中的参数SRID，也是指的空间参考系统的ID，与EPSG一致；天地图通常采用的4490坐标系其实也就是CGCS2000坐标系 。 二、地图管理类的认识1. ArcGISDynamicMapServiceLayer​ extends DynamicLayer 2. ArcGISTiledMapServiceLayer​ extends TiledServiceLayer 3. ArcGISLocalTiledLayer​ extends TiledLayer 4. ArcGISFeatureLayer​ extends GraphicsLayer 5. TianDiTuLayer​ extends TiledServiceLayer 6. GraphicsLayer​ extends Layer 7. WMSLayer​ extends DynamicLayer 8. 其他：​ WMSLayer、WFS、 WMTSLayer、 WebMapLayer、 WCS、WPS、WCPS等…​ 其中wms是web地图服务，是一个仓库管理系统；wfs 是web要素服务，是一个工作流系统； 三、Gis开发常用函数1.FindTask​ 多个图层的要素查询、不能进行“空间查询”； 2. QueryTask​ 空间和属性查询 3. IdentifyTask​ 多个图层中查询、识别要素（Feature）； 4. OnSingleTapListener​ 地图点击事件监听 5. calculateLength2D()​ 线长度计算 6. polygon.calculateArea2D()​ 面积计算 7. GeometryEngine​ 图形交叉关系识别及计算 四、Gis平台差异化注意事项（android为主）1.ArcGISDynamicMapServiceLayer 无法显示问题属性设置：Supports Dynamic Layers: true2.ArcGISDynamicMapServiceLayer可根据底图坐标系自行调整。​ 如：加载wmts地图服务后进行ArcGISDynamicMapServiceLayer叠加可进行图层显示、反之无法显示。 3.ArcGISDynamicMapServiceLayer(String url) 与ArcGISDynamicMapServiceLayer(String url, int[] visiblelayers)差异​ 初始化传入visiblelayers，后面可通过图层id进行单个图层的控制、否则无法正常控制。​ 4.ArcGISDynamicMapServiceLayer(String url, int[] visiblelayers)部分地图服务必须使用此函数才可正常显示图层。​ 项目经历：广州项目添加特有的配置文件支持该函数的使用。 问题讨论：​ 1.三大查询的异步处理机制？​ 2.地图服务操作常见问题总结。​ 3.天地图加载方式及注意事项。 ​]]></content>
      <categories>
        <category>mobile</category>
      </categories>
      <tags>
        <tag>移动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动一张图专题分析]]></title>
    <url>%2FXDATA.Blog%2F2018%2F08%2F31%2FMOBILE%2F%E7%A7%BB%E5%8A%A8%E4%B8%80%E5%BC%A0%E5%9B%BE%E4%B8%93%E9%A2%98%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[移动一张图专题分析 ##简介[专题模块为整个项目中的重要组成部分，也是不可或缺之一。用户可通过专题信息查看其主要层级结构和内部构造划分。对主要层级可进行收藏展示，便于直观查看。可手动点击某一层级结构打开对应图层，查看详细信息。] 列表主要分为两种结构，一种为树状结构、一种为层级结构。以相同的数据模型展示不同的列表结构，便于用户选择。 ##逻辑列表项包括三角号小图标、收藏按钮和点击开关的按钮。根据不同情境分别设置相应的展示状态。 当为树状结构时：首先初始化专题列表，通过Id展示最新列表。当点击Item项时，我们会记录专题的id,通过id找到子集列表数据，查看子集的type类型是否为“catalog”,如果是该类型，则会继续打开。直到我们点击Item项为“group”类型时，这时图层状态则不显示下一级别。 当我们点击开关状态时，获取子结点数据，将当前状态设置为打开，设置专题是否可见，根据id判断找到父级与子级，并更新整个专题的数据。当开关状态点击到“group”级别时，下一级别则是“layer”级别，图层状态则不显示下一级别。直接在图层上加载layer级别的数据。关闭时如果点击group级别的数据，则会直接关闭当前对应级别数据，父级状态为半开状态，如果关闭“catalog级则会将子级数据共同关闭，直到点击状态为“catalog”级别，对应“parentLayerId”=-1时，这时所有子级数据将全部关闭。 当为层级结构时：当我们点击开关状态时，记录当前id,并通过id找到对应子级的信息，清空当前数据，将最新数据更新到列表上。关闭时当”parentLayerId!=-1”时,列表下方有一个按钮提示返回上一级，当点击按钮时会找到上一级别数据，将当前级别数据清空，并将父级数据展示到列表上，更新适配器。 Windows平台/AndroidStudio开发环境##重要代码实现1. 通过ID获取列表，projectId刚开始传入-1.显示根目录列表：public void replaceAndShowListById(Context context, String projectId, boolean isOnlyShow) { try { List&lt;ThemeInfo&gt; themeInfoList=TopicLayerManager.getSubTopicList(context, projectId); if (null != themeInfoList) { if (null != showList) { showList.clear(); } } listViewSetAdapter(themeInfoList); if (!isOnlyShow &amp;&amp; null != themeInfoList &amp;&amp; themeInfoList.size() &gt; 0) { TotalApplication.getListIdInstance().clear(); TotalApplication.getListIdInstance().add(projectId); } } catch (Exception e) { e.printStackTrace(); } } public synchronized void listViewSetAdapter(List&lt;ThemeInfo&gt; dmpList) { if (null != dmpList &amp;&amp; dmpList.size() &gt; 0) { if (null == projectAdapter) { if (null != this.themeListView) { this.showList = dmpList; projectAdapter = new TopicAdapter(this.context, this.showList, handler, isGradedData); this.themeListView.setAdapter(projectAdapter); } } else { this.showList = dmpList; projectAdapter.setThemeInfoList(this.showList); } } } 2. 列表Item的点击事件： public synchronized void clickItemResponse(Context context, int position) throws Exception { if (null != showList) { ThemeInfo node = showList.get(position); if (JudgeNullUtil.ObjIsNull(node)) { return; } List&lt;ThemeInfo&gt; dmpList = new ArrayList&lt;&gt;(); String projectId = node.getId(); String type = node.getType(); if (projectId != null &amp;&amp; projectId.length() &gt; 0 &amp;&amp; Constants.TYPE_CATLOG.equals(type)) { dmpList = TopicLayerManager.getSubTopicList(context, projectId); } if (null != dmpList &amp;&amp; dmpList.size() &gt; 0) { if (isGradedData) { if (projectId != null &amp;&amp; projectId.length() &gt; 0) { if (!node.isLeaf()) { node.setExpand(!node.isExpand()); if (node.isExpand()) { for (ThemeInfo cNode : dmpList) { cNode.setLevel(node.getLevel() + 1); } showList.addAll(position + 1, dmpList); listViewSetAdapter(showList); } else { List&lt;ThemeInfo&gt; rmList = new ArrayList&lt;&gt;(); TopicUtil.getAllChildren(node, rmList, showList, false); showList.removeAll(rmList); listViewSetAdapter(showList); } TotalApplication.getListIdInstance().add(projectId); } } } else { if (projectId != null &amp;&amp; projectId.length() &gt; 0) { showList = dmpList; listViewSetAdapter(showList); TotalApplication.getListIdInstance().add(projectId); } } } } } 3. 开关按钮的点击事件： public static void projectSwitch(Context context, Handler handler, List&lt;ThemeInfo&gt; themeInfoList, ThemeInfo info, TopicAdapter.ViewHolder finalHolder, boolean isGradedData) { List&lt;ThemeInfo&gt; parents = new ArrayList&lt;&gt;(); TopicUtil.getAllParent(info, parents, themeInfoList, false); List&lt;ThemeInfo&gt; childrens = new ArrayList&lt;&gt;(); TopicUtil.getAllChildren(info, childrens, themeInfoList, false); String openStatus = info.getOpenStatus(); if (!openStatus.equals(Constants.TOPIC_STATUS_OFF)) { finalHolder.isOpen.setImageResource(R.mipmap.topic_off); info.setOpenStatus(Constants.TOPIC_STATUS_OFF); TopicUtil.closeCurrentNode(info, themeInfoList, false); } else { finalHolder.isOpen.setImageResource(R.mipmap.topic_on); info.setOpenStatus(Constants.TOPIC_STATUS_ON); for (ThemeInfo node : childrens) { node.setOpenStatus(Constants.TOPIC_STATUS_ON); } for (ThemeInfo node : parents) { node.setOpenStatus(Constants.TOPIC_STATUS_ON); } } if (JudgeNullUtil.ObjIsNull(info)) { return; } TopicUtil.topicSwitchVisible(context, info, handler, isGradedData); } 4.通过图层id显示专题图层： /** * 通过图层id显示专题图层。 * * @param context 上下文 * @param visibleInfos 当前需要显示的图层 */ public static void setLayerVisible(Context context, List&lt;ThemeInfo&gt; visibleInfos, String currentStatus) throws Exception { if (JudgeNullUtil.ObjIsNull(visibleInfos)) { return; } boolean isOpenLayer = false; if (!currentStatus.equals(Constants.TOPIC_STATUS_OFF)) { isOpenLayer = true; } if(App.isOnLineData){ onlineVisibleLayer(context, visibleInfos, isOpenLayer); }else{ offlineVisibleLayer(visibleInfos,isOpenLayer); } } 5.更新专题数据： /** * 更新专题某一层级数据或整个专题数据源 */ public static void updateThemeList(Context context, List&lt;ThemeInfo&gt; themeList) throws Exception { App appCtx = (App) context.getApplicationContext(); appCtx.getDataSource().setTheme(themeList); } /** * 更新子级目录专题数据 */ public static List&lt;ThemeInfo&gt; updateSubData(ThemeInfo subThemeInfo, List&lt;ThemeInfo&gt; themeList) throws Exception { if (subThemeInfo == null) { return themeList; } String currentId = subThemeInfo.getId(); if (currentId == null || JudgeNullUtil.ObjIsNull(themeList)) { return themeList; } List&lt;String&gt; subLayerIds = getSubLayerIds(currentId, themeList); if (JudgeNullUtil.ObjIsNull(subLayerIds)) { return themeList; } assert subLayerIds != null; for (int i = 0; i &lt; subLayerIds.size(); i++) { String subId = subLayerIds.get(i); subThemeInfo.setId(subId); String type = getThemeType(subThemeInfo, themeList); updateCurrentData(subThemeInfo, themeList); if (type == null) { continue; } if (type.equals(Constants.TYPE_CATLOG)) { updateSubData(subThemeInfo, themeList); } } return themeList; } 6. 更新layer数据：/** * 设置layer显示状态 * @param layer专题图层 * @param visibleIds 图层id */ public static void updateLayerVisible(Layer layer, int[] visibleIds, boolean isOpenLayer) throws Exception { if (layer == null) { return; } if (layer instanceof ArcGISDynamicMapServiceLayer) { ArcGISDynamicMapServiceLayer dynamicLayer = (ArcGISDynamicMapServiceLayer) layer; refreshDynamicLayer(visibleIds, dynamicLayer, isOpenLayer); } else { layer.setVisible(isOpenLayer); } } /** * 根据visibleIds 更新DymicLayer * @param visibleIds layer Ids * @param dynamicLayer 当前需要刷新的图层 */ private static void refreshDynamicLayer(int[] visibleIds, ArcGISDynamicMapServiceLayer dynamicLayer, boolean isOpenLayer) throws Exception { if (dynamicLayer == null) { return; } ArcGISLayerInfo[] arcGISLayerInfos = dynamicLayer.getAllLayers(); if (visibleIds.length &gt; arcGISLayerInfos.length) { return; } ArcGISLayerInfo layerInfo; for (int index : visibleIds) { if (index &lt; 0) { continue; } layerInfo = arcGISLayerInfos[index]; if (layerInfo == null) { continue; } boolean isVisible = layerInfo.isVisible(); ArcGISLayerInfo layerParentInfo = layerInfo.getParentLayer(); if (layerParentInfo != null) { boolean parentVisible = layerParentInfo.isVisible(); if (isOpenLayer) { if (!parentVisible) { layerParentInfo.setVisible(true); } } else { if (parentVisible) { layerParentInfo.setVisible(false); } } } if (isOpenLayer) { if (!isVisible) { layerInfo.setVisible(true); } } else { if (isVisible) { layerInfo.setVisible(false); } } } if (!dynamicLayer.isVisible()) { dynamicLayer.setVisible(true); } dynamicLayer.refresh(); } 结语专题模块的开发提高了项目的灵活性和通透性，大大缩短了用户点击搜索的时间，保证了多层级结构加载时层与层之间的联系不冲突，确保它们之间稳定性。查询时可通过坐标点查询多个图层所对应信息，大大缩短了查询效率，确保项目的顺利进行。为后期新功能迭代打下坚实基础，提高用户体验。]]></content>
      <categories>
        <category>mobile</category>
      </categories>
      <tags>
        <tag>移动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome-Devtool]]></title>
    <url>%2FXDATA.Blog%2F2018%2F08%2F14%2FTOOLS%2FChrome-Devtool%2F</url>
    <content type="text"><![CDATA[基于Chrome DevTools的Web应用程序的性能分析 ======= 前端页面渲染——原理：定义： 即是web用户在访问一个页面时所要花费的时间总和。即一个完全意义上的用户响应时间，相对于服务器的响应时间而言还会包括更多的内容和影响因素。那么一个web页面的完整请求包括了哪些部分的时间总和就是web前端性能分析和优化所需要了解的基础知识，先了解一下用户从浏览器访问一个url后到页面完全展示所有内容的整个过程吧。 页面请求的过程： 浏览器的url请求 递归寻找DNS服务器 连接目标IP并建立TCP连接 向目标服务器发送http请求 web服务器接收请求后处理 web服务器返回相应的结果【无效、重定向、正确页面等】 浏览器接收返回的http内容 页面解析的过程： Dom Tree：浏览器将html解析成一个dom树，dom树的创建时一个深遍历的过程。 Css Rule Tree：将css样式全部解析成Css Rule Tree的规则树。 Render Tree：将Dom Tree和Css Rule Tree结合进行Render Tree的构建，Render Tree不同于Dom Tree，它将一些没有必要渲染的dom节点进行了相应的处理，例如：header标签，display为none的标签元素等。 layout：有了Render Tree我们就可以对每个节点在屏幕中的位置进行计算处理。 paiting: 最后通过位置和样式进行相应的节点进行绘制展示在前端页面上。 影响前端流畅相应的因素（回流与重绘）减少Render Tree的回流和重绘，主要需要处理的是回流问题。定义：回流： Render Tree中的元素因为尺寸，布局，隐藏等改变而需要重新构建，这就叫做回流（reflow）。 重绘：当Render Tree的一部分元素需要更新元素，而这些元素只是外观，风格不影响布局，则叫做重绘。 注： 回流必定带来重绘，而重绘不一定会回流，回流带来页面渲染的工作量打，过多的回流容易造成页面的卡顿。 浏览器的优化策略：一般浏览器都会进行回流的优化处理，因为回流的代价比较大，所以如果每一个操作都需要进行回流处理，那么浏览器很容易承受不住，于是浏览器自身就进行了优化处理，将回流和重绘操作放置在一个队列中，在到达一定时间或者一定数量则进行批量的处理，这样将多次的回流和重绘操作减少成为一次的操作。 前端注意：一些操作可能提前强制浏览器对队列进行flush，例如在向浏览器请求一些style信息时就可能造成队列flush。 请求offsetTop、offsetLeft、offsetWidth、offsetHeight时 请求scrollTop、scrollLeft、scrollWidth、scrollHeight 请求clientTop、clientLeft、clentWidth、clientHeight 请求getComputedStyle()计算样式时 因为请求一些属性时，浏览器为了给精确的值，队列中的一些操作可能会影响到这些值，那么即使获取元素的布局和样式信息根最近发生或者改变的布局信息无关，浏览器都会强行刷新渲染队列。 减少回流的策略： 减少回流和重绘其实就是减少对Render Tree的操作，减少对一些style信息的请求，尽量利用浏览器的优化策略。 直接改变className，如果动态改变样式则使用cssText（考虑没有优化浏览器） // 不好的写法 var left = 1; var top = 1; el.style.left = left + &#39;px&#39;; el.style.top = top + &#39;px&#39;; // 比较好的写法 el.className = &#39;class1&#39;; 让操作元素进行“离线处理”，处理完一起更新a) 使用DocumentFragment进行缓存操作,引发一次回流和重绘； // 不好的写法 var p = document.createElement(&#39;p&#39;); var t = document.createTextNode(&#39;text1&#39;); p.appendChild(t); document.appendChild(p); // 引起一次回流 p = document.createElement(&#39;p&#39;); t = document.createTextNode(&#39;text2&#39;); p.appendChild(t); document.body.appendChild(p); // 又引起一次回流 // 比较好的写法 var farg = document.creatDocumentFragment(); var p = document.creatElement(&#39;p&#39;); var t = document.creatTextNode(&#39;text1&#39;); p.appendChild(t); farg.appendChild(p); p = document.creatElement(&#39;p&#39;); t = document.creatTextNode(&#39;text2&#39;); p.appendChild(t); farg.appendChild(p); document.body.appendChild(frag); // 这样只会引起一次回流 b) 使用display:none技术，只引发两次回流和重绘； var container = document.getElementById(&#39;div1&#39;); container.style.display = &#39;none&#39;; // 引起一次回流 for (var i = 0; i &lt; 10; i++) { var p = document.createElement(&#39;p&#39;); var t = document.creatTextNode(&#39;text&#39; + i); container.appendChild(p); } container.style.display = &#39;block&#39;; // 引起另外一次回流 c) 使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘； //建立克隆镜像 var oldNode = document.getElementById(&#39;target&#39;), clone = oldNode.cloneNode(true); //深复制 // 处理克隆对象的操作.... //完成后 oldNode.parentNode.replaceChild(clone,oldNode); 不要经常访问会flush队列的属性，如果确定要访问，则多利用缓存 // 不好的方式 for(循环) { el.style.left = el.offsetLeft + 5 + &#39;px&#39;; el.style.top = el.offsetTop + 5 + &#39;px&#39;; } // 好的方式 var left = el.offsetLeft, top = el.offsetTop, s = el.style; for (循环) { left += 10; top += 10; s.left = left + &#39;px&#39;; s.top = top + &#39;px&#39;; } 让元素脱离动画流，减少回流的Render Tree的规模 Performanance的使用Chrome Performance： 主要是用于页面性能分析，可进行页面状态、事件、运行、内存查看，通过操作页面查看性能情况，进行分析定位。Demo测试： https://googlechrome.github.io/devtools-samples/jank/ 1、先对移动方块进行添加，添加至页面进行卡顿，因为每台机器的性能不同，添加至一定数目之后才会造成卡顿 2、打开开发者工具进行performance的记录得到分析数据的展示情况。 1) 数据展示主要的花费事件在于Rendering 2) fps显示红色提醒，卡顿，缩放至细节查看 3) 点击有红色三角的Recalculate Style的调用栈。 发现有提示可能发生回流情况，点击reveal查看详细信息。 进入代码查看在app.js的70行代码发生了回流情况。 ![image](png7.png) 发现在其中多次访问了offsetTop的属性，造成了回流问题。 ![image](png8.png) 3、在采用另外一种优化性能方式查看代码（获取样式top缓存处理不多次访问），发现页面流畅了很多。 Memory的使用Chrome Memory： 主要是用于深度性能分析，提供记录场景运行、记录堆快照、记录堆分配等三个功能实现对渲染性能和内存泄漏的分析定位。 快照的方式Demo测试： https://handsome-hang.github.io/test/chrome/目前采用比较多的方式是是使用快照对比来完成，如图： 1、首先在初始化页面进行一次快照处理记录初始化状态。（基本参照） 2、然后进行点击添加按钮进行widget的创建添加。 3、接着进行删除操作对widget进行了移除处理，进行一次快照获取。 4、然后反复先前操作进行快照记录处理。 可以发现内存在一次次操作后得到的快照内存大小不断的在增长，这个时候就可以判断出应该是有内存泄漏没有被回收。 5、将获取的快照进行对比处理。 6、对引用类型（以Detached DOM 为例子）进行分析查看， #Delta是否有不断增加，如果有则是有异常内存泄漏。 7、查看详细增长内容有属性被哪些地方引用而导致没有办法回收，发现widget的一些信息没有被回收而一直存在。 8、通过删除操作找到对应的代码，来查看widget被移除操作中间发生了什么而导致widget内容没有被回收，发现index.html代码中有问题。 // 问题所在 domConstruct.destroy(window.container1.domNode); // 只是移除了dom节点，并没有对widget整个对象进行处理导致有引用存在 // 将widget进行整个摧毁处理调用destroy方法 window.container.destroy(); // 进行widget的摧毁处理 9、之后再次进行来看内存是否能够被及时的处理，发现内存增长停止了，并且Detached DOM增长没有了，内存被及时的回收防止了内存的泄漏。 Memory还有提供另外两个分析内存的工具。Collect JavaScript CPU Profile： 记录一段场景cpu的分配使用情况。 对其中对内存影响较大的，并且有提示的方法进行相应的注意和相应的处理 Record Heap Allocations： 一段记录堆分配内存进行处理 堆突出的蓝条，如果没有释放掉要进行特别注意并且分析其中的情况详情，如果没有释放则需要跟踪代码进行处理 内存泄漏的原因：（1）监听在window/document/body等handler事件没有解绑 （2）模块形成的闭包内部变量使用完后没有将引入变量设为null （3）使用第三方库创建，没有调用正确的销毁函数 （4）dom的移除若子节点存在引用则无法回收 （5）widget使用事件的订阅，在摧毁时没有移除 总结语在Performance中已经可以完成大多数的性能检测定位。而在其中Memory进行详细分析处理内存泄漏问题处理，使用工具处理问题是一部分解决方案，但是根源问题还是在于编码的规范问题，如果已经成熟的系统，在内存性能检测上是很麻烦的事情，所以内存性能检测是一个不断持续的过程。 内容中如果出现什么有错误的地方请及时的提醒，以便进行及时的修正。]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>chrome devtool 性能分析 内存泄露</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动用地分析]]></title>
    <url>%2FXDATA.Blog%2F2018%2F08%2F13%2FMOBILE%2F%E7%94%A8%E5%9C%B0%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[移动用地分析功能 简介 用地分析是指在对地区各自然要素进行综合分析研究的基础上，按照城市规划和建设要求、用地整备工程技术的可能性和经济性，对城市规划用地进行适用性分析评定，以划出城市用地的不同等级。另外用于查清村和农、林、牧、渔场，居民点及其以外的独立工矿企事业单位土地权属界线和村以上各级行政界线，查清各类用地面积、分布和利用状况。在本文中，用地分析主要实现为对所选中区域进行土地类别、面积和分布的识别与判断，计算其中各个层级占其父级的百分比以及面积情况。* 实现逻辑略析 可视化与相关功能操作窗口的基本实现 加载功能基础的地图底图与分析操作图层 分析区域的选择并获取当前图形 离线调用FeatureQuery（在线调用QueryTask）进行要素查询与过滤 获得结果FeatureResult，从中获取Geometry（并非与绘制图形做过交叉处理的Geometry）与Attribute 图形切割与面积计算 通过GraphicLayer进行图形展示以及图形条组与相应控件Item绑定 重要部分代码实现 1.分析区域选择 //通过多点集合绘制几何图形 polygon.lineTo(currentPoint); currentGraphic = new Graphic(polygon, symbol); drawLayer.updateGraphic(currentGraphicIndex,currentGraphic); pointGraphic=new Graphic(multiPoint,pointSymbol); drawLayer.updateGraphic(pointGraphicIndex,pointGraphic); multiPoint.add(currentPoint); if(lastGraphicIndex!=-1){ drawLayer.removeGraphic(lastGraphicIndex); } lastGraphic=new Graphic(currentPoint,lastSymbol); lastGraphicIndex=drawLayer.addGraphic(lastGraphic); 2.地图查询 离线查询 离线查询通过初始化一个QueryParameter并设置其参数，调用FeatureLayer对象的QueryFeature方法进行查询，拿到查询结果的Geometry与Attribute。 QueryParameters queryParams=new QueryParameters(); //设置区域 if (isALL) { queryParams.setGeometry(mapView_main.getExtent()); }else { Polygon queryPolygon=measureManager.getpolygon(); queryParams.setGeometry(queryPolygon); } //设置过滤字段 queryParams.setOutFields(new String[]{&quot;*&quot;}); landAnalysisResultInfos=new ArrayList&lt;&gt;(); List&lt;LandAnalysisResultInfo&gt; analysisResultInfos=new ArrayList&lt;&gt;(); Future&lt;FeatureResult&gt; resultFuture=null; FeatureResult featureResult=null; FeatureLayer featureLayer=(FeatureLayer)layer; resultFuture=featureLayer.getFeatureTable().queryFeatures(queryParams,callbackListener); try { //获取结果 featureResult=resultFuture.get(); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } if (featureResult!=null&amp;&amp;featureResult.featureCount()&gt;0) { Iterator it = featureResult.iterator(); while (it.hasNext()){ GeodatabaseFeature geodatabaseFeature= (GeodatabaseFeature) it.next(); Geometry geometry=geodatabaseFeature.getGeometry(); &lt;String, Object&gt; featureMap=geodatabaseFeature.getAttributes(); if(geometry!=null){ //进行图形处理 } if (featureMap!=null&amp;&amp;featureMap.size()&gt;0) { //进行内容详情提取处理 } } 在线查询 在线查询通过初始化一个QueryParameter并设置其参数，然后通过在线图层的URL初始化一个QueryTask，通过其对象的execute方法拿到查询结果的Geometry与Attribute。 QueryParameters queryParams=new QueryParameters(); Polygon Querypolygon=measureManager.getpolygon(); queryParams.setGeometry(Querypolygon); landAnalysisResultInfos=new ArrayList&lt;&gt;(); queryParams.setOutFields(new String[]{&quot;*&quot;}); List&lt;LandAnalysisResultInfo&gt; analysisResultInfos=new ArrayList&lt;&gt;(); Future&lt;FeatureResult&gt; resultFuture=null; FeatureResult featureResult=null; ArcGISDynamicMapServiceLayer featureLayer=(ArcGISDynamicMapServiceLayer)layer; QueryTask queryTask=new QueryTask(featureLayer.getQueryUrl(0)); resultFuture=queryTask.execute(queryParams, callbackListener); try { featureResult=resultFuture.get(); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } if (featureResult!=null&amp;&amp;featureResult.featureCount()&gt;0) { for (Object element : featureResult) { if (element instanceof Feature) { Feature f = (Feature) element; Geometry geometry=f.getGeometry(); Map&lt;String, Object&gt; featureMap=f.getAttributes(); if(geometry!=null){ //进行图形处理 } if (featureMap!=null&amp;&amp;featureMap.size()&gt;0) { //进行内容详情提取处理 } } } } 3.图形交叉处理 通过调用GeometeyEngine.intersect()方法获取。 Geometry geometry = GeometryEngine.intersect(geometry,measureManager.getpolygon(),mapView_main.getSpatialReference()); 4.面积计算 由于获取的Geometry的面积与其父Geometry的面积均为调用Geometry对象的calculateArea2D()方法，并非实际面积。所以我们需要通过Attribute获得的实际面积计算切割Geometry与其父Geometry的实际面积，并计算其百分比。 /** *通过在地图上的Area大小计算百分比与实际面积 * * @param landResourceInfos 分析结果的数组 成员： {@link LandAnalysisResultInfo} * @return 一个结果的数组 变更了参数数组中成员的属性 */ public static List&lt;LandAnalysisResultInfo&gt; getLandPercentValue(List&lt;LandAnalysisResultInfo&gt; landResourceInfos){ /*计算实际面积 */ double MUM=0; for (LandAnalysisResultInfo landResourceInfo : landResourceInfos) { if (landResourceInfo.getYDMJ()==null) { landResourceInfos.remove(landResourceInfo); continue; } Double visualArea=landResourceInfo.getGeometry().calculateArea2D(); Double visualParentArea=landResourceInfo.getParentGeometry().calculateArea2D(); Double realArea=landResourceInfo.getYDMJ()/visualParentArea*visualArea; landResourceInfo.setYDMJ(realArea); //累计求和 MUM=MUM+landResourceInfo.getYDMJ(); } /*分别计算百分比*/ for (LandAnalysisResultInfo landResourceInfo : landResourceInfos) { landResourceInfo.setPercentValue(String.valueOf(landResourceInfo.getYDMJ()/MUM*100)); } return landResourceInfos; } 5.图形展示 由于本次使用为列表显示，故图形展示在点击子Item的时候进行Geometry的绘制与添加。 /** * 结果列表点击效果 */ private AdapterView.OnItemClickListener resultListOnItemClickListener =new AdapterView.OnItemClickListener() { @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) { resultDrawerLayer.removeAll(); resultDrawerLayer.addGraphic(new Graphic(landAnalysisResultInfos.get(position).getGeometry(), MapViewTapTool.getLabelSymbol(MainMapActivity.this,Geometry.Type.POLYGON, Color.BLUE))); resultDrawerLayer.addGraphic(new Graphic(landAnalysisResultInfos.get(position).getParentGeometry(),MapViewTapTool.getLabelSymbol(MainMapActivity.this,Geometry.Type.POLYLINE, Color.BLACK))); Envelope tempEnvelope = new Envelope(); landAnalysisResultInfos.get(position).getParentGeometry().queryEnvelope(tempEnvelope); Point tempPoint = tEnvelope.getCenter(); mapView_main.centerAt(tempPoint,true); } }; 结语 &emsp;&emsp;用地分析功能的开发，既减少了用户查看地图计算面积的时间，提高了地图的可阅读性。让用户通过移动设备简单的操作即可获取选取区域中各类型的板块内容与面积，并通过绘制图层让用户在地图上更直观的看清板块对象。 相关关键代码查看 &emsp;]]></content>
      <categories>
        <category>mobile</category>
      </categories>
      <tags>
        <tag>移动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动在线缓存功能]]></title>
    <url>%2FXDATA.Blog%2F2018%2F08%2F10%2FMOBILE%2F%E5%9C%A8%E7%BA%BF%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[#1. 简介 离线在线一体化数据存储在企业级地理数据库中，通过Arcgis桌面加载后配图处理，并发布到Arcgis for Server中，供移动端设备编辑使用，并可以同步回传版本化存档。 应用场景在没有网络的情况下我们需要用到在线的地图数据进行操作，这些数据需要有一定的时效性，如果采用，打包离线包的方式提前做好离线数据，那时效性相对较差。所以，用在线缓存技术可以支持这一点。#2. 在线缓存的实现逻辑思路 在地图上选定区域，作为需要下载对应离线数据的地图范围（可以设定范围，也可以自定义） 获取下载滴地图服务所需要的具体参数 在本地创建文件，存放下载的数据，以供使用#3. 用到的核心功能类以及说明 GeodatabaseSyncTask类，实现下载同步功能 GenerateGeodatabaseParameters，下载数据时所需的参数对象，该类构造函数一共有7个根据需要选择 CallbackListener，完成GDB数据库下载的回调函数类，在该回调中我们只可以执行一些操作，如示例里在回调中删除了在线的服务图层，加载离线的数据图层到地图上进行显示。通过Geodatabase本地数据库可以获取要素图层列表List&lt;GdbFeatureTable&gt;对象，通过newFeatureLayer(gdbFeatureTable)来创建一个离线要素图层进行要素显示。 GeodatabaseStatusCallback，本地数据库回调状态类，在数据下载过程中会有很多状态改变，各种状态改变时都会走这个类的回调函数。 GeodatabaseTask.generateGeodatabase，通过该方法生成离线数据库和相应的要素表，方法需要传递上面介绍的三个参数和一个数据库存储的路径。#4. 代码示例 在地图上自定义一个区域 /** * 绘制出在线缓存区域 * */ private void polygonState(Point currentPoint)throws Exception{ if(startPoint!=null&amp;&amp;!startPoint.isEmpty()){ polygon.lineTo(currentPoint); currentGraphic = new Graphic(polygon, symbol); drawLayer.updateGraphic(currentGraphicIndex,currentGraphic); pointGraphic=new Graphic(multiPoint,pointSymbol); drawLayer.updateGraphic(pointGraphicIndex,pointGraphic); multiPoint.add(currentPoint); if(lastGraphicIndex!=-1){ drawLayer.removeGraphic(lastGraphicIndex); } lastGraphic=new Graphic(currentPoint,lastSymbol); lastGraphicIndex=drawLayer.addGraphic(lastGraphic); if(polygon.getPointCount()&gt;=3){ isCheckedSave=true; isSave=isCheckedSave; onlinesave.setTextColor(ContextCompat.getColor(mActivity,R.color.blue)); onlinesave.setClickable(isSave); } }else{ polygon=new Polygon(); multiPoint=new MultiPoint(); polygon.startPath(currentPoint); startPoint=currentPoint; currentGraphic=new Graphic(startPoint,symbol); currentGraphicIndex=drawLayer.addGraphic(currentGraphic); pointGraphic=new Graphic(startPoint,lastSymbol); pointGraphicIndex=drawLayer.addGraphic(pointGraphic); multiPoint.add(currentPoint); } } /** * 确定所选区域范围 * */ public void SaveLabel()throws Exception{ if(isSave&amp;&amp;drawLayer!=null) { startPoint = null; isCheckedSave=false; isSave=isCheckedSave; onlinesave.setTextColor(ContextCompat.getColor(mActivity,R.color.gray)); onlinesave.setClickable(isSave); if(currentGraphicIndex!=-1){ Graphic graphic = drawLayer.getGraphic(currentGraphicIndex); if(graphic!=null){ Geometry geometry=graphic.getGeometry(); Graphic saveGraphic=null; if(geometryType.equals(Geometry.Type.POLYGON)){ symbol=MapViewTapTool.getLabelSymbol(mActivity,geometryType,ContextCompat.getColor(mActivity,R.color.green_transparent)); saveGraphic=new Graphic(geometry,symbol); pointSymbol=MapViewTapTool.getCircleGreenSymbol(mActivity); pointGraphic=new Graphic(geometry,pointSymbol); }else{ symbol=MapViewTapTool.getLabelSymbol(mActivity,geometryType,ContextCompat.getColor(mActivity,R.color.green)); saveGraphic=new Graphic(geometry,symbol); pointSymbol=MapViewTapTool.getCircleGreenSymbol(mActivity); pointGraphic=new Graphic(geometry,pointSymbol); } if(onlineCacheInfoList!=null&amp;&amp;onlineCacheInfoList.size()&gt;0){ setView(); int i = 0; if(onlineCacheInfoList.get(i).getCacheurl().trim().length()&gt;0) { downloadData(onlineCacheInfoList.get(i), geometry, i);//缓存featureLayer } } } } }else{ isCheckedSave=false; isSave=isCheckedSave; onlinesave.setTextColor(ContextCompat.getColor(mActivity,R.color.gray)); onlinesave.setClickable(isSave); } } 下载选定区域所对应的在线缓存的文件 private void downloadData(final OnlineCacheInfo onlineCacheInfo, final Geometry geometry, final int i) { gdbSyncTask = new GeodatabaseSyncTask(onlineCacheInfo.getCacheurl(), null); gdbSyncTask.fetchFeatureServiceInfo(new CallbackListener&lt;FeatureServiceInfo&gt;() { @Override public void onError(Throwable arg0) { Log.e(TAG, &quot;Error fetching FeatureServiceInfo&quot;); } @Override public void onCallback(FeatureServiceInfo fsInfo) { if (fsInfo.isSyncEnabled()) { //回调获取所需要的下载的图层信息 createGeodatabase(onlineCacheInfo.getIds(),geometry,i); } } }); } //创建下载 private void createGeodatabase(int[] ids, final Geometry geometry, final int i) { SpatialReference sp=mOneMapView.getSpatialReference(); GenerateGeodatabaseParameters params = new GenerateGeodatabaseParameters(ids, geometry,sp,true, SyncModel.GEODATABASE); CallbackListener&lt;String&gt; gdbResponseCallback = new CallbackListener&lt;String&gt;() { @Override public void onError(final Throwable e) { Log.e(TAG, &quot;Error creating geodatabase&quot;); Toast.makeText(mActivity, &quot;数据下载失败!&quot;, Toast.LENGTH_LONG).show(); pDialog.dismiss(); } @Override public void onCallback(String path) { updateFeatureLayer(path); if(i&lt;onlineCacheInfoList.size()&amp;&amp;onlineCacheInfoList.get(i+1).getCacheurl().trim().length()&gt;0){ downloadData(onlineCacheInfoList.get(i+1),geometry,i+1); }else { pDialog.dismiss(); Toast.makeText(mActivity, &quot;数据下载完成!&quot;, Toast.LENGTH_LONG).show(); } } }; localGdbFilePath = &quot;对应在本地存储的存储路径以及存储名称&quot;; submitTask(params, localGdbFilePath, statusCallback, gdbResponseCallback); } private void submitTask(GenerateGeodatabaseParameters params, String file, GeodatabaseStatusCallback statusCallback, CallbackListener&lt;String&gt; gdbResponseCallback) { // submit task gdbSyncTask.generateGeodatabase(params, file, false, statusCallback, gdbResponseCallback); } 将下载完成的数据再地图上展示 //加载数据 private void updateFeatureLayer(String featureLayerPath) { // create a new geodatabase Geodatabase localGdb = null; try { localGdb = new Geodatabase(featureLayerPath); } catch (FileNotFoundException e) { e.printStackTrace(); } if (localGdb != null) { for (GeodatabaseFeatureTable gdbFeatureTable : localGdb .getGeodatabaseTables()) { if (gdbFeatureTable.hasGeometry()){ mOneMapView.addLayer(new FeatureLayer(gdbFeatureTable)); } } } } #5. 结语在线缓存的应用，减少了手动制作离线数据的步骤，大大提高了地图制作的效率，只需发布对应的地图服务就能实现离线数据的在线下载。另外也同时保证了数据的时效性，如果对应地图服务有新的数据更改，那我们可以重新下载新的在线数据，不需要再去手动打包地图文件。 最后感谢您的阅读，有机会一起探讨！]]></content>
      <categories>
        <category>mobile</category>
      </categories>
      <tags>
        <tag>移动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World With Hexo]]></title>
    <url>%2FXDATA.Blog%2F2018%2F08%2F10%2FHEXO%2Fhello-world%2F</url>
    <content type="text"><![CDATA[快速开始创建一篇新的博客$ hexo new &quot;My New Post&quot; 详情: Writing 启动服务器$ hexo server 详情: Server 生成博客静态文件$ hexo generate 详情: Generating 发布到服务器$ hexo deploy 详情: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 配置完善]]></title>
    <url>%2FXDATA.Blog%2F2018%2F08%2F10%2FHEXO%2FHexo%E9%85%8D%E7%BD%AE%E5%AE%8C%E5%96%84%2F</url>
    <content type="text"><![CDATA[hexo搭建后,我们需要加入许多个性化功能,在此进行记录. 添加返回顶部按钮 打开\themes\landscape\layout_partial,新建文件名称为totop.ejs. &lt;div id=&quot;totop&quot;&gt; &lt;a title=&quot;javascript:;&quot;&gt;返回&lt;br&gt;顶部&lt;/a&gt; &lt;/div&gt; 打开\themes\landscape\source\js,新建文件totop.js. (function($) { var upperLimit = 1000; // Our scroll link element var scrollElem = $(&#39;#totop&#39;); // Scroll to top speed var scrollSpeed = 1600; scrollElem.hide(); $(window).scroll(function () { var scrollTop = $(document).scrollTop(); if ( scrollTop &gt; upperLimit ) { $(scrollElem).stop().fadeTo(300, 1); }else{ $(scrollElem).stop().fadeTo(300, 0); } }); $(scrollElem).click(function(){ $(&#39;html, body&#39;).animate({scrollTop:0}, scrollSpeed); return false; }); })(jQuery); 打开\themes\landscape\layout_partial\after_footer.ejs,添加代码 &lt;%- partial(&#39;totop&#39;) %&gt; &lt;script src=&quot;&lt;%- config.root %&gt;js/totop.js&quot;&gt;&lt;/script&gt; 设置样式,打开\themes\landscape\source\css_partial,创建文件totop.styl,添加样式代码 #totop position:fixed bottom:50px right:30px text-align: center z-index: 100 a display: block padding 4px 8px color: #fff background-color: #258fb8 cursor: pointer border-radius: 5px &amp;:hover opacity: .8 打开\themes\landscape\source\css\style.styl,添加代码 @import &quot;_partial/totop&quot;]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebPack4入门]]></title>
    <url>%2FXDATA.Blog%2F2018%2F07%2F10%2FWEBPACK%2FWebpack4%E5%8F%8A%E6%A8%A1%E5%9D%97%E7%BB%91%E5%AE%9A%E5%85%A5%E9%97%A8%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[Webpack4及模块绑定入门手册 本文在我们的书《现代JavaScript工具和技能》中有所介绍。 让我们一起熟悉支持现代JavaScript开发的基本工具。 Webpack4 文档中说到： Webpack是一个module bundler。 它的主要目的是捆绑JavaScript文件以便在浏览器中使用，但它也能够转换，捆绑或打包任何资源。 Webpack已成为现代Web开发最重要的工具之一。 它主要是JavaScript的module bundler，但它可以用来转换所有前端资源，如HTML，CSS，甚至图像。 它可以让您更好地控制应用程序正在进行的HTTP请求的数量，并允许您使用其他类型的这些资源（例如，Pug，Sass和ES8）。 Webpack还允许您轻松地从npm使用包。 本文面向那些刚接触Webpack的人，将介绍初始设置和配置，模块，加载器（loaders），插件，代码拆分和热模块更换。 如果您发现视频教程很有帮助，我强烈推荐Glen Maddern的Webpack from First Principles 作为起点，了解Webpack的特殊之处。 它现在有点旧了，但原则仍然相同，这是一个很好的介绍。 要在家中进行操作，您需要安装Node.js. 您也可以从我们的GitHub仓库下载演示应用程序。 开始让我们用npm初始化一个新项目并安装webpack和webpack-cli： mkdir webpack-demo &amp;&amp; cd webpack-demo npm init -y npm install --save-dev webpack webpack-cli 接下来我们将创建下面文件结构和内容： webpack-demo |- package.json |- webpack.config.js |- /src |- index.js |- /dist |- index.html dist/index.html &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Hello Webpack&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; src/index.js const root = document.createElement(&quot;div&quot;) root.innerHTML = `&lt;p&gt;Hello Webpack.&lt;/p&gt;` document.body.appendChild(root) webpack.config.js const path = require(&#39;path&#39;) module.exports = { entry: &#39;./src/index.js&#39;, output: { filename: &#39;bundle.js&#39;, path: path.resolve(__dirname, &#39;dist&#39;) } } 这告诉Webpack在我们的入口点src / index.js中编译代码并在/dist/bundle.js中输出一个bundle。 我们来添加一个用于运行Webpack的npm脚本。 package.json { ... &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;develop&quot;: &quot;webpack --mode development --watch&quot;, &quot;build&quot;: &quot;webpack --mode production&quot; }, ... } 使用npm run develop命令，我们可以创建我们的第一个包！ Asset Size Chunks Chunk Names bundle.js 2.92 KiB main [emitted] main 您现在应该可以在浏览器中加载dist / index.html并看到“Hello Webpack”。 打开dist / bundle.js以查看Webpack的功能。 顶部是Webpack的模块引导代码，底部是我们的模块。 你可能对此还没有很深刻的印象，但是如果你已经走到这一步，你现在可以开始使用ES模块，而Webpack将能够生成一个适用于所有浏览器的生产包。 使用Ctrl + C重新编译并运行npm run build以在生产模式下编译我们的bundle。 Asset Size Chunks Chunk Names bundle.js 647 bytes main [emitted] main 请注意，捆绑包大小已从2.92 KiB降至647字节。 再看一下dist / bundle.js，你会看到一堆丑陋的代码。 我们的软件包已经用UglifyJS缩小了：代码将运行完全相同，但它是以尽可能小的文件大小完成的。 模式开发优化了构建速度和调试 模式生产优化了运行时的执行速度和输出文件大小。 模块使用ES模块，您可以将大型程序拆分为许多小型自包含程序。 创造性地，Webpack知道如何使用导入和导出语句来使用ES模块。 举个例子，让我们现在通过安装lodash-es并添加第二个模块来尝试这个： npm install --save-dev lodash-es src/index.js import { groupBy } from &quot;lodash-es&quot; import people from &quot;./people&quot; const managerGroups = groupBy(people, &quot;manager&quot;) const root = document.createElement(&quot;div&quot;) root.innerHTML = `&lt;pre&gt;${JSON.stringify(managerGroups, null, 2)}&lt;/pre&gt;` document.body.appendChild(root) src/people.js const people = [ { manager: &quot;Jen&quot;, name: &quot;Bob&quot; }, { manager: &quot;Jen&quot;, name: &quot;Sue&quot; }, { manager: &quot;Bob&quot;, name: &quot;Shirley&quot; } ] export default people 运行npm run develop启动Webpack并刷新index.html。 您应该看到按管理器分组的一组人员打印到屏幕上。 注意：导入一个像‘es-lodash’这样没有相对路径的模块，是从npm安装到 node_modules的模块。 你自己的模块总是需要一个像‘./people’这样的相对路径，因此你可以区分它们。 请注意，在控制台中我们的捆绑包大小已增加到1.41 MiB！ 这值得关注，但在这种情况下，没有理由担心。 使用npm run build在生产模式下编译，lodash-es中的所有未使用的lodash模块都将从bundle中删除。 删除未使用的导入的过程称为tree-shaking，并且是Webpack免费获得的。 &gt; npm run develop Asset Size Chunks Chunk Names bundle.js 1.41 MiB main [emitted] [big] main &gt; npm run build Asset Size Chunks Chunk Names bundle.js 16.7 KiB 0 [emitted] main 装载加载程序允许您在导入文件时运行预处理程序。 这允许您将静态资源捆绑到JavaScript之外，但让我们看看在首先加载.js模块时可以做些什么。 让我们通过下一代JavaScript转换器Babel运行所有.js文件来保持代码的现代化： npm install --save-dev &quot;babel-loader@^8.0.0-beta&quot; @babel/core @babel/preset-env webpack.config.js const path = require(&#39;path&#39;) module.exports = { entry: &#39;./src/index.js&#39;, output: { filename: &#39;bundle.js&#39;, path: path.resolve(__dirname, &#39;dist&#39;) }, module: { rules: [ { test: /\.js$/, exclude: /(node_modules|bower_components)/, use: { loader: &#39;babel-loader&#39;, } } ] } } .babelrc { &quot;presets&quot;: [ [&quot;@babel/env&quot;, { &quot;modules&quot;: false }] ], &quot;plugins&quot;: [&quot;syntax-dynamic-import&quot;] } 此配置可防止Babel将导入和导出语句转换为ES5，并启用动态导入，这个我们将在后面的“代码拆分”一节中介绍。 我们现在可以自由使用现代语言功能，它们将被编译为在所有浏览器中运行的ES5。 SassLoaders可以链接在一起进行一系列变换。 从我们的JavaScript导入Sass可以较好地演示它是如何工作的： npm install --save-dev style-loader css-loader sass-loader node-sass webpack.config.js module.exports = { ... module: { rules: [ ... { test: /\.scss$/, use: [{ loader: &#39;style-loader&#39; }, { loader: &#39;css-loader&#39; }, { loader: &#39;sass-loader&#39; }] } ] } } 这些加载器以相反的顺序处理: sass-loader将Sass转换为CSS。 css-loader将CSS解析为JavaScript并解析任何依赖项。 style-loader将我们的CSS输出到文档中的&lt;style>标记中。 您可以将这些视为函数调用。 一个加载器的输出作为输入提供给下一个： styleLoader(cssLoader(sassLoader(&quot;source&quot;))) 让我们添加一个Sass源文件，import是一个模块。 src/style.scss $bluegrey: #2b3a42; pre { padding: 8px 16px; background: $bluegrey; color: #e1e6e9; font-family: Menlo, Courier, monospace; font-size: 13px; line-height: 1.5; text-shadow: 0 1px 0 rgba(23, 31, 35, 0.5); border-radius: 3px; } src/index.js import { groupBy } from &#39;lodash-es&#39; import people from &#39;./people&#39; import &#39;./style.scss&#39; ... 使用Ctrl + C和npm run develop重新启动构建。 在浏览器中刷新index.html，您应该看到一些样式。 JS中的样式表我们刚从JavaScript中导入了一个Sass文件作为模块。 打开dist / bundle.js并搜索“pre {”。 实际上，我们的Sass已被编译为一串CSS并在我们的包中保存为模块。 当我们将这个模块导入JavaScript时，style-loader将字符串输出到嵌入的&lt;style>标记中。 你为什么需要做这样的事？ 我不会在这里深入研究这个主题，但这里有几个理由需要考虑： 您可能希望包含在项目中的JavaScript组件可能依赖于其他资源才能正常运行（HTML，CSS，图像，SVG）。 如果这些都可以捆绑在一起，则导入和使用起来要容易得多。 消除Dead code：当代码不再导入JS组件时，也不再导入CSS。 生成的包只会包含执行某些操作的代码。 CSS模块：CSS的全局命名空间使得很难确信对CSS的更改不会产生任何副作用。 CSS模块通过设置CSS默认本地并显示您可以在JavaScript中引用的唯一类名来解决该问题。 通过巧妙的方式捆绑/拆分代码来减少HTTP请求的数量。 图片我们将看到的最后一个加载器示例是使用文件加载器处理图像。 在标准HTML文档中，当浏览器遇到img标记或具有background-image属性的元素时，将获取图像。 使用Webpack，您可以在小图像的情况下通过将图像源作为字符串存储在JavaScript中来优化它。 通过执行此操作，您可以预加载它们，浏览器不必在以后使用单独的请求获取它们： npm install --save-dev file-loader webpack.config.js module.exports = { ... module: { rules: [ ... { test: /\.(png|svg|jpg|gif)$/, use: [ { loader: &#39;file-loader&#39; } ] } ] } } 用以下命令下载一个测试图像： curl https://raw.githubusercontent.com/sitepoint-editors/webpack-demo/master/src/code.png --output src/code.png 使用Ctrl + C和npm run develop重新启动构建，您现在可以将图像作为模块导入！ src/index.js import { groupBy } from &#39;lodash-es&#39; import people from &#39;./people&#39; import &#39;./style.scss&#39; import &#39;./image-example&#39; ... src/image-example.js import codeURL from &quot;./code.png&quot; const img = document.createElement(&quot;img&quot;) img.src = codeURL img.style = &quot;background: #2B3A42; padding: 20px&quot; img.width = 32 document.body.appendChild(img) 这将包括一个图像，其中src属性包含图像本身的数据URI： &lt;img src=&quot;data:image/png;base64,iVBO...&quot; style=&quot;background: #2B3A42; padding: 20px&quot; width=&quot;32&quot;&gt; 我们的CSS中的背景图像也由文件加载器处理。 src/style.scss $bluegrey: #2b3a42; pre { padding: 8px 16px; background: $bluegrey; background: $bluegrey url(&quot;code.png&quot;) no-repeat center center / 32px 32px; color: #e1e6e9; font-family: Menlo, Courier, monospace; font-size: 13px; line-height: 1.5; text-shadow: 0 1px 0 rgba(23, 31, 35, 0.5); border-radius: 3px; } 在文档中查看更多Loaders示例： 加载字体 加载数据 依赖图 Dependency Graph您现在应该能够看到加载器如何帮助您在资源中构建依赖关系树。 这就是Webpack主页上的图像所展示的内容。 尽管JavaScript是切入点，但Webpack明白您的其他资源类型（如HTML，CSS和SVG）各自具有自己的依赖关系，这应该被视为构建过程的一部分。 代码拆分Webpack文档中写到： 代码拆分是Webpack最引人注目的功能之一。 此功能允许您将代码拆分为各种捆绑包，然后可以按需或并行加载。 它可用于实现更小的捆绑并控制资源负载优先级，如果使用得当，可能会对加载时间产生重大影响。 到目前为止，我们只看到了一个入口点 - src / index.js - 和一个输出包 - dist / bundle.js。 当您的应用程序增长时，您需要将其拆分，以便在开始时不会下载整个代码库。 一种好的方法是使用Code Splitting和Lazy Loading来按需获取内容，因为代码路径需要它们。 我们通过添加一个“聊天”模块来证明这一点，该模块在有人与之交互时被提取和初始化。 我们将创建一个新的入口点并为其命名，我们还将使输出的文件名动态，因此每个块的不同。 webpack.config.js const path = require(&#39;path&#39;) module.exports = { entry: &#39;./src/index.js&#39;, entry: { app: &#39;./src/app.js&#39; }, output: { filename: &#39;bundle.js&#39;, filename: &#39;[name].bundle.js&#39;, path: path.resolve(__dirname, &#39;dist&#39;) }, ... } src/app.js import &#39;./app.scss&#39; const button = document.createElement(&quot;button&quot;) button.textContent = &#39;Open chat&#39; document.body.appendChild(button) button.onclick = () =&gt; { import(/* webpackChunkName: &quot;chat&quot; */ &quot;./chat&quot;).then(chat =&gt; { chat.init() }) } src/chat.js import people from &quot;./people&quot; export function init() { const root = document.createElement(&quot;div&quot;) root.innerHTML = `&lt;p&gt;There are ${people.length} people in the room.&lt;/p&gt;` document.body.appendChild(root) } src/app.scss button { padding: 10px; background: #24b47e; border: 1px solid rgba(#000, .1); border-width: 1px 1px 3px; border-radius: 3px; font: inherit; color: #fff; cursor: pointer; text-shadow: 0 1px 0 rgba(#000, .3), 0 1px 1px rgba(#000, .2); } 注意：尽管/ webpackChunkName / comment为包提供了名称，但此语法不是特定于Webpack的。 它是动态导入的建议语法，旨在直接在浏览器中支持。 我们运行npm run build并查看它生成的内容： Asset Size Chunks Chunk Names chat.bundle.js 377 bytes 0 [emitted] chat app.bundle.js 7.65 KiB 1 [emitted] app 由于我们的条目包已经更改，我们还需要更新它的路径。 dist/index.html &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Hello Webpack&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;app.bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 我们从dist目录启动一个服务器，看看这个实际应用： cd dist npx serve 在浏览器中打开http://localhost:5000，看看会发生什么。 最初只获取bundle.js。 单击该按钮时，将导入并初始化聊天模块。 只需很少的工作，我们就可以在我们的应用程序中添加动态代码拆分和延迟加载模块。 这是构建高性能Web应用程序的一个很好的起点。 插件当加载器对单个文件进行转换时，插件可以在更大的代码块上运行。 现在我们正在打包代码，外部模块和静态资产，我们的包将会迅速增长。 插件可以帮助我们以巧妙的方式分割代码并优化生产。 在不知情的情况下，我们实际上已经使用了许多默认的Webpack插件“模式” 发展 提供process.env.NODE_ENV，其值为“development” NamedModulesPlugin 生产 提供process.env.NODE_ENV，其值为“production” UglifyJsPlugin ModuleConcatenationPlugin NoEmitOnErrorsPlugin 产品在添加其他插件之前，我们首先拆分我们的配置，以便我们可以应用特定于每个环境的插件。 将webpack.config.js重命名为webpack.common.js并添加用于开发和生产的配置文件。 - |- webpack.config.js + |- webpack.common.js + |- webpack.dev.js + |- webpack.prod.js 我们将使用webpack-merge将我们的公共配置与特定于环境的配置相结合： npm install --save-dev webpack-merge webpack.dev.js const merge = require(&#39;webpack-merge&#39;) const common = require(&#39;./webpack.common.js&#39;) module.exports = merge(common, { mode: &#39;development&#39; }) webpack.prod.js const merge = require(&#39;webpack-merge&#39;) const common = require(&#39;./webpack.common.js&#39;) module.exports = merge(common, { mode: &#39;production&#39; }) package.json &quot;scripts&quot;: { &quot;develop&quot;: &quot;webpack --watch --mode development&quot;, &quot;build&quot;: &quot;webpack --mode production&quot; &quot;develop&quot;: &quot;webpack --watch --config webpack.dev.js&quot;, &quot;build&quot;: &quot;webpack --config webpack.prod.js&quot; }, 现在我们可以将特定于开发的插件添加到webpack.dev.js和webpack.prod.js中特定于生产的插件中。 拆分CSS在使用ExtractTextWebpackPlugin捆绑生产时，最好将CSS与JavaScript分开。 当前的.scss加载器非常适合开发，所以我们将把它们从webpack.common.js移到webpack.dev.js中，并将ExtractTextWebpackPlugin添加到webpack.prod.js中。 npm install --save-dev extract-text-webpack-plugin@4.0.0-beta.0 webpack.common.js ... module.exports = { ... module: { rules: [ ... - { - test: /\.scss$/, - use: [ - { - loader: &#39;style-loader&#39; - }, { - loader: &#39;css-loader&#39; - }, { - loader: &#39;sass-loader&#39; - } - ] - }, ... ] } } webpack.dev.js const merge = require(&#39;webpack-merge&#39;) + const ExtractTextPlugin = require(&#39;extract-text-webpack-plugin&#39;) const common = require(&#39;./webpack.common.js&#39;) module.exports = merge(common, { mode: &#39;production&#39;, module: { rules: [ { test: /\.scss$/, use: ExtractTextPlugin.extract({ fallback: &#39;style-loader&#39;, use: [&#39;css-loader&#39;, &#39;sass-loader&#39;] }) } ] }, plugins: [ new ExtractTextPlugin(&#39;style.css&#39;) ] }) 我们来比较两个构建脚本的输出： &gt; npm run develop Asset Size Chunks Chunk Names app.bundle.js 28.5 KiB app [emitted] app chat.bundle.js 1.4 KiB chat [emitted] chat &gt; npm run build Asset Size Chunks Chunk Names chat.bundle.js 375 bytes 0 [emitted] chat app.bundle.js 1.82 KiB 1 [emitted] app style.css 424 bytes 1 [emitted] app 现在CSS被从JavaScript包中提取出来用于生产，我们需要从我们的HTML &lt;link>到它。 dist/index.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Code Splitting&lt;/title&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;app.bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 这允许在浏览器中并行下载CSS和JavaScript，因此加载速度比单个捆绑包更快。 它还允许在JavaScript完成下载之前显示样式。 生成HTML每当我们的输出发生变化时，我们必须不断更新index.html以引用新的文件路径。 这正是html-webpack-plugin自动为我们创建的。 我们也可以在每次构建之前同时添加clean-webpack-plugin来清除/dist目录。 npm install --save-dev html-webpack-plugin clean-webpack-plugin webpack.common.js const path = require(&#39;path&#39;) const CleanWebpackPlugin = require(&#39;clean-webpack-plugin&#39;); const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); module.exports = { ... plugins: [ new CleanWebpackPlugin([&#39;dist&#39;]), new HtmlWebpackPlugin({ title: &#39;My killer app&#39; }) ] } 现在每次我们建立时，dist都会被清除掉。 我们现在也会看到index.html输出，以及我们的入口包的正确路径。 运行npm run develop会产生以下结果： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;My killer app&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;app.bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 而npm run build产生了这个： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;My killer app&lt;/title&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;app.bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 发展webpack-dev-server为您提供了一个简单的Web服务器，并为您提供实时重新加载，因此您无需手动刷新页面即可查看更改。 npm install --save-dev webpack-dev-server package.json { ... &quot;scripts&quot;: { &quot;develop&quot;: &quot;webpack --watch --config webpack.dev.js&quot;, &quot;develop&quot;: &quot;webpack-dev-server --config webpack.dev.js&quot;, } ... } &gt; npm run develop ｢wds｣: Project is running at http://localhost:8080/ ｢wds｣: webpack output is served from / 在浏览器中打开http://localhost:8080/并对其中一个JavaScript或CSS文件进行更改。 您应该看到它自动构建和刷新。 HotModuleReplacementHotModuleReplacement插件比Live Reloading更进一步，并在运行时交换模块而无需刷新。 正确配置后，这可以节省开发单页应用程序的大量时间。 如果页面中有很多状态，则可以对组件进行增量更改，只更换和更新已更改的模块。 webpack.dev.js const webpack = require(&#39;webpack&#39;) const merge = require(&#39;webpack-merge&#39;) const common = require(&#39;./webpack.common.js&#39;) module.exports = merge(common, { mode: &#39;development&#39;, devServer: { hot: true }, plugins: [ new webpack.HotModuleReplacementPlugin() ], ... } 现在我们需要从代码中接受更改的模块来重新初始化事物。 src/app.js if (module.hot) { module.hot.accept() } ... 注意：启用热模块替换时，module.hot设置为true以进行开发，false设置为生产，因此这些将从捆绑中剥离。 重新启动构建，看看执行以下操作时会发生什么： 单击打开聊天 将新人添加到people.js模块 再次单击“打开聊天” 这是发生了什么： 单击“打开聊天”时，将获取并初始化chat.js模块 HMR检测perple.js何时被修改 index.js中的module.hot.accept（）会导致替换此条目块加载的所有模块 再次单击“打开聊天”时，将使用更新模块中的代码运行chat.init（）。 CSS替换让我们将按钮颜色更改为红色，看看会发生什么： src/app.scss button { ... background: #24b47e; background: red; ... } 现在我们可以看到我们的样式的即时更新，而不会丢失任何状态。这是一个大大改善的开发人员体验！感觉就像未来。 HTTP/2使用像Webpack这样的module bundler的主要好处之一是它可以帮助您控制资源的构建方式，然后在客户端上获取，从而帮助您提高性能。多年来，连接文件以减少需要在客户端上进行的请求数量被认为是最佳实践。这仍然有效，但HTTP/2现在允许在单个请求中传递多个文件，因此连接不再是银弹。您的应用程序实际上可能会受益于单独缓存许多小文件。然后，客户端可以获取单个已更改的模块，而不必再次获取具有大部分相同内容的整个包。 Webpack的创建者Tobias Koppers撰写了一篇内容丰富的文章，解释了为什么捆绑仍然很重要，即使在HTTP/2时代也是如此。 在Webpack和HTTP / 2上阅读更多相关信息。 给你的话我希望你已经发现Webpack的这个介绍很有帮助，并且能够开始使用它并产生很大的效果。可能需要一些时间来围绕Webpack的配置，加载器和插件，但了解这个工具如何工作将会有所回报。 Webpack 4的文档目前正在进行中，但实际上很好地组合在一起。我强烈建议您阅读概念和指南以获取更多信息。以下是您可能感兴趣的一些其他主题： 源地图开发 生产的源地图 缓存破坏与散列文件名 拆分供应商包 Webpack 4是您选择的module bundler吗？请在下面的评论中告诉我。]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>WebPack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How To Build Personal Blog By Hexo]]></title>
    <url>%2FXDATA.Blog%2F2018%2F06%2F13%2FHEXO%2FHow-To-Build-Personal-Blog-By-Hexo%2F</url>
    <content type="text"><![CDATA[Hexo,Github搭建个人Blog踩坑准备工作 下载安装node.js(推荐使用淘宝npm镜像) 下载安装git 下载安装github desktop(用于blog与github关联时验证账户) 利用npm安装hexo( npm install -g hexo) 部署Hexo 创建工作空间,cd到工作空间 初始化hexo hexo init 安装依赖(npm install) 本地启动 发布静态网页(hexo g),在public目录下 启动本地服务器(hexo server),默认端口4000 将博客与Github关联 在Github上创建名字为XXX.github.io的项目,XXX为自己的github用户名。 打开工作空间下的_config.yml配置文件，添加配置 运行npm install hexo-deployer-git -save hexo g生成静态文件 hexo d将本地静态文件推送至github,中途可能会进行用户验证 浏览器访问https://hertz9409.github.io/ 创建博客文章并发布 hexo new “my new md” 编写markdown内容 hexo clean,删除本地静态文件 hexo g,重新生成本地静态文件 hexo deploy,将本地静态文件推送至github 在文章中使用图片方法一 在文章中写入 在themes主题文件夹下source目录下，新建目录upload_image，把图片放到该目录下 执行hexo g命令时会自动上传图片方法二 安装npm插件hexo-asset-image 使用主题 进入主题商店,查看主题 cd 工作空间中的themes文件夹 执行命令git clone https://github.com/Ben02/hexo-theme-Anatole.git themes/anatole 主题更新cd anatole git pull 常见MarkDown语法]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
